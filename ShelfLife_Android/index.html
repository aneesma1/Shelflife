<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Home Library by Anees</title>

    <!-- PWA MANIFEST (Embedded) -->
    <link rel="manifest"
        href="data:application/manifest+json;base64,ewogICAgIm5hbWUiOiAiU2hlbGZMaWZlIFVsdGltYXRlIiwKICAgICJzaG9ydF9uYW1lIjogIlNoZWxZTGlmZSIsCiAgICAic3RhcnRfdXJsIjogIi4iLAogICAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgICAiYmFja2dyb3VuZF9jb2xvciI6ICIjZjNmNGY2IiwKICAgICJ0aGVtZV9jb2xvciI6ICIjMjU2M2ViIiwKICAgICJpY29ucyI6IFtdCn0=">

    <!-- OFFLINE LIBRARIES (Downloaded via Cloud Build) -->
    <script src="libs/react.js"></script>
    <script src="libs/react-dom.js"></script>
    <script src="libs/babel.min.js"></script>
    <script src="libs/tailwindcss.js"></script>
    <script src="libs/dexie.js"></script>
    <script src="libs/html5-qrcode.min.js"></script>
    <script src="libs/jszip.min.js"></script>

    <!-- OFFLINE FONTS (Bundled in APK) -->
    <style>
        @font-face {
            font-family: 'Noto Sans';
            font-weight: 400;
            src: url('fonts/NotoSans-Regular.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Noto Sans';
            font-weight: 700;
            src: url('fonts/NotoSans-Bold.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Noto Sans Malayalam';
            src: url('fonts/NotoSansMalayalam.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Noto Sans Arabic';
            src: url('fonts/NotoSansArabic.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Noto Sans Devanagari';
            src: url('fonts/NotoSansDevanagari.woff2') format('woff2');
        }
    </style>

    <style>
        body {
            font-family: 'Noto Sans', sans-serif;
            background-color: #f3f4f6;
            overscroll-behavior: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* PWA Text Selection Override */
        body.is-pwa #tbody,
        body.is-pwa .card,
        body.is-pwa td,
        body.is-pwa th,
        body.is-pwa div,
        .modal-content,
        .modal-content * {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }

        .font-ml {
            font-family: 'Noto Sans Malayalam', sans-serif;
        }

        .font-ar {
            font-family: 'Noto Sans Arabic', sans-serif;
        }

        .font-hi {
            font-family: 'Noto Sans Devanagari', sans-serif;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .pie-chart {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: conic-gradient(var(--pie-gradient));
        }

        /* Disable overscroll in modal overlays (prevent native pull-to-refresh) */
        .modal-overlay {
            overscroll-behavior: none !important;
            /* Note: touch-action handled by JS isModalOpen() check */
        }

        /* Allow scrolling inside modal content but prevent overscroll */
        .modal-content {
            overscroll-behavior: contain;
        }

        /* Pull to Refresh Spinner */
        #ptr-spinner {
            position: fixed;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: top 0.3s ease;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="ptr-spinner">
        <div className="spinner"></div>
    </div>
    <div id="root"></div>

    <script>
        // --- SERVICE WORKER REGISTRATION (Robust for PWA) ---
        if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || window.location.hostname === 'localhost')) {
            const swCode = `
        const CACHE_NAME = 'shelflife-v2';
        const FILES_TO_CACHE = [
            './',
            'https://unpkg.com/react@18/umd/react.development.js',
            'https://unpkg.com/react-dom@18/umd/react-dom.development.js',
            'https://unpkg.com/@babel/standalone/babel.min.js',
            'https://cdn.tailwindcss.com',
            'https://unpkg.com/dexie@3.2.4/dist/dexie.js',
            'https://unpkg.com/html5-qrcode',
            'https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&family=Noto+Sans+Malayalam&family=Noto+Sans+Arabic&family=Noto+Sans+Devanagari&display=swap'
        ];
        
        self.addEventListener('install', (evt) => {
            evt.waitUntil(
                caches.open(CACHE_NAME).then((cache) => {
                    return cache.addAll(FILES_TO_CACHE).catch(err => console.log('Cache error:', err));
                })
            );
            self.skipWaiting();
        });

        self.addEventListener('activate', (evt) => {
            evt.waitUntil(self.clients.claim());
        });

        self.addEventListener('fetch', (evt) => {
            evt.respondWith(
                caches.match(evt.request).then((resp) => {
                    return resp || fetch(evt.request).catch(() => new Response("Offline"));
                })
            );
        });
    `;

            // Create blob URL for SW
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);

            navigator.serviceWorker.register(swUrl)
                .then((reg) => console.log('SW Registered'))
                .catch((err) => console.log('SW Failed:', err));
        }
    </script>



    <script type="text/babel">

        // ==========================================
        // 1. UTILITIES
        // ==========================================

        const ImageUtils = {
            // Process image with proper memory cleanup
            process: (file, maxWidth = 500, quality = 0.65) => new Promise((resolve, reject) => {
                // Validate file size (max 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    reject(new Error('Image too large. Max 10MB allowed.'));
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();

                    // Cleanup function for Image object
                    const cleanup = () => {
                        img.onload = null;
                        img.onerror = null;
                        img.src = '';
                    };

                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            let w = img.width, h = img.height;

                            // More aggressive resizing for memory savings
                            if (w > maxWidth) {
                                h = Math.round(h * (maxWidth / w));
                                w = maxWidth;
                            }

                            canvas.width = w;
                            canvas.height = h;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, w, h);

                            // Use WebP for smaller size
                            const result = canvas.toDataURL('image/webp', quality);

                            // Cleanup canvas
                            canvas.width = 0;
                            canvas.height = 0;
                            cleanup();

                            resolve(result);
                        } catch (err) {
                            cleanup();
                            reject(err);
                        }
                    };

                    img.onerror = (err) => {
                        cleanup();
                        reject(new Error('Failed to load image'));
                    };

                    img.src = e.target.result;
                };

                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            }),

            // Create smaller thumbnail for list view (optimize memory)
            createThumbnail: (base64, maxSize = 100) => new Promise((resolve) => {
                if (!base64 || base64 === 'loading') {
                    resolve(null);
                    return;
                }

                const img = new Image();
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        let w = img.width, h = img.height;

                        if (w > h) {
                            h = Math.round(h * (maxSize / w));
                            w = maxSize;
                        } else {
                            w = Math.round(w * (maxSize / h));
                            h = maxSize;
                        }

                        canvas.width = w;
                        canvas.height = h;
                        canvas.getContext('2d').drawImage(img, 0, 0, w, h);

                        const result = canvas.toDataURL('image/webp', 0.5);
                        canvas.width = 0;
                        canvas.height = 0;
                        img.src = '';
                        resolve(result);
                    } catch {
                        resolve(base64); // Fallback to original
                    }
                };
                img.onerror = () => resolve(null);
                img.src = base64;
            }),

            // Compress data URL (for Capacitor Camera output)
            compressDataUrl: (dataUrl, maxWidth = 500, quality = 0.65) => new Promise((resolve, reject) => {
                if (!dataUrl) {
                    resolve(null);
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        let w = img.width, h = img.height;
                        if (w > maxWidth) {
                            h = Math.round(h * (maxWidth / w));
                            w = maxWidth;
                        }
                        canvas.width = w;
                        canvas.height = h;
                        canvas.getContext('2d').drawImage(img, 0, 0, w, h);
                        const result = canvas.toDataURL('image/webp', quality);
                        canvas.width = 0;
                        canvas.height = 0;
                        img.src = '';
                        resolve(result);
                    } catch (err) {
                        resolve(dataUrl); // Fallback
                    }
                };
                img.onerror = () => resolve(dataUrl);
                img.src = dataUrl;
            })
        };

        // Initialize Capacitor Enums globally for script usage
        const Directory = {
            Documents: 'DOCUMENTS',
            Data: 'DATA',
            Cache: 'CACHE',
            External: 'EXTERNAL', // often maps to generic external storage
            ExternalStorage: 'EXTERNAL_STORAGE' // Android specific
        };

        const Encoding = {
            UTF8: 'utf8',
            ASCII: 'ascii',
            UTF16: 'utf16'
        };

        // Platform detection helpers - safe checks for Tauri vs Capacitor vs Browser
        const isNativeCapacitor = () => !!(window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Filesystem);
        const isTauri = () => !!window.__TAURI__;

        const ExportUtils = {
            getTimestamp: () => {
                const now = new Date();
                const d = now.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }).replace(/ /g, '-');
                const t = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' }).replace(/:/g, '-');
                return `${d}_${t}`;
            },
            download: async (content, name, mimeType, specificFolder = null, specificBase = null) => {
                if (isNativeCapacitor()) {
                    try {
                        const { Filesystem } = window.Capacitor.Plugins;
                        // Use specific folder if provided, else default to ShelfLife/Exports
                        const folder = specificFolder || 'ShelfLife/Exports';
                        const baseStr = specificBase || localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';

                        // Map string to Directory Constant
                        // Note: We use global Directory object defined above
                        const targetDir = Directory[baseStr] || Directory.Documents;

                        // Ensure folder exists
                        try {
                            await Filesystem.mkdir({
                                path: folder, // Write relative to Base (e.g. Documents/ShelfLife)
                                directory: targetDir,
                                recursive: true
                            });
                        } catch (e) { }

                        const cleanPath = folder ? `${folder}/${name}` : name;

                        await Filesystem.writeFile({
                            path: cleanPath,
                            data: content,
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        alert(`Saved to: ${baseStr}/${cleanPath}`);
                    } catch (e) {
                        console.error(e);
                        alert("Save failed. " + e.message);
                    }
                } else {
                    // Browser Download
                    try {
                        let dataUri = '';
                        if (mimeType === 'application/json' || mimeType.includes('text')) {
                            // Use UTF-8 BOM only for CSV to assist Excel opening
                            const prefix = mimeType.includes('csv') ? "\uFEFF" : "";
                            const base64 = btoa(unescape(encodeURIComponent(prefix + content)));
                            dataUri = `data:${mimeType};base64,${base64}`;
                        } else {
                            dataUri = content;
                        }
                        const a = document.createElement('a');
                        a.href = dataUri;
                        a.download = name;
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => document.body.removeChild(a), 100);
                    } catch (e) {
                        alert("Export failed: " + e.message);
                    }
                }
            },
            csv: (books, filenamePrefix = "ShelfLife_Export", specificFolder = null, specificBase = null) => {
                const folder = specificFolder || 'ShelfLife/Exports';
                const base = specificBase || localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS';

                const maxTags = books.reduce((max, b) => Math.max(max, (b.tags || []).length), 0);
                let header = "ID,Title,AuthorName,AuthorInitials,Publisher,Year,Pages,Condition,Price,Currency,Owner,Building,Shelf,ISBN,Status";
                for (let i = 1; i <= maxTags; i++) header += `,Tag_${i}`;
                header += "\n";
                const rows = books.map(b => {
                    // ESCAPE HELPER: Ensures every field is properly quoted and internal quotes are doubled
                    const esc = (val) => `"${String(val || '').replace(/"/g, '""')}"`;

                    const core = [
                        esc(b.id),
                        esc(b.title),
                        esc(b.author_name || b.author),
                        esc(b.author_initials),
                        esc(b.publisher),
                        esc(b.pub_year),
                        esc(b.page_count),
                        esc(b.condition),
                        esc(b.price),
                        esc(b.currency),
                        esc(b.owner),
                        esc(b.building),
                        esc(b.shelf),
                        esc('\t' + (b.isbn || '')), // ISBN (Force Text with Tab)
                        esc(b.status)
                    ].join(',');

                    const tags = (b.tags || []);
                    const tagCells = Array.from({ length: maxTags }, (_, i) => esc(tags[i])).join(',');
                    return `${core},${tagCells}`;
                }).join('\n');

                // Sanitize filename
                const safePrefix = filenamePrefix.replace(/[^a-z0-9_]/gi, '_');
                const timestamp = ExportUtils.getTimestamp().replace(/[-:]/g, ''); // Compact timestamp
                ExportUtils.download("\uFEFF" + header + rows, `${safePrefix}_${timestamp}.csv`, "text/csv;charset=utf-8", folder, base);
            },
            htmlText: (books, type, title = "Library Inventory", specificFolder = null, specificBase = null) => {
                const folder = specificFolder || 'ShelfLife/Exports';
                const base = specificBase || localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS';

                let html = `<html><head><meta charset="UTF-8"><style>body{font-family:sans-serif;padding:20px;} table{width:100%;border-collapse:collapse;} th,td{border:1px solid #ddd;padding:8px;} th{background:#f3f3f3;} tr:nth-child(even){background:#f9f9f9;}</style></head><body><h1>${title}</h1><table><tr><th>Title</th><th>Author</th><th>Publisher</th><th>Year</th><th>Loc</th><th>Cond</th><th>Price</th></tr>${books.map(b => `<tr><td>${b.title}</td><td>${b.author_name || b.author} ${b.author_initials || ''}</td><td>${b.publisher}</td><td>${b.pub_year}</td><td>${b.building} ${b.shelf}</td><td>${b.condition}</td><td>${b.currency || ''} ${b.price}</td></tr>`).join('')}</table></body></html>`;
                ExportUtils.download(html, `ShelfLife_List_${ExportUtils.getTimestamp()}.html`, "text/html;charset=utf-8", folder, base);
            },
            htmlVisual: (books, type, title = "Visual Catalogue", specificFolder = null, specificBase = null) => {
                const folder = specificFolder || 'ShelfLife/Exports';
                const base = specificBase || localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS';

                let html = `<html><head><meta charset="UTF-8"><style>body{font-family:sans-serif;padding:20px;} .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:20px;} .card{border:1px solid #ddd;padding:10px;text-align:center;border-radius:8px;} img{width:100%;height:150px;object-fit:cover;margin-bottom:10px;border-radius:4px;} .meta{font-size:12px;color:#666;}</style></head><body><h1>${title}</h1><div class="grid">${books.map(b => `<div class="card">${b.front ? `<img src="${b.front}"/>` : ''}<b>${b.title}</b><br><small>${b.author_name || b.author} ${b.author_initials || ''}</small><br><span class="meta">${b.publisher} ‚Ä¢ ${b.pub_year}</span></div>`).join('')}</div></body></html>`;
                ExportUtils.download(html, `ShelfLife_Visual_${ExportUtils.getTimestamp()}.html`, "text/html;charset=utf-8", folder, base);
            },
            htmlDashboard: (books, title = "Library Dashboard", specificFolder = null, specificBase = null) => {
                const folder = specificFolder || 'ShelfLife/Exports';
                const base = specificBase || localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS';

                // Prepare book data - escape special chars for JSON in HTML
                const booksData = books.map(b => ({
                    id: b.id || Math.random().toString(36).substr(2, 9),
                    title: (b.title || '').replace(/[<>&"']/g, c => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;' }[c] || c)),
                    author: ((b.author_name || b.author || '')).replace(/[<>&"']/g, c => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;' }[c] || c)),
                    publisher: (b.publisher || '').replace(/[<>&"']/g, c => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;' }[c] || c)),
                    year: b.pub_year || '', building: b.building || '', shelf: b.shelf || '', owner: b.owner || '',
                    condition: b.condition || '', lang: b.lang || 'en', price: b.price || '', currency: b.currency || '',
                    isbn: b.isbn || '', status: b.status || 'avail', tags: (b.tags || []).map(t => t.replace(/[<>&"']/g, '')),
                    front: b.front ? 'yes' : '', dateAdded: b.dateAdded || ''
                }));

                const stats = {
                    total: booksData.length, authors: new Set(booksData.map(b => b.author).filter(Boolean)).size,
                    buildings: new Set(booksData.map(b => b.building).filter(Boolean)).size,
                    languages: new Set(booksData.map(b => b.lang)).size,
                    tags: new Set(booksData.flatMap(b => b.tags)).size,
                    owners: new Set(booksData.map(b => b.owner).filter(Boolean)).size,
                    available: booksData.filter(b => b.status === 'avail').length,
                    lent: booksData.filter(b => b.status === 'lent').length,
                    withCover: booksData.filter(b => b.front).length,
                    noCover: booksData.filter(b => !b.front).length
                };

                const languages = {}, buildings = {}, conditions = {}, owners = {};
                booksData.forEach(b => {
                    languages[b.lang] = (languages[b.lang] || 0) + 1;
                    if (b.building) buildings[b.building] = (buildings[b.building] || 0) + 1;
                    if (b.condition) conditions[b.condition] = (conditions[b.condition] || 0) + 1;
                    if (b.owner) owners[b.owner] = (owners[b.owner] || 0) + 1;
                });
                const langMap = { en: 'English', ml: 'Malayalam', hi: 'Hindi', ar: 'Arabic', ur: 'Urdu', fa: 'Persian' };

                // Calculate max tags for CSV export
                const maxTags = booksData.reduce((max, b) => Math.max(max, (b.tags || []).length), 0);

                // Generate table rows at export time (not in JS)
                const tableRows = booksData.map(b =>
                    '<tr data-lang="' + (langMap[b.lang] || b.lang) + '" data-building="' + b.building + '" data-owner="' + b.owner + '" data-tags="' + b.tags.join('|') + '"><td style="font-weight:600" class="col-title">' + b.title + '</td><td class="col-author">' + b.author + '</td><td class="col-lang">' + (langMap[b.lang] || b.lang) + '</td><td class="col-building">' + b.building + '</td><td class="col-shelf hidden">' + b.shelf + '</td><td class="col-owner">' + b.owner + '</td><td class="col-year hidden">' + b.year + '</td><td class="col-condition">' + b.condition + '</td><td class="col-status status-' + b.status + '">' + (b.status === 'avail' ? 'Available' : b.status === 'lent' ? 'Lent' : 'Sold') + '</td><td class="col-isbn hidden">' + b.isbn + '</td><td class="col-tags">' + b.tags.map(t => '<span class="tag">' + t + '</span>').join('') + '</td></tr>'
                ).join('');

                const html = `<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>${title} - ShelfLife</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--primary:#EA580C;--primary-dark:#C2410C;--primary-light:#FFEDD5;--sidebar-bg:#431407;--sidebar-hover:#7C2D12;--bg:#FFF7ED;--text:#431407;--text-muted:#9A3412;--border:#FED7AA}
body{font-family:system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text);display:flex;min-height:100vh}
.sidebar{width:260px;background:var(--sidebar-bg);color:#FFEDD5;position:fixed;height:100vh;overflow-y:auto;z-index:50}
.sidebar-header{padding:20px;border-bottom:1px solid rgba(255,255,255,0.1)}
.logo{font-size:20px;font-weight:700;display:flex;align-items:center;gap:10px;color:white}
.sidebar-content{padding:16px}
.filter-section{margin-bottom:16px}
.section-title{font-size:11px;text-transform:uppercase;color:#FDBA74;font-weight:600;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.1);margin-bottom:8px}
.filter-option{display:flex;align-items:center;gap:8px;padding:4px 6px;border-radius:4px;cursor:pointer;font-size:12px;color:#FFEDD5}
.filter-option:hover{background:var(--sidebar-hover)}
.filter-option input{width:14px;height:14px;accent-color:var(--primary)}
.count{margin-left:auto;background:rgba(0,0,0,0.2);padding:2px 6px;border-radius:4px;font-size:10px;color:#FDBA74}
.main{flex:1;margin-left:260px;padding:20px}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;flex-wrap:wrap;gap:12px}
.page-title{font-size:24px;font-weight:800}
.header-subtitle{color:var(--text-muted);font-size:13px;margin-top:4px}
.btn{padding:8px 14px;border-radius:6px;font-weight:500;cursor:pointer;display:inline-flex;align-items:center;gap:6px;font-size:12px;border:1px solid var(--border);background:white;color:var(--text)}
.btn:hover{background:#FFF7ED;border-color:var(--primary)}
.btn-primary{background:var(--primary);color:white;border-color:var(--primary)}
.quick-filters{display:flex;gap:6px;margin-bottom:16px;flex-wrap:wrap}
.quick-btn{padding:6px 12px;border-radius:16px;font-size:11px;font-weight:500;cursor:pointer;border:1px solid var(--border);background:white;color:var(--text)}
.quick-btn:hover,.quick-btn.active{background:var(--primary);color:white;border-color:var(--primary)}
.stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px;margin-bottom:20px}
.stat-card{background:white;padding:16px;border-radius:12px;border:2px solid var(--border);cursor:pointer;transition:all 0.2s}
.stat-card:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.1);border-color:var(--primary)}
.stat-icon{font-size:24px;margin-bottom:8px}
.stat-label{font-size:10px;text-transform:uppercase;color:var(--text-muted);font-weight:600}
.stat-value{font-size:28px;font-weight:800;color:var(--text)}
.toolbar{display:flex;gap:10px;margin-bottom:12px;flex-wrap:wrap;align-items:center}
.search-box{flex:1;min-width:180px;position:relative}
.search-box input{width:100%;padding:8px 12px 8px 32px;border:1px solid var(--border);border-radius:6px;font-size:13px}
.search-box input:focus{outline:none;border-color:var(--primary)}
.search-icon{position:absolute;left:10px;top:50%;transform:translateY(-50%)}
.dropdown{position:relative;display:inline-block}
.dropdown-content{display:none;position:absolute;background:white;min-width:200px;box-shadow:0 8px 16px rgba(0,0,0,0.15);border-radius:8px;z-index:100;padding:12px;right:0;top:100%}
.dropdown:hover .dropdown-content{display:block}
.dropdown-content label{display:flex;align-items:center;gap:6px;padding:4px 0;font-size:12px;cursor:pointer}
.table-container{background:white;border:1px solid var(--border);border-radius:10px;overflow-x:auto}
table{width:100%;border-collapse:collapse}
th{text-align:left;padding:10px 12px;background:#FFEDD5;color:#9A3412;font-size:10px;text-transform:uppercase;font-weight:700;border-bottom:1px solid var(--border);white-space:nowrap;cursor:pointer}
th:hover{background:#FED7AA}
td{padding:8px 12px;border-bottom:1px solid var(--border);font-size:12px}
tr:hover td{background:#FFF7ED}
.tag{display:inline-block;padding:2px 6px;background:#F3F4F6;border-radius:10px;font-size:9px;margin-right:3px;color:#4B5563}
.status-avail{color:#059669;font-weight:600}
.status-lent{color:#DC2626;font-weight:600}
.status-sold{color:#6B7280;font-weight:600}
.results-info{font-size:12px;color:var(--text-muted);margin-bottom:8px}
.hidden{display:none!important}
.modal-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:1000;justify-content:center;align-items:center}
.modal-overlay.show{display:flex}
.modal-box{background:white;border-radius:16px;max-width:500px;width:90%;max-height:80vh;overflow:hidden;box-shadow:0 20px 40px rgba(0,0,0,0.3);animation:modalIn 0.2s ease}
@keyframes modalIn{from{transform:scale(0.9);opacity:0}to{transform:scale(1);opacity:1}}
.modal-header{background:linear-gradient(135deg,var(--primary) 0%,var(--primary-dark) 100%);color:white;padding:16px 20px;display:flex;justify-content:space-between;align-items:center}
.modal-title{font-size:18px;font-weight:700;display:flex;align-items:center;gap:10px}
.modal-close{background:rgba(255,255,255,0.2);border:none;color:white;width:32px;height:32px;border-radius:50%;cursor:pointer;font-size:18px;display:flex;align-items:center;justify-content:center}
.modal-close:hover{background:rgba(255,255,255,0.3)}
.modal-body{padding:20px;max-height:60vh;overflow-y:auto}
.modal-chips{display:flex;flex-wrap:wrap;gap:8px}
.modal-chip{background:var(--primary-light);color:var(--text);padding:6px 12px;border-radius:20px;font-size:13px;font-weight:500}
@media print{.sidebar,.btn,.quick-filters,.toolbar,.dropdown,.header,.stats-grid,.modal-overlay{display:none!important}.main{margin-left:0!important}body{background:white}}
</style></head>
<body>
<aside class="sidebar">
<div class="sidebar-header"><div class="logo"><span>üìö</span><span>ShelfLife</span></div></div>
<div class="sidebar-content">
<button class="btn" style="width:100%;margin-bottom:15px;justify-content:center;background:var(--primary);color:white;border:none" onclick="resetAll()">üîÑ Reset Filters</button>
<div class="filter-section"><div class="section-title">üåç Language</div>
${Object.entries(languages).map(([k, v]) => '<label class="filter-option"><input type="checkbox" checked onchange="filterTable()" data-col="lang" data-val="' + (langMap[k] || k) + '"> ' + (langMap[k] || k) + ' <span class="count">' + v + '</span></label>').join('')}
</div>
<div class="filter-section"><div class="section-title">üèõÔ∏è Building</div>
${Object.entries(buildings).map(([k, v]) => '<label class="filter-option"><input type="checkbox" checked onchange="filterTable()" data-col="building" data-val="' + k + '"> ' + k + ' <span class="count">' + v + '</span></label>').join('')}
</div>
<div class="filter-section"><div class="section-title">‚≠ê Condition</div>
${Object.entries(conditions).map(([k, v]) => '<label class="filter-option"><input type="checkbox" checked onchange="filterTable()" data-col="condition" data-val="' + k + '"> ' + k + ' <span class="count">' + v + '</span></label>').join('')}
</div>
<div class="filter-section"><div class="section-title">üë§ Owner</div>
${Object.entries(owners).map(([k, v]) => '<label class="filter-option"><input type="checkbox" checked onchange="filterTable()" data-col="owner" data-val="' + k + '"> ' + k + ' <span class="count">' + v + '</span></label>').join('')}
</div>
</div></aside>
<main class="main">
<div class="header">
<div><h1 class="page-title">${title}</h1><p class="header-subtitle">Generated: ${new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' })} ${new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })} ‚Ä¢ ${stats.total} books</p></div>
<div style="display:flex;gap:8px">
<button class="btn" onclick="exportCSV()">üì• Export CSV</button>
<button class="btn" onclick="window.print()">üñ®Ô∏è Print</button>
</div>
</div>
<div class="quick-filters">
<button class="quick-btn active" onclick="quickFilter('all',this)">üìö All (${stats.total})</button>
<button class="quick-btn" onclick="quickFilter('avail',this)">üìó Available (${stats.available})</button>
<button class="quick-btn" onclick="quickFilter('lent',this)">üìï Lent (${stats.lent})</button>
<button class="quick-btn" onclick="quickFilter('cover',this)">üì∑ Has Cover (${stats.withCover})</button>
<button class="quick-btn" onclick="quickFilter('nocover',this)">‚ùå No Cover (${stats.noCover})</button>
</div>
<div class="stats-grid">
<div class="stat-card" onclick="statCardClick('total')"><div class="stat-icon">üìñ</div><div class="stat-label">Total</div><div class="stat-value">${stats.total}</div></div>
<div class="stat-card" onclick="statCardClick('authors')"><div class="stat-icon">‚úçÔ∏è</div><div class="stat-label">Authors</div><div class="stat-value">${stats.authors}</div></div>
<div class="stat-card" onclick="statCardClick('buildings')"><div class="stat-icon">üèõÔ∏è</div><div class="stat-label">Buildings</div><div class="stat-value">${stats.buildings}</div></div>
<div class="stat-card" onclick="statCardClick('languages')"><div class="stat-icon">üåç</div><div class="stat-label">Languages</div><div class="stat-value">${stats.languages}</div></div>
<div class="stat-card" onclick="statCardClick('tags')"><div class="stat-icon">üè∑Ô∏è</div><div class="stat-label">Tags</div><div class="stat-value">${stats.tags}</div></div>
<div class="stat-card" onclick="statCardClick('owners')"><div class="stat-icon">üë§</div><div class="stat-label">Owners</div><div class="stat-value">${stats.owners}</div></div>
</div>
<div class="toolbar">
<button class="btn" onclick="resetAll()">üîÑ Reset</button>
<div class="search-box"><span class="search-icon">üîç</span><input type="text" id="search" placeholder="Search..." oninput="filterTable()"></div>
<div class="dropdown"><button class="btn">üëÅÔ∏è Columns ‚ñº</button>
<div class="dropdown-content">
<label><input type="checkbox" checked onchange="toggleCol('title')"> Title</label>
<label><input type="checkbox" checked onchange="toggleCol('author')"> Author</label>
<label><input type="checkbox" checked onchange="toggleCol('lang')"> Language</label>
<label><input type="checkbox" checked onchange="toggleCol('building')"> Building</label>
<label><input type="checkbox" onchange="toggleCol('shelf')"> Shelf</label>
<label><input type="checkbox" checked onchange="toggleCol('owner')"> Owner</label>
<label><input type="checkbox" onchange="toggleCol('year')"> Year</label>
<label><input type="checkbox" checked onchange="toggleCol('condition')"> Condition</label>
<label><input type="checkbox" checked onchange="toggleCol('status')"> Status</label>
<label><input type="checkbox" onchange="toggleCol('isbn')"> ISBN</label>
<label><input type="checkbox" checked onchange="toggleCol('tags')"> Tags</label>
</div></div>
</div>
<div class="results-info" id="info">Showing ${stats.total} books</div>
<div class="table-container">
<table><thead><tr>
<th class="col-title" onclick="sortTable(0)">Title ‚Üï</th>
<th class="col-author" onclick="sortTable(1)">Author ‚Üï</th>
<th class="col-lang" onclick="sortTable(2)">Lang</th>
<th class="col-building" onclick="sortTable(3)">Building</th>
<th class="col-shelf hidden" onclick="sortTable(4)">Shelf</th>
<th class="col-owner" onclick="sortTable(5)">Owner</th>
<th class="col-year hidden" onclick="sortTable(6)">Year</th>
<th class="col-condition" onclick="sortTable(7)">Condition</th>
<th class="col-status" onclick="sortTable(8)">Status</th>
<th class="col-isbn hidden" onclick="sortTable(9)">ISBN</th>
<th class="col-tags">Tags</th>
</tr></thead>
<tbody id="tbody">${tableRows}</tbody>
</table></div>
</main>
<div class="modal-overlay" id="modal" onclick="if(event.target===this)closeModal()">
<div class="modal-box">
<div class="modal-header"><div class="modal-title" id="modalTitle"></div><button class="modal-close" onclick="closeModal()">&times;</button></div>
<div class="modal-body" id="modalBody"></div>
</div>
</div>
<script>
var sortDir=1,lastCol=-1,activeQuick='all';
function sortTable(col){if(lastCol===col)sortDir*=-1;else{sortDir=1;lastCol=col;}
var tb=document.getElementById('tbody');var rows=Array.prototype.slice.call(tb.rows);
rows.sort(function(a,b){var x=a.cells[col].textContent.toLowerCase(),y=b.cells[col].textContent.toLowerCase();return x<y?-sortDir:x>y?sortDir:0;});
for(var i=0;i<rows.length;i++)tb.appendChild(rows[i]);}
function toggleCol(name){var els=document.querySelectorAll('.col-'+name);for(var i=0;i<els.length;i++)els[i].classList.toggle('hidden');}
function getChecked(col){var cbs=document.querySelectorAll('input[data-col="'+col+'"]:checked');var vals=[];for(var i=0;i<cbs.length;i++)vals.push(cbs[i].getAttribute('data-val').toLowerCase());return vals;}
function applyAllFilters(){
try {
var q=document.getElementById('search').value.toLowerCase();
var langs=getChecked('lang'),bldgs=getChecked('building'),conds=getChecked('condition'),owners=getChecked('owner');
var rows=document.querySelectorAll('#tbody tr');var shown=0;
for(var i=0;i<rows.length;i++){var r=rows[i];var show=true;
var txt=r.textContent.toLowerCase();
if(q&&txt.indexOf(q)===-1)show=false;
if(show&&langs.length>0){var lc=r.querySelector('.col-lang');var lv=lc?lc.textContent.toLowerCase():'';var lm=false;for(var j=0;j<langs.length;j++)if(lv.indexOf(langs[j])!==-1)lm=true;if(!lm)show=false;}
if(show&&bldgs.length>0){var bc=r.querySelector('.col-building');var bv=bc?bc.textContent.toLowerCase():'';var bm=false;for(var j=0;j<bldgs.length;j++)if(bv.indexOf(bldgs[j])!==-1)bm=true;if(!bm)show=false;}
if(show&&conds.length>0){var cc=r.querySelector('.col-condition');var cv=cc?cc.textContent.toLowerCase():'';var cm=false;for(var j=0;j<conds.length;j++)if(cv.indexOf(conds[j])!==-1)cm=true;if(!cm)show=false;}
if(show&&owners.length>0){var oc=r.querySelector('.col-owner');var ov=oc?oc.textContent.toLowerCase():'';var om=false;for(var j=0;j<owners.length;j++)if(ov.indexOf(owners[j])!==-1)om=true;if(!om)show=false;}
if(show&&activeQuick!=='all'){var sc=r.querySelector('.col-status');var sv=sc?sc.textContent.toLowerCase():'';
if(activeQuick==='avail'&&sv.indexOf('available')===-1)show=false;
if(activeQuick==='lent'&&sv.indexOf('lent')===-1)show=false;}
r.style.display=show?'':'none';if(show)shown++;}
document.getElementById('info').textContent='Showing '+shown+' books';
} catch(e) { console.error('Filter Error:', e); }
}
function filterTable(){applyAllFilters();}
function quickFilter(type,btn){var btns=document.querySelectorAll('.quick-btn');for(var i=0;i<btns.length;i++)btns[i].classList.remove('active');btn.classList.add('active');activeQuick=type;applyAllFilters();}
function resetAll(){
document.getElementById('search').value='';
var cbs=document.querySelectorAll('input[type="checkbox"]');for(var i=0;i<cbs.length;i++)cbs[i].checked=true;
var btns=document.querySelectorAll('.quick-btn');for(var i=0;i<btns.length;i++)btns[i].classList.remove('active');
document.querySelector('.quick-btn').classList.add('active');activeQuick='all';
applyAllFilters();
}
function drillDown(el){
resetAll();
var col=el.getAttribute('data-col');
var val=el.getAttribute('data-val');
var escVal=val.replace(/"/g,'\\"');
// Check sidebar first
var cb=document.querySelector('input[data-col="'+col+'"][data-val="'+escVal+'"]');
if(cb){
var all=document.querySelectorAll('input[data-col="'+col+'"]');for(var i=0;i<all.length;i++)all[i].checked=false;
cb.checked=true;
} else {
document.getElementById('search').value=val;
}
filterTable();
closeModal();
}
function showModal(icon,title,items,col){
document.getElementById('modalTitle').innerHTML=icon+' '+title;
var html='<div class="modal-chips">';
for(var i=0;i<items.length;i++){
// No JS escaping needed, just HTML entity encoding for the attribute value
var val=items[i].replace(/"/g,'&quot;');
html+='<span class="modal-chip" style="cursor:pointer" data-col="'+col+'" data-val="'+val+'" onclick="drillDown(this)">'+items[i]+'</span>';
}
html+='</div>';document.getElementById('modalBody').innerHTML=html;document.getElementById('modal').classList.add('show');
}
function closeModal(){document.getElementById('modal').classList.remove('show');}
function statCardClick(type){
var items=[];var icon='';var title='';var col='';
if(type==='total'){ resetAll(); return; }
if(type==='authors'){ col='author';icon='‚úçÔ∏è';var s=new Set();document.querySelectorAll('#tbody tr').forEach(function(r){var c=r.querySelector('.col-author');if(c&&c.textContent.trim())s.add(c.textContent.trim());});title='Authors ('+s.size+')';items=Array.from(s).sort(); }
if(type==='buildings'){ col='building';icon='üèõÔ∏è';var s=new Set();document.querySelectorAll('#tbody tr').forEach(function(r){var c=r.getAttribute('data-building');if(c)s.add(c);});title='Buildings ('+s.size+')';items=Array.from(s).sort(); }
if(type==='languages'){ col='lang';icon='üåç';var s=new Set();document.querySelectorAll('#tbody tr').forEach(function(r){var c=r.getAttribute('data-lang');if(c)s.add(c);});title='Languages ('+s.size+')';items=Array.from(s).sort(); }
if(type==='tags'){ col='tags';icon='üè∑Ô∏è';var s=new Set();document.querySelectorAll('#tbody tr').forEach(function(r){var c=r.getAttribute('data-tags');if(c)c.split('|').forEach(function(x){if(x)s.add(x);});});title='Tags ('+s.size+')';items=Array.from(s).sort(); }
if(type==='owners'){ col='owner';icon='üë§';var s=new Set();document.querySelectorAll('#tbody tr').forEach(function(r){var c=r.getAttribute('data-owner');if(c)s.add(c);});title='Owners ('+s.size+')';items=Array.from(s).sort(); }
showModal(icon,title,items,col);
}
var maxTagCols=${maxTags};
function exportCSV(){var rows=document.querySelectorAll('#tbody tr');var hdr=['Title','Author','Language','Building','Owner','Condition','Status'];for(var t=1;t<=maxTagCols;t++)hdr.push('Tag_'+t);var csv='\uFEFF'+hdr.join(',')+String.fromCharCode(10);for(var i=0;i<rows.length;i++){if(rows[i].style.display==='none')continue;var r=rows[i];var line=['"'+r.querySelector('.col-title').textContent.replace(/"/g,'""')+'"','"'+r.querySelector('.col-author').textContent.replace(/"/g,'""')+'"','"'+r.querySelector('.col-lang').textContent.replace(/"/g,'""')+'"','"'+r.querySelector('.col-building').textContent.replace(/"/g,'""')+'"','"'+r.querySelector('.col-owner').textContent.replace(/"/g,'""')+'"','"'+r.querySelector('.col-condition').textContent.replace(/"/g,'""')+'"','"'+r.querySelector('.col-status').textContent.replace(/"/g,'""')+'"'];var tags=(r.getAttribute('data-tags')||'').split('|');for(var t=0;t<maxTagCols;t++)line.push('"'+(tags[t]||'').replace(/"/g,'""')+'"');csv+=line.join(',')+String.fromCharCode(10);}var blob=new Blob([csv],{type:'text/csv;charset=utf-8'});var a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='library_export.csv';a.click();}
<\/script>
</body></html>`;

                ExportUtils.download(html, `ShelfLife_Dashboard_${ExportUtils.getTimestamp()}.html`, "text/html;charset=utf-8", folder, base);
            },
            // Export all book cover images to multiple independent ZIP files
            // Each ZIP is standalone and extractable independently
            // onProgress: (current, total, message) => void
            imagesZip: async (books, onProgress = () => { }) => {
                if (!window.JSZip) {
                    alert("JSZip library not loaded. Cannot export images.");
                    return { success: false, error: "JSZip not available" };
                }

                // Platform Check
                const isNative = isNativeCapacitor();
                let Filesystem = null;
                if (isNative) {
                    Filesystem = window.Capacitor.Plugins.Filesystem;
                }

                const MAX_IMAGES_PER_ZIP = 150;
                const MAX_SIZE_PER_ZIP = 100 * 1024 * 1024; // 100MB per ZIP

                // Collect all images with metadata
                const allImages = [];
                const filenameCounts = {};

                for (const book of books) {
                    const safeTitle = (book.title || 'Unknown').replace(/[^a-z0-9\s]/gi, '').replace(/\s+/g, '_').slice(0, 50);
                    if (book.front && book.front.startsWith('data:image')) {
                        allImages.push({ title: safeTitle, type: 'front', data: book.front, size: Math.round(book.front.length * 0.75) });
                    }
                    if (book.back && book.back.startsWith('data:image')) {
                        allImages.push({ title: safeTitle, type: 'back', data: book.back, size: Math.round(book.back.length * 0.75) });
                    }
                    if (book.spine && book.spine.startsWith('data:image')) {
                        allImages.push({ title: safeTitle, type: 'spine', data: book.spine, size: Math.round(book.spine.length * 0.75) });
                    }
                }

                if (allImages.length === 0) {
                    alert("No images found in your library.");
                    return { success: false, error: "No images" };
                }

                const totalSize = allImages.reduce((sum, img) => sum + img.size, 0);
                const estimatedParts = Math.max(1, Math.ceil(allImages.length / MAX_IMAGES_PER_ZIP), Math.ceil(totalSize / MAX_SIZE_PER_ZIP));

                if (estimatedParts > 1) {
                    const sizeMB = Math.round(totalSize / (1024 * 1024));
                    if (!confirm(`Total: ${allImages.length} images (~${sizeMB}MB)\nWill create ${estimatedParts} independent ZIP files.\n\nContinue?`)) {
                        return { success: false, error: "User cancelled" };
                    }
                }

                onProgress(0, allImages.length, `Starting export of ${allImages.length} images...`);

                const deviceName = localStorage.getItem('shelfLife_deviceName') || (isNative ? 'ANDROID' : 'BROWSER');
                const now = new Date();
                const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
                const baseFilename = `${deviceName}_Images_${dateStr}`;

                const folder = 'ShelfLife/Exports';
                const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                const targetDir = Directory[baseStr] || Directory.Documents;

                if (isNative) {
                    try { await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true }); } catch (e) { }
                }

                const savedFiles = [];
                let processedCount = 0;
                let partNumber = 1;
                let currentZip = new JSZip();
                let currentZipSize = 0;
                let currentZipImageCount = 0;

                try {
                    for (let i = 0; i < allImages.length; i++) {
                        const img = allImages[i];
                        const baseFn = `${img.title}_${img.type}`;
                        if (!filenameCounts[baseFn]) filenameCounts[baseFn] = 0;
                        filenameCounts[baseFn]++;
                        const filename = filenameCounts[baseFn] > 1 ? `${baseFn}_${filenameCounts[baseFn]}.jpg` : `${baseFn}.jpg`;

                        currentZip.file(filename, img.data.split(',')[1], { base64: true });
                        currentZipSize += img.size;
                        currentZipImageCount++;
                        processedCount++;
                        onProgress(processedCount, allImages.length, `Adding: ${filename}`);

                        const isLast = i === allImages.length - 1;
                        const shouldSave = isLast || currentZipImageCount >= MAX_IMAGES_PER_ZIP || currentZipSize >= MAX_SIZE_PER_ZIP;

                        if (shouldSave && currentZipImageCount > 0) {
                            const zipFilename = estimatedParts > 1 || savedFiles.length > 0 ? `${baseFilename}_Part${partNumber}.zip` : `${baseFilename}.zip`;
                            onProgress(processedCount, allImages.length, `Compressing Part ${partNumber}...`);

                            if (isNative) {
                                // Native Save
                                const zipBlob = await currentZip.generateAsync({ type: "base64", compression: "DEFLATE", compressionOptions: { level: 6 } }, (m) => {
                                    onProgress(processedCount, allImages.length, `Compressing Part ${partNumber}: ${Math.round(m.percent)}%`);
                                });
                                await Filesystem.writeFile({ path: `${folder}/${zipFilename}`, data: zipBlob, directory: targetDir });
                                savedFiles.push({ filename: zipFilename, imageCount: currentZipImageCount });
                            } else {
                                // Browser Download
                                const zipBlob = await currentZip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }, (m) => {
                                    onProgress(processedCount, allImages.length, `Compressing Part ${partNumber}: ${Math.round(m.percent)}%`);
                                });
                                const url = URL.createObjectURL(zipBlob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = zipFilename;
                                document.body.appendChild(a);
                                a.click();
                                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 1000);
                                savedFiles.push({ filename: zipFilename, imageCount: currentZipImageCount });
                            }

                            if (!isLast) {
                                currentZip = new JSZip();
                                currentZipSize = 0;
                                currentZipImageCount = 0;
                                partNumber++;
                            }
                            await new Promise(r => requestAnimationFrame(r));
                        }
                    }
                    return { success: true, count: savedFiles.length };
                } catch (e) {
                    console.error(e);
                    alert("Export failed: " + e.message);
                    return { success: false, error: e.message };
                }
            },
        };

        const ICONS = {
            Library: `<path d="m16 6 4 14"/><path d="M12 6v14"/><path d="M8 8v12"/><path d="M4 4v16"/>`,
            PlusSquare: `<rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/><path d="M12 8v8"/>`,
            BarChart2: `<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>`,
            Settings: `<path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/>`,
            Search: `<circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/>`,
            Edit3: `<path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/>`,
            Book: `<path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>`,
            Camera: `<path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/>`,
            FileText: `<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/>`,
            List: `<line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/>`,
            Image: `<rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>`,
            Download: `<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/>`,
            X: `<path d="M18 6 6 18"/><path d="m6 6 12 12"/>`,
            MapPin: `<path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/>`,
            AlertCircle: `<circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/>`,
            Trash2: `<path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/>`,
            Eye: `<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>`,
            Plus: `<path d="M5 12h14"/><path d="M12 5v14"/>`,
            Upload: `<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/>`,
            Filter: `<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>`,
            Barcode: `<path d="M3 5v14"/><path d="M8 5v14"/><path d="M12 5v14"/><path d="M17 5v14"/><path d="M21 5v14"/>`,
            CheckSquare: `<polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>`,
            Mic: `<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="23"/><line x1="8" x2="16" y1="23" y2="23"/>`,
            Grid: `<rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/>`,
            LayoutList: `<rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/><path d="M14 4h7"/><path d="M14 9h7"/><path d="M14 15h7"/><path d="M14 20h7"/>`,
            Merge: `<path d="m8 6 4-4 4 4"/><path d="M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22"/><path d="m20 22-5-5"/>`,
            Minus: `<path d="M5 12h14"/>`,
            ChevronUp: `<path d="m18 15-6-6-6 6"/>`,
            ChevronDown: `<path d="m6 9 6 6 6-6"/>`,
            Tag: `<path d="M12 2H2v10l9.29 9.29c.94.94 2.48.94 3.42 0l6.58-6.58c.94-.94.94-2.48 0-3.42L12 2Z"/><path d="M7 7h.01"/>`
        };

        const Icon = ({ name, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={`lucide lucide-${name} ${className}`} dangerouslySetInnerHTML={{ __html: ICONS[name] || ICONS['Book'] }} />
        );

        // --- TRANSLITERATION ---
        const TRANSLITERATE_MAP = {
            '‡¥Ö': 'a', '‡§Ü': 'aa', '‡¥á': 'i', '‡¥à': 'ee', '‡¥â': 'u', '‡¥ä': 'oo', '‡¥é': 'e', '‡¥è': 'ea', '‡¥ê': 'ai', '‡¥í': 'o', '‡¥ì': 'oa', '‡¥î': 'au', '‡¥Ç': 'm', '‡¥ï': 'ka', '‡¥ñ': 'kha', '‡¥ó': 'ga', '‡¥ò': 'gha', '‡¥ô': 'nga', '‡¥ö': 'cha', '‡¥õ': 'chha', '‡¥ú': 'ja', '‡¥ù': 'jha', '‡¥û': 'nja', '‡¥ü': 'ta', '‡¥†': 'ttha', '‡¥°': 'da', '‡¥¢': 'ddha', '‡¥£': 'na', '‡¥§': 'tha', '‡¥•': 'thha', '‡¥¶': 'da', '‡¥ß': 'dha', '‡¥®': 'na', '‡¥™': 'pa', '‡¥´': 'pha', '‡¥¨': 'ba', '‡¥≠': 'bha', '‡¥Æ': 'ma', '‡¥Ø': 'ya', '‡¥∞': 'ra', '‡¥≤': 'la', '‡¥µ': 'va', '‡¥∂': 'sha', '‡¥∑': 'sha', '‡¥∏': 'sa', '‡¥π': 'ha', '‡¥≥': 'la', '‡¥¥': 'zha', '‡¥±': 'ra', '‡§Ö': 'a', '‡§Ü': 'aa', '‡§á': 'i', '‡§à': 'ee', '‡§â': 'u', '‡§ä': 'oo', '‡§è': 'e', '‡§ê': 'ai', '‡§ì': 'o', '‡§î': 'au', '‡§Ç': 'n', '‡§ï': 'ka', '‡§ñ': 'kha', '‡§ó': 'ga', '‡§ò': 'gha', '‡§ö': 'cha', '‡§õ': 'chha', '‡§ú': 'ja', '‡§ù': 'jha', '‡§ü': 'ta', '‡§†': 'ttha', '‡§°': 'da', '‡§¢': 'ddha', '‡§£': 'na', '‡§§': 'tha', '‡§•': 'thha', '‡§¶': 'da', '‡§ß': 'dha', '‡§®': 'na', '‡§™': 'pa', '‡§´': 'pha', '‡§¨': 'ba', '‡§≠': 'bha', '‡§Æ': 'ma', '‡§Ø': 'ya', '‡§∞': 'ra', '‡§≤': 'la', '‡§µ': 'va', '‡§∂': 'sha', '‡§∑': 'sha', '‡§∏': 'sa', '‡§π': 'ha'
        };
        const transliterate = (text) => text.split('').map(char => TRANSLITERATE_MAP[char] || char).join('');

        // ==========================================
        // 2. DATABASE
        // ==========================================
        const db = new Dexie("ShelfLife_Final_v40");
        // V1 Schema: Original
        db.version(1).stores({ books: "++id, title, phonetic, author, owner, publisher, language, building, shelf, status, date_added, isbn, page_count, condition, currency" });

        // V2: Add tags multi-entry index for Tag Manager
        db.version(2).stores({
            books: "++id, title, phonetic, author, owner, publisher, language, building, shelf, status, date_added, isbn, page_count, condition, currency, *tags"
        });

        // V2 Schema (Implied): Split Author
        // We use the same database name to keep it simple, but we handle the data migration in code.
        // On app load, we check and migrate "author" -> "author_name" + "author_initials"

        const migrateAuthors = async () => {
            const books = await db.books.toArray();
            let migratedCount = 0;
            const updates = [];

            for (const book of books) {
                if (book.author && !book.author_name) {
                    const parts = book.author.trim().split(' ');
                    let name = parts.pop() || '';
                    let initials = parts.join(' ') || '';

                    // IF single word, treat as Name, no initials
                    if (!initials && !name) { name = book.author; }

                    updates.push({
                        key: book.id,
                        changes: {
                            author: undefined, // Remove old
                            author_name: name,
                            author_initials: initials
                        }
                    });
                    migratedCount++;
                }
            }

            if (migratedCount > 0) {
                await db.transaction('rw', db.books, async () => {
                    for (const u of updates) {
                        await db.books.update(u.key, u.changes);
                    }
                });
                console.log(`Migrated ${migratedCount} books to new Author format.`);
            }
        };

        // Language Code to Full Name Map
        const LANG_MAP = {
            'en': 'English',
            'ml': 'Malayalam',
            'hi': 'Hindi',
            'ar': 'Arabic'
        };

        // Migrate lang code to full language name
        const migrateLanguage = async () => {
            const books = await db.books.toArray();
            let migratedCount = 0;

            for (const book of books) {
                if (book.lang && !book.language) {
                    await db.books.update(book.id, {
                        language: LANG_MAP[book.lang] || book.lang
                    });
                    migratedCount++;
                }
            }

            if (migratedCount > 0) {
                console.log(`Migrated ${migratedCount} books to new Language format.`);
            }
        };

        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        // HELPER: Title Case
        const toTitleCase = (str) => {
            if (!str) return '';
            return str.toLowerCase().replace(/(?:^|\s|-)\S/g, function (a) { return a.toUpperCase(); });
        };

        // AUTO-SUGGEST INPUT with viewport-aware dropdown (avoids keyboard)
        const AutoSuggestInput = ({ label, value, onChange, field, placeholder }) => {
            const [suggestions, setSuggestions] = useState([]);
            const [showDropdown, setShowDropdown] = useState(false);
            const [maxHeight, setMaxHeight] = useState(150);
            const [filteredSuggestions, setFilteredSuggestions] = useState([]);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Fetch suggestions from database
            useEffect(() => {
                db.books.toArray().then(all => {
                    const set = new Set(all.map(b => b[field]).filter(Boolean));
                    setSuggestions([...set].sort());
                });
            }, [field]);

            // Calculate dropdown height based on viewport
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 150;
                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20;
                return Math.max(80, Math.min(viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap, 200));
            }, []);

            // Filter suggestions based on input
            useEffect(() => {
                if (!value || value.length < 1) {
                    setFilteredSuggestions([]);
                    setShowDropdown(false);
                    return;
                }
                const q = value.toLowerCase();
                const filtered = suggestions.filter(s => s.toLowerCase().includes(q)).slice(0, 15);
                setFilteredSuggestions(filtered);
                setShowDropdown(filtered.length > 0);
            }, [value, suggestions]);

            // Recalculate height on viewport changes
            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());
                updateHeight();
                window.addEventListener('resize', updateHeight);
                window.visualViewport?.addEventListener('resize', updateHeight);
                return () => {
                    window.removeEventListener('resize', updateHeight);
                    window.visualViewport?.removeEventListener('resize', updateHeight);
                };
            }, [calculateMaxHeight]);

            // Close dropdown on outside click
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target) &&
                        inputRef.current && !inputRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            const selectSuggestion = (s) => {
                onChange({ target: { value: s } });
                setShowDropdown(false);
            };

            return (
                <div className="relative">
                    <label className="text-xs text-gray-500 font-bold">{label}</label>
                    <input
                        ref={inputRef}
                        className="w-full p-3 border rounded-lg"
                        value={value}
                        onChange={onChange}
                        placeholder={placeholder}
                        onFocus={() => filteredSuggestions.length > 0 && setShowDropdown(true)}
                    />
                    {showDropdown && filteredSuggestions.length > 0 && (
                        <div
                            ref={dropdownRef}
                            className="absolute left-0 right-0 top-full mt-1 bg-white border rounded-lg shadow-lg z-50 overflow-y-auto"
                            style={{ maxHeight: `${maxHeight}px` }}
                        >
                            {filteredSuggestions.map((s, i) => (
                                <div
                                    key={i}
                                    className="px-3 py-2 hover:bg-blue-50 cursor-pointer text-sm border-b last:border-b-0"
                                    onClick={() => selectSuggestion(s)}
                                >
                                    {s}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        // DYNAMIC SEARCH INPUT with viewport-aware dropdown (avoids keyboard)
        const DynamicSearchInput = ({ value, onChange, suggestions, placeholder, icon }) => {
            const [showDropdown, setShowDropdown] = useState(false);
            const [maxHeight, setMaxHeight] = useState(150);
            const [filteredSuggestions, setFilteredSuggestions] = useState([]);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Calculate max dropdown height based on available viewport space
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 150;

                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;

                // Estimate keyboard takes ~40% of screen on mobile
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20; // Gap above keyboard

                // Available space = from bottom of input to keyboard
                const available = viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap;

                // Clamp between 80px (min) and 250px (max)
                return Math.max(80, Math.min(available, 250));
            }, []);

            // Filter suggestions based on input
            useEffect(() => {
                if (!value || value.length < 1) {
                    setFilteredSuggestions([]);
                    setShowDropdown(false);
                    return;
                }

                const q = value.toLowerCase();
                const filtered = suggestions.filter(s =>
                    s.toLowerCase().includes(q)
                ).slice(0, 20); // Max 20 suggestions

                setFilteredSuggestions(filtered);
                setShowDropdown(filtered.length > 0);
            }, [value, suggestions]);

            // Recalculate height on viewport changes
            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());

                updateHeight();
                window.addEventListener('resize', updateHeight);
                window.visualViewport?.addEventListener('resize', updateHeight);

                return () => {
                    window.removeEventListener('resize', updateHeight);
                    window.visualViewport?.removeEventListener('resize', updateHeight);
                };
            }, [calculateMaxHeight]);

            // Close dropdown when clicking outside
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target) &&
                        inputRef.current && !inputRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            const selectSuggestion = (s) => {
                onChange({ target: { value: s } });
                setShowDropdown(false);
            };

            return (
                <div className="relative flex-1">
                    {icon && <Icon name={icon} className="absolute left-2 top-2 text-gray-400" size={14} />}
                    <input
                        ref={inputRef}
                        className={`w-full p-2 border rounded ${icon ? 'pl-8' : ''}`}
                        placeholder={placeholder}
                        value={value}
                        onChange={onChange}
                        onFocus={() => filteredSuggestions.length > 0 && setShowDropdown(true)}
                    />
                    {showDropdown && filteredSuggestions.length > 0 && (
                        <div
                            ref={dropdownRef}
                            className="absolute left-0 right-0 top-full mt-1 bg-white border rounded-lg shadow-lg z-50 overflow-y-auto"
                            style={{ maxHeight: `${maxHeight}px` }}
                        >
                            {filteredSuggestions.map((s, i) => (
                                <div
                                    key={i}
                                    className="px-3 py-2 hover:bg-blue-50 cursor-pointer text-sm border-b last:border-b-0"
                                    onClick={() => selectSuggestion(s)}
                                >
                                    {s}
                                </div>
                            ))}
                            {filteredSuggestions.length === 20 && (
                                <div className="px-3 py-1 text-xs text-gray-400 text-center bg-gray-50">
                                    Showing first 20 results
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // VOICE INPUT (Wrapped)
        const VoiceInput = ({ label, value, onChange, onVoice, isListening, lang, type = "text", placeholder }) => {
            return (
                <div className="relative">
                    <label className="text-xs text-gray-500 font-bold">{label}</label>
                    <div className="relative">
                        <input
                            type={type}
                            className="w-full p-3 border rounded-lg pr-10"
                            placeholder={placeholder}
                            value={value}
                            onChange={onChange}
                            lang={lang}
                        />
                        <button
                            type="button"
                            onClick={onVoice}
                            className={`absolute right-2 top-2 p-1 rounded-full ${isListening ? 'bg-red-500 text-white animate-pulse' : 'text-gray-400'}`}
                        >
                            <Icon name="Mic" size={20} />
                        </button>
                    </div>
                </div>
            );
        };

        // TAG TOKEN INPUT (Pills/Chips with Autocomplete)
        const TagTokenInput = ({ label, value = [], onChange, allBooks = [], placeholder = "Add tags..." }) => {
            const [input, setInput] = useState('');
            const [showDropdown, setShowDropdown] = useState(false);
            const [suggestions, setSuggestions] = useState([]);
            const [selectedIndex, setSelectedIndex] = useState(-1);
            const [maxHeight, setMaxHeight] = useState(150);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Calculate dropdown height based on viewport
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 150;
                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20;
                return Math.max(80, Math.min(viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap, 200));
            }, []);

            // Recalculate height on viewport changes
            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());
                updateHeight();
                window.visualViewport?.addEventListener('resize', updateHeight);
                return () => window.visualViewport?.removeEventListener('resize', updateHeight);
            }, [calculateMaxHeight]);

            // Extract all unique tags from library
            const allTags = useMemo(() => {
                const tagSet = new Set();
                allBooks.forEach(book => {
                    if (book.tags && Array.isArray(book.tags)) {
                        book.tags.forEach(tag => {
                            if (tag && tag.trim()) tagSet.add(tag.trim());
                        });
                    }
                });
                return Array.from(tagSet).sort();
            }, [allBooks]);

            // Filter suggestions based on input
            useEffect(() => {
                if (!input.trim()) {
                    setSuggestions([]);
                    setShowDropdown(false);
                    return;
                }

                const filtered = allTags.filter(tag =>
                    tag.toLowerCase().includes(input.toLowerCase()) &&
                    !value.includes(tag)
                );
                setSuggestions(filtered.slice(0, 8)); // Limit to 8 suggestions
                setShowDropdown(true); // Always show dropdown if input exists
                setSelectedIndex(-1);
            }, [input, allTags, value]);

            // Add tag (with Title Case formatting)
            const addTag = (tag) => {
                const formatted = toTitleCase(tag);
                if (!formatted || value.some(v => v.toLowerCase() === formatted.toLowerCase())) return;

                const newTags = [...value, formatted];
                onChange(newTags);
                setInput('');
                setShowDropdown(false);
                setSelectedIndex(-1);
                inputRef.current?.focus();
            };

            // Remove tag
            const removeTag = (indexToRemove) => {
                const newTags = value.filter((_, index) => index !== indexToRemove);
                onChange(newTags);
                inputRef.current?.focus();
            };

            // Keyboard navigation
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        addTag(suggestions[selectedIndex]);
                    } else if (input.trim()) {
                        addTag(input);
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setSelectedIndex(prev =>
                        prev < suggestions.length - 1 ? prev + 1 : prev
                    );
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setSelectedIndex(prev => prev > 0 ? prev - 1 : -1);
                } else if (e.key === 'Backspace' && !input && value.length > 0) {
                    removeTag(value.length - 1);
                } else if (e.key === 'Escape') {
                    setShowDropdown(false);
                    setSelectedIndex(-1);
                }
            };

            // Click outside to close dropdown
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            return (
                <div className="relative" ref={dropdownRef}>
                    <label className="text-xs text-gray-500 font-bold">{label}</label>
                    <div className="w-full p-2 border rounded-lg min-h-[44px] flex flex-wrap gap-2 items-center cursor-text"
                        onClick={() => inputRef.current?.focus()}>
                        {/* Tag Pills */}
                        {value.map((tag, index) => (
                            <div key={index}
                                className="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-medium">
                                <span>{tag}</span>
                                <button type="button"
                                    onClick={(e) => { e.stopPropagation(); removeTag(index); }}
                                    className="hover:bg-blue-200 rounded-full p-0.5 transition">
                                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>
                        ))}

                        {/* Input Field */}
                        <input
                            ref={inputRef}
                            type="text"
                            className="flex-1 min-w-[120px] outline-none bg-transparent"
                            placeholder={value.length === 0 ? placeholder : ""}
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                            onFocus={() => input && setShowDropdown(suggestions.length > 0)}
                        />
                    </div>

                    {/* Autocomplete Dropdown */}
                    {showDropdown && (
                        <div className="absolute z-50 w-full mt-1 bg-white border rounded-lg shadow-lg overflow-y-auto"
                            style={{ maxHeight: `${maxHeight}px` }}>
                            {suggestions.map((suggestion, index) => (
                                <div key={index}
                                    className={`px-3 py-2 cursor-pointer transition ${index === selectedIndex ? 'bg-blue-100' : 'hover:bg-gray-100'}`}
                                    onClick={() => addTag(suggestion)}>
                                    {suggestion}
                                </div>
                            ))}
                            {/* Option to create new tag */}
                            {input && !allTags.includes(input.trim()) && (
                                <div className={`px-3 py-2 cursor-pointer border-t text-blue-600 font-medium transition ${selectedIndex === suggestions.length ? 'bg-blue-50' : 'hover:bg-gray-50'}`}
                                    onClick={() => addTag(input)}>
                                    + Create "{input.trim()}"
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // TAG MANAGER - Colorful chip tokens with full CRUD operations
        const TAG_COLORS = [
            { bg: 'bg-blue-100', text: 'text-blue-800', border: 'border-blue-300' },
            { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300' },
            { bg: 'bg-yellow-100', text: 'text-yellow-800', border: 'border-yellow-300' },
            { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-300' },
            { bg: 'bg-purple-100', text: 'text-purple-800', border: 'border-purple-300' },
            { bg: 'bg-pink-100', text: 'text-pink-800', border: 'border-pink-300' },
            { bg: 'bg-indigo-100', text: 'text-indigo-800', border: 'border-indigo-300' },
            { bg: 'bg-orange-100', text: 'text-orange-800', border: 'border-orange-300' },
        ];

        const getTagColor = (tag) => {
            const hash = tag.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            return TAG_COLORS[hash % TAG_COLORS.length];
        };



        const TagManagerModal = ({ isOpen, onClose, books, onTagsUpdated }) => {
            const [allTags, setAllTags] = useState([]);
            const [selectedTags, setSelectedTags] = useState([]);
            const [searchQuery, setSearchQuery] = useState('');
            const [showDropdown, setShowDropdown] = useState(false);
            const [maxHeight, setMaxHeight] = useState(200);
            const [renameTag, setRenameTag] = useState(null);
            const [renameValue, setRenameValue] = useState('');
            const [deleteTag, setDeleteTag] = useState(null);
            const [deleteAction, setDeleteAction] = useState('remove');
            const [replaceTarget, setReplaceTarget] = useState('');
            const [showMergeModal, setShowMergeModal] = useState(false);
            const [mergeTarget, setMergeTarget] = useState('');
            const [mergeNewName, setMergeNewName] = useState('');
            const [mergeMode, setMergeMode] = useState('existing');
            const [isProcessing, setIsProcessing] = useState(false);
            const [showBrowseAll, setShowBrowseAll] = useState(false);
            const inputRef = useRef(null);

            // Calculate all tags with counts
            const refreshTags = useCallback(async () => {
                const allBooks = await db.books.toArray();
                const tagMap = new Map();
                allBooks.forEach(book => {
                    (book.tags || []).forEach(tag => {
                        if (!tagMap.has(tag)) tagMap.set(tag, { count: 0, bookIds: [] });
                        tagMap.get(tag).count++;
                        tagMap.get(tag).bookIds.push(book.id);
                    });
                });
                const tags = Array.from(tagMap.entries())
                    .map(([tag, data]) => ({ tag, ...data }))
                    .sort((a, b) => b.count - a.count);
                setAllTags(tags);
            }, []);

            useEffect(() => {
                if (isOpen) {
                    refreshTags();
                    setSearchQuery('');
                    setSelectedTags([]);
                }
            }, [isOpen, refreshTags]);

            // Keyboard-aware height calculation
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 200;
                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20;
                return Math.max(100, Math.min(viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap, 250));
            }, []);

            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());
                updateHeight();
                window.visualViewport?.addEventListener('resize', updateHeight);
                return () => window.visualViewport?.removeEventListener('resize', updateHeight);
            }, [calculateMaxHeight]);

            // Filter tags by search (search-first: show nothing if empty)
            const filteredTags = useMemo(() => {
                if (!searchQuery.trim()) return [];
                const q = searchQuery.toLowerCase();
                return allTags.filter(t => t.tag.toLowerCase().includes(q)).slice(0, 15);
            }, [allTags, searchQuery]);

            // Check if search query is a new tag (doesn't exist)
            const isNewTag = useMemo(() => {
                if (!searchQuery.trim()) return false;
                const q = searchQuery.trim().toLowerCase();
                return !allTags.some(t => t.tag.toLowerCase() === q);
            }, [allTags, searchQuery]);

            // Toggle tag selection (add as chip)
            const selectTag = (tag) => {
                if (!selectedTags.includes(tag)) {
                    setSelectedTags([...selectedTags, tag]);
                }
                setSearchQuery('');
                setShowDropdown(false);
            };

            // Remove chip
            const removeTag = (tag) => {
                setSelectedTags(selectedTags.filter(t => t !== tag));
            };

            // Create new tag and add to selection (with Title Case)
            const handleCreateTag = () => {
                const newTag = toTitleCase(searchQuery);
                if (newTag && !selectedTags.some(t => t.toLowerCase() === newTag.toLowerCase())) {
                    setSelectedTags([...selectedTags, newTag]);
                }
                setSearchQuery('');
                setShowDropdown(false);
            };

            // Rename tag
            const handleRename = async () => {
                if (!renameTag || !renameValue.trim()) return;
                setIsProcessing(true);
                try {
                    const booksWithTag = await db.books.where('tags').equals(renameTag).toArray();
                    for (const book of booksWithTag) {
                        book.tags = book.tags.map(t => t === renameTag ? renameValue.trim() : t);
                        await db.books.put(book);
                    }
                    alert(`Renamed "${renameTag}" ‚Üí "${renameValue.trim()}" in ${booksWithTag.length} books`);
                    onClose();
                    if (onTagsUpdated) onTagsUpdated();
                } finally {
                    setIsProcessing(false);
                }
            };

            // Delete tag with options
            const handleDelete = async () => {
                if (!deleteTag) return;
                setIsProcessing(true);
                try {
                    const booksWithTag = await db.books.where('tags').equals(deleteTag).toArray();
                    for (const book of booksWithTag) {
                        if (deleteAction === 'remove') {
                            book.tags = book.tags.filter(t => t !== deleteTag);
                        } else if (deleteAction === 'replaceExisting' && replaceTarget) {
                            book.tags = book.tags.map(t => t === deleteTag ? replaceTarget : t);
                            book.tags = [...new Set(book.tags)];
                        } else if (deleteAction === 'replaceNew' && replaceTarget.trim()) {
                            book.tags = book.tags.map(t => t === deleteTag ? replaceTarget.trim() : t);
                        }
                        await db.books.put(book);
                    }
                    const actionText = deleteAction === 'remove' ? 'removed from' : 'replaced in';
                    alert(`"${deleteTag}" ${actionText} ${booksWithTag.length} books`);
                    onClose();
                    if (onTagsUpdated) onTagsUpdated();
                } finally {
                    setIsProcessing(false);
                }
            };

            // Merge multiple tags
            const handleMerge = async () => {
                if (selectedTags.length < 2) return;
                const targetName = mergeMode === 'existing' ? mergeTarget : mergeNewName.trim();
                if (!targetName) return;

                setIsProcessing(true);
                try {
                    let totalBooks = 0;
                    for (const sourceTag of selectedTags) {
                        if (sourceTag === targetName) continue;
                        const booksWithTag = await db.books.where('tags').equals(sourceTag).toArray();
                        for (const book of booksWithTag) {
                            book.tags = book.tags.map(t => t === sourceTag ? targetName : t);
                            book.tags = [...new Set(book.tags)];
                            await db.books.put(book);
                        }
                        totalBooks += booksWithTag.length;
                    }
                    alert(`Merged ${selectedTags.length} tags into "${targetName}" (${totalBooks} books updated)`);
                    onClose();
                    if (onTagsUpdated) onTagsUpdated();
                } finally {
                    setIsProcessing(false);
                }
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 modal-overlay" onClick={onClose}>
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg max-h-[85vh] flex flex-col" onClick={e => e.stopPropagation()}>
                        {/* Header */}
                        <div className="p-4 border-b flex justify-between items-center bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-t-xl">
                            <h2 className="font-bold text-lg flex items-center gap-2"><Icon name="Tag" size={20} /> Tag Manager</h2>
                            <button onClick={onClose} className="p-1 hover:bg-white/20 rounded"><Icon name="X" size={20} /></button>
                        </div>

                        {/* Search Input with Dropdown */}
                        <div className="p-3 border-b bg-gray-50 relative">
                            <input
                                ref={inputRef}
                                className="w-full p-3 border rounded-lg text-sm"
                                placeholder="Search tags or type new..."
                                value={searchQuery}
                                onChange={e => { setSearchQuery(e.target.value); setShowDropdown(true); }}
                                onFocus={() => setShowDropdown(true)}
                            />
                            {/* Dropdown */}
                            {showDropdown && searchQuery.trim() && (
                                <div
                                    className="absolute left-3 right-3 bg-white border rounded-lg shadow-lg z-10 overflow-y-auto"
                                    style={{ maxHeight: maxHeight, top: '100%' }}
                                >
                                    {filteredTags.map(({ tag, count }) => {
                                        const color = getTagColor(tag);
                                        const isSelected = selectedTags.includes(tag);
                                        return (
                                            <div
                                                key={tag}
                                                onClick={() => !isSelected && selectTag(tag)}
                                                className={`px-3 py-2 flex justify-between items-center cursor-pointer hover:bg-gray-100 
                                                    ${isSelected ? 'opacity-50 cursor-not-allowed' : ''}`}
                                            >
                                                <span className={`px-2 py-0.5 rounded-full text-sm ${color.bg} ${color.text}`}>
                                                    {tag}
                                                </span>
                                                <span className="text-xs text-gray-400">{count} books</span>
                                            </div>
                                        );
                                    })}
                                    {filteredTags.length === 0 && !isNewTag && (
                                        <div className="px-3 py-2 text-gray-400 text-sm italic">No matching tags</div>
                                    )}
                                    {isNewTag && (
                                        <div
                                            onClick={handleCreateTag}
                                            className="px-3 py-2 flex items-center gap-2 cursor-pointer hover:bg-green-50 text-green-700 border-t"
                                        >
                                            <Icon name="Plus" size={16} />
                                            <span>Create "<strong>{searchQuery.trim()}</strong>"</span>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Selected Tags (Chips) */}
                        <div className="p-3 border-b flex flex-wrap gap-2 min-h-[60px]">
                            {selectedTags.length === 0 ? (
                                <p className="text-gray-400 text-sm italic">Type to search and select tags...</p>
                            ) : (
                                selectedTags.map(tag => {
                                    const color = getTagColor(tag);
                                    const tagData = allTags.find(t => t.tag === tag);
                                    const isNew = !tagData;
                                    return (
                                        <span
                                            key={tag}
                                            className={`px-3 py-1.5 rounded-full text-sm font-medium flex items-center gap-2 border-2
                                                ${isNew ? 'bg-green-100 text-green-800 border-green-300' : `${color.bg} ${color.text} ${color.border}`}`}
                                        >
                                            {tag} {tagData && <span className="opacity-60">({tagData.count})</span>}
                                            {isNew && <span className="text-[10px] bg-green-500 text-white px-1 rounded">NEW</span>}
                                            <button onClick={() => removeTag(tag)} className="hover:text-red-600 ml-1">√ó</button>
                                        </span>
                                    );
                                })
                            )}
                        </div>

                        {/* Action Buttons */}
                        <div className="p-3 bg-gray-100 flex flex-wrap gap-2">
                            {selectedTags.length === 1 && allTags.find(t => t.tag === selectedTags[0]) && (
                                <>
                                    <button
                                        onClick={() => { setRenameTag(selectedTags[0]); setRenameValue(selectedTags[0]); }}
                                        className="flex-1 py-2 bg-blue-100 text-blue-800 rounded-lg text-sm font-bold flex items-center justify-center gap-1"
                                    >
                                        <Icon name="Edit3" size={14} /> Rename
                                    </button>
                                    <button
                                        onClick={() => setDeleteTag(selectedTags[0])}
                                        className="flex-1 py-2 bg-red-100 text-red-800 rounded-lg text-sm font-bold flex items-center justify-center gap-1"
                                    >
                                        <Icon name="Trash2" size={14} /> Delete
                                    </button>
                                </>
                            )}
                            {selectedTags.length >= 2 && (
                                <button
                                    onClick={() => setShowMergeModal(true)}
                                    className="flex-1 py-2 bg-purple-100 text-purple-800 rounded-lg text-sm font-bold flex items-center justify-center gap-1"
                                >
                                    <Icon name="Merge" size={14} /> Merge {selectedTags.length} Tags
                                </button>
                            )}
                            {selectedTags.length > 0 && (
                                <button
                                    onClick={() => setSelectedTags([])}
                                    className="py-2 px-4 bg-gray-200 rounded-lg text-sm"
                                >
                                    Clear
                                </button>
                            )}
                            {selectedTags.length === 0 && (
                                <p className="text-xs text-gray-400 italic w-full text-center">Select tags to see actions</p>
                            )}
                        </div>

                        {/* Quick Stats + Browse All */}
                        <div className="p-2 bg-gray-50 border-t flex justify-between items-center">
                            <p className="text-xs text-gray-400">{allTags.length} tags in library</p>
                            <button
                                onClick={() => setShowBrowseAll(true)}
                                className="text-xs bg-blue-100 text-blue-700 px-3 py-1 rounded-full font-bold hover:bg-blue-200"
                            >
                                Browse All
                            </button>
                        </div>

                        {/* Browse All Tags Modal */}
                        {showBrowseAll && (
                            <div className="absolute inset-0 bg-black/30 flex items-center justify-center p-4 z-20">
                                <div className="bg-white rounded-xl w-full max-w-md max-h-[70vh] flex flex-col shadow-xl">
                                    <div className="p-3 border-b flex justify-between items-center bg-blue-500 text-white rounded-t-xl">
                                        <h3 className="font-bold">üìã All Tags ({allTags.length})</h3>
                                        <button onClick={() => setShowBrowseAll(false)} className="hover:bg-white/20 p-1 rounded"><Icon name="X" size={18} /></button>
                                    </div>
                                    <div className="flex-1 overflow-y-auto p-3">
                                        <div className="flex flex-wrap gap-2">
                                            {allTags.map(({ tag, count }) => {
                                                const color = getTagColor(tag);
                                                const isSelected = selectedTags.includes(tag);
                                                return (
                                                    <button
                                                        key={tag}
                                                        onClick={() => { selectTag(tag); setShowBrowseAll(false); }}
                                                        className={`px-3 py-1.5 rounded-full text-sm font-medium border-2 transition-all
                                                            ${color.bg} ${color.text} ${color.border}
                                                            ${isSelected ? 'ring-2 ring-offset-1 ring-blue-500' : ''}
                                                            hover:shadow-md active:scale-95`}
                                                    >
                                                        {tag} <span className="opacity-60">({count})</span>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                    <div className="p-2 border-t text-center">
                                        <button onClick={() => setShowBrowseAll(false)} className="text-sm text-gray-500">Close</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Rename Modal */}
                        {renameTag && (
                            <div className="absolute inset-0 bg-black/30 flex items-center justify-center p-4 z-20">
                                <div className="bg-white rounded-xl p-4 w-full max-w-sm shadow-xl">
                                    <h3 className="font-bold text-lg mb-3">Rename "{renameTag}"</h3>
                                    <input
                                        className="w-full p-3 border rounded-lg mb-3"
                                        value={renameValue}
                                        onChange={e => setRenameValue(e.target.value)}
                                        autoFocus
                                    />
                                    <div className="flex gap-2">
                                        <button onClick={handleRename} disabled={isProcessing} className="flex-1 py-2 bg-blue-600 text-white rounded-lg font-bold">{isProcessing ? 'Renaming...' : 'Rename'}</button>
                                        <button onClick={() => setRenameTag(null)} className="flex-1 py-2 bg-gray-200 rounded-lg">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Delete Modal */}
                        {deleteTag && (
                            <div className="absolute inset-0 bg-black/30 flex items-center justify-center p-4 z-20">
                                <div className="bg-white rounded-xl p-4 w-full max-w-sm shadow-xl">
                                    <h3 className="font-bold text-lg mb-2">Delete "{deleteTag}"?</h3>
                                    <p className="text-sm text-gray-500 mb-3">This tag is used by {allTags.find(t => t.tag === deleteTag)?.count || 0} books.</p>
                                    <div className="space-y-2 mb-4">
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={deleteAction === 'remove'} onChange={() => setDeleteAction('remove')} />
                                            Remove tag from all books
                                        </label>
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={deleteAction === 'replaceExisting'} onChange={() => setDeleteAction('replaceExisting')} />
                                            Replace with existing tag:
                                        </label>
                                        {deleteAction === 'replaceExisting' && (
                                            <select className="w-full p-2 border rounded ml-6" value={replaceTarget} onChange={e => setReplaceTarget(e.target.value)}>
                                                <option value="">Select tag...</option>
                                                {allTags.filter(t => t.tag !== deleteTag).map(t => (
                                                    <option key={t.tag} value={t.tag}>{t.tag} ({t.count})</option>
                                                ))}
                                            </select>
                                        )}
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={deleteAction === 'replaceNew'} onChange={() => setDeleteAction('replaceNew')} />
                                            Replace with new tag:
                                        </label>
                                        {deleteAction === 'replaceNew' && (
                                            <input className="w-full p-2 border rounded ml-6" placeholder="New tag name..." value={replaceTarget} onChange={e => setReplaceTarget(e.target.value)} />
                                        )}
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={handleDelete} disabled={isProcessing} className="flex-1 py-2 bg-red-600 text-white rounded-lg font-bold">{isProcessing ? 'Deleting...' : 'Delete'}</button>
                                        <button onClick={() => setDeleteTag(null)} className="flex-1 py-2 bg-gray-200 rounded-lg">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Merge Modal */}
                        {showMergeModal && (
                            <div className="absolute inset-0 bg-black/30 flex items-center justify-center p-4 z-20">
                                <div className="bg-white rounded-xl p-4 w-full max-w-sm shadow-xl">
                                    <h3 className="font-bold text-lg mb-2">Merge {selectedTags.length} Tags</h3>
                                    <p className="text-sm text-gray-500 mb-3">Tags: {selectedTags.join(', ')}</p>
                                    <div className="space-y-2 mb-4">
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={mergeMode === 'existing'} onChange={() => setMergeMode('existing')} />
                                            Merge into one of these:
                                        </label>
                                        {mergeMode === 'existing' && (
                                            <select className="w-full p-2 border rounded ml-6" value={mergeTarget} onChange={e => setMergeTarget(e.target.value)}>
                                                <option value="">Select tag...</option>
                                                {selectedTags.filter(t => allTags.find(at => at.tag === t)).map(t => (
                                                    <option key={t} value={t}>{t}</option>
                                                ))}
                                            </select>
                                        )}
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={mergeMode === 'new'} onChange={() => setMergeMode('new')} />
                                            Merge into new tag:
                                        </label>
                                        {mergeMode === 'new' && (
                                            <input className="w-full p-2 border rounded ml-6" placeholder="New tag name..." value={mergeNewName} onChange={e => setMergeNewName(e.target.value)} />
                                        )}
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={handleMerge} disabled={isProcessing} className="flex-1 py-2 bg-purple-600 text-white rounded-lg font-bold">{isProcessing ? 'Merging...' : 'Merge'}</button>
                                        <button onClick={() => setShowMergeModal(false)} className="flex-1 py-2 bg-gray-200 rounded-lg">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // AUTOCOMPLETE INPUT (For Author, Building, Owner, Condition)
        // Supports two modes:
        // 1. allBooks + field: extracts suggestions from book data
        // 2. suggestions: direct array of suggestions (for SlicerSearch)
        const AutocompleteInput = ({ label, value = '', onChange, allBooks = [], field, placeholder = '', suggestions: directSuggestions }) => {
            const [showDropdown, setShowDropdown] = useState(false);
            const [filteredSuggestions, setFilteredSuggestions] = useState([]);
            const [selectedIndex, setSelectedIndex] = useState(-1);
            const [maxHeight, setMaxHeight] = useState(150);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Handle onChange - always pass event-style object for form field compatibility
            const handleChange = (val) => {
                if (typeof onChange === 'function') {
                    onChange({ target: { value: val } });
                }
            };

            // Calculate dropdown height based on viewport
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 150;
                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20;
                return Math.max(80, Math.min(viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap, 200));
            }, []);

            // Recalculate height on viewport changes
            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());
                updateHeight();
                window.visualViewport?.addEventListener('resize', updateHeight);
                return () => window.visualViewport?.removeEventListener('resize', updateHeight);
            }, [calculateMaxHeight]);

            // Extract unique values for this field from all books (if not using directSuggestions)
            const allValues = useMemo(() => {
                if (directSuggestions && directSuggestions.length > 0) {
                    return directSuggestions;
                }
                const valueSet = new Set();
                allBooks.forEach(book => {
                    const fieldValue = book[field];
                    if (fieldValue && typeof fieldValue === 'string' && fieldValue.trim()) {
                        valueSet.add(fieldValue.trim());
                    }
                });
                return Array.from(valueSet).sort();
            }, [allBooks, field, directSuggestions]);

            // Filter suggestions based on input
            useEffect(() => {
                if (!value || value.length < 1) {
                    setFilteredSuggestions([]);
                    setShowDropdown(false);
                    return;
                }

                const filtered = allValues.filter(val =>
                    String(val).toLowerCase().includes(String(value).toLowerCase()) &&
                    String(val).toLowerCase() !== String(value).toLowerCase()
                );
                setFilteredSuggestions(filtered.slice(0, 8));
                setShowDropdown(filtered.length > 0);
                setSelectedIndex(-1);
            }, [value, allValues]);

            // Select suggestion
            const selectSuggestion = (suggestion) => {
                handleChange(suggestion);
                setShowDropdown(false);
                setSelectedIndex(-1);
            };

            // Keyboard navigation
            const handleKeyDown = (e) => {
                if (!showDropdown) return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setSelectedIndex(prev =>
                        prev < filteredSuggestions.length - 1 ? prev + 1 : prev
                    );
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setSelectedIndex(prev => prev > 0 ? prev - 1 : -1);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    selectSuggestion(filteredSuggestions[selectedIndex]);
                } else if (e.key === 'Escape') {
                    setShowDropdown(false);
                    setSelectedIndex(-1);
                }
            };

            // Click outside to close
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            return (
                <div className="relative flex-1" ref={dropdownRef}>
                    {label && <label className="text-xs text-gray-500 font-bold">{label}</label>}
                    <input
                        ref={inputRef}
                        type="text"
                        className="w-full p-3 border rounded-lg"
                        placeholder={placeholder}
                        value={value}
                        onChange={(e) => handleChange(e.target.value)}
                        onKeyDown={handleKeyDown}
                        onFocus={() => value && setShowDropdown(filteredSuggestions.length > 0)}
                    />

                    {/* Autocomplete Dropdown */}
                    {showDropdown && filteredSuggestions.length > 0 && (
                        <div className="absolute z-50 w-full mt-1 bg-white border rounded-lg shadow-lg overflow-y-auto"
                            style={{ maxHeight: `${maxHeight}px` }}>
                            {filteredSuggestions.map((suggestion, index) => (
                                <div
                                    key={index}
                                    className={`px-3 py-2 cursor-pointer transition ${index === selectedIndex ? 'bg-blue-100' : 'hover:bg-gray-100'
                                        }`}
                                    onClick={() => selectSuggestion(suggestion)}
                                >
                                    {suggestion}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        // BARCODE SCANNER
        // BARCODE SCANNER - Uses Capacitor MLKit (native) with Html5Qrcode fallback (web)
        const BarcodeScanner = ({ onDetected, onClose }) => {
            const [online, setOnline] = useState(navigator.onLine);
            const [scanning, setScanning] = useState(false);
            const [error, setError] = useState(null);
            const [useWebFallback, setUseWebFallback] = useState(false);
            const scanSuccessful = React.useRef(false);
            const isMounted = React.useRef(true);

            useEffect(() => {
                window.addEventListener('online', () => setOnline(true));
                window.addEventListener('offline', () => setOnline(false));

                const startScanning = async () => {
                    try {
                        const plugins = window.Capacitor?.Plugins || {};
                        const pluginNames = Object.keys(plugins);

                        // DEBUG: Log all available Capacitor plugins to console
                        console.log('Available Capacitor Plugins:', pluginNames);

                        // Try multiple possible plugin names (MLKit barcode scanner might register differently)
                        const Scanner = plugins.BarcodeScanner || plugins.BarcodeScanning || plugins.MlkitBarcodeScanning || plugins.CapacitorMlkitBarcodeScanning;

                        // VISIBLE DEBUG: Show alert with plugin info (REMOVE AFTER DEBUGGING)
                        // alert(`DEBUG - Capacitor Plugins Found:\n\n${pluginNames.join(', ') || 'NONE'}\n\nBarcode Scanner: ${Scanner ? 'FOUND ‚úì' : 'NOT FOUND ‚úó'}`);

                        console.log('Found barcode scanner plugin:', Scanner ? 'Yes' : 'No (using web fallback)');

                        if (Scanner) {
                            try {
                                // Step 1: Check if Google Barcode Scanner Module is available
                                const { available } = await Scanner.isGoogleBarcodeScannerModuleAvailable();

                                if (!available) {
                                    // Module not installed - need to install it first
                                    alert('Installing Google Barcode Scanner... This is a one-time download.');

                                    // Install the module (downloads from Google Play Services)
                                    await Scanner.installGoogleBarcodeScannerModule();

                                    // Wait a moment for installation to complete
                                    await new Promise(resolve => setTimeout(resolve, 2000));

                                    // Check again
                                    const recheck = await Scanner.isGoogleBarcodeScannerModuleAvailable();
                                    if (!recheck.available) {
                                        alert('Module installation in progress. Please try again in a few seconds.');
                                        setUseWebFallback(true);
                                        return;
                                    }
                                }

                                // Step 2: Request permission
                                const permResult = await Scanner.requestPermissions();
                                console.log('Permission result:', permResult);

                                if (permResult.camera !== 'granted') {
                                    setError('Camera permission denied');
                                    return;
                                }

                                // Step 3: Start native scanner
                                if (isMounted.current) setScanning(true);
                                const result = await Scanner.scan({
                                    formats: ['EAN_13', 'EAN_8', 'UPC_A', 'UPC_E'],
                                });
                                scanSuccessful.current = true; // Mark as successfully finished

                                console.log('Scan result:', result);

                                // CRITICAL: Delay callback to let WebView fully resume
                                // after native scanner Activity closes
                                setTimeout(() => {
                                    if (isMounted.current) {
                                        setScanning(false);
                                        if (result.barcodes && result.barcodes.length > 0) {
                                            onDetected(result.barcodes[0].rawValue);
                                        } else {
                                            onClose();
                                        }
                                    }
                                }, 300);
                            } catch (innerErr) {
                                console.error('Scanner inner error:', innerErr);
                                // Fall back to web scanner on any error
                                if (isMounted.current) setUseWebFallback(true);
                            }
                        } else {
                            // No native plugin found - fall back to web scanner
                            console.log('Using web fallback (Html5QrcodeScanner)');
                            if (isMounted.current) setUseWebFallback(true);
                        }
                    } catch (err) {
                        // alert(`DEBUG OUTER ERROR:\n\n${err.message || err}`);
                        console.error('Barcode scan error:', err);
                        // On error, try web fallback
                        if (isMounted.current) setUseWebFallback(true);
                    }
                };

                startScanning();

                return () => {
                    isMounted.current = false;
                    // Cleanup for Capacitor scanner if needed
                    const plugins = window.Capacitor?.Plugins || {};
                    const Scanner = plugins.BarcodeScanner || plugins.BarcodeScanning || plugins.MlkitBarcodeScanning || plugins.CapacitorMlkitBarcodeScanning;

                    // SAFE CLEANUP: Only stop if scan was NOT successful (user cancelled or error)
                    // If scan was successful, plugin closes itself. Calling stopScan again causes freeze.
                    if (Scanner && Scanner.stopScan && !scanSuccessful.current) {
                        try { Scanner.stopScan(); } catch (e) { }
                    }
                };
            }, []);

            // Web fallback using Html5QrcodeScanner
            useEffect(() => {
                if (!useWebFallback) return;

                if (!window.Html5QrcodeScanner) {
                    setError('Barcode scanner not available');
                    return;
                }

                const scanner = new Html5QrcodeScanner("reader", { fps: 10, qrbox: 250 });
                scanner.render(
                    (decodedText) => { scanner.clear(); onDetected(decodedText); },
                    (err) => { /* ignore scan errors */ }
                );

                return () => { try { scanner.clear(); } catch (e) { } };
            }, [useWebFallback]);

            // Native scanning UI (minimal - camera is fullscreen)
            if (scanning && !useWebFallback) {
                return (
                    <div className="fixed inset-0 bg-black z-50 flex flex-col items-center justify-center modal-overlay">
                        <div className="text-white text-center">
                            <div className="w-12 h-12 border-4 border-white border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                            <p className="font-bold">Scanning...</p>
                            <p className="text-sm opacity-70">Point camera at barcode</p>
                        </div>
                        <button onClick={onClose} className="absolute top-4 right-4 text-white p-2">
                            <Icon name="X" size={24} />
                        </button>
                    </div>
                );
            }

            // Error UI
            if (error) {
                return (
                    <div className="fixed inset-0 bg-black z-50 flex flex-col items-center justify-center modal-overlay">
                        <div className="text-white text-center p-4">
                            <Icon name="AlertCircle" size={48} className="mx-auto mb-4 text-red-400" />
                            <p className="font-bold mb-2">Scanner Error</p>
                            <p className="text-sm opacity-70 mb-4">{error}</p>
                            <button onClick={onClose} className="bg-white text-black px-6 py-2 rounded-lg font-bold">
                                Close
                            </button>
                        </div>
                    </div>
                );
            }

            // Web fallback UI (Html5QrcodeScanner) with manual input option
            const [manualIsbn, setManualIsbn] = useState('');
            const handleManualSubmit = () => {
                if (manualIsbn && manualIsbn.length >= 10) {
                    onDetected(manualIsbn.replace(/[^0-9X]/gi, ''));
                } else {
                    alert('Please enter a valid ISBN (10 or 13 digits)');
                }
            };
            return (
                <div className="fixed inset-0 bg-black z-50 flex flex-col modal-overlay">
                    <div className="p-4 flex justify-between text-white bg-black/50 absolute top-0 w-full z-10 items-center">
                        <span className="flex items-center gap-2">
                            <div className={`w-3 h-3 rounded-full ${online ? 'bg-green-500' : 'bg-red-500'}`}></div>
                            {online ? 'Online' : 'Offline'}
                            {useWebFallback && <span className="text-xs opacity-50">(Web Mode)</span>}
                        </span>
                        <button onClick={onClose}><Icon name="X" /></button>
                    </div>
                    <div className="mt-16 p-4 bg-gray-800">
                        <div className="text-white text-sm mb-2">Type ISBN manually:</div>
                        <div className="flex gap-2">
                            <input type="text" value={manualIsbn} onChange={(e) => setManualIsbn(e.target.value)}
                                placeholder="Enter ISBN-10 or ISBN-13"
                                className="flex-1 p-3 rounded-lg text-black"
                                onKeyPress={(e) => e.key === 'Enter' && handleManualSubmit()} />
                            <button onClick={async () => { try { const t = await navigator.clipboard.readText(); setManualIsbn(t.replace(/[^0-9X]/gi, '')); } catch (e) { alert('Could not read clipboard'); } }} className="bg-gray-600 text-white px-3 py-2 rounded-lg font-bold">
                                Paste
                            </button>
                            <button onClick={handleManualSubmit} className="bg-blue-500 text-white px-4 py-2 rounded-lg font-bold">
                                Search
                            </button>
                        </div>
                        <button onClick={async () => {
                            try {
                                const items = await navigator.clipboard.read();
                                let imgBlob = null;
                                for (let i = 0; i < items.length; i++) {
                                    for (let j = 0; j < items[i].types.length; j++) {
                                        if (items[i].types[j].indexOf('image') === 0) {
                                            imgBlob = await items[i].getType(items[i].types[j]);
                                            break;
                                        }
                                    }
                                    if (imgBlob) break;
                                }
                                if (!imgBlob) { alert('No image in clipboard. Use Snipping Tool first.'); return; }
                                const imageUrl = URL.createObjectURL(imgBlob);
                                const html5QrCode = new Html5Qrcode('temp-reader');
                                const result = await html5QrCode.scanFile(new File([imgBlob], 'clipboard.png', { type: imgBlob.type }), true);
                                html5QrCode.clear();
                                URL.revokeObjectURL(imageUrl);
                                if (result) { onDetected(result); }
                            } catch (e) {
                                alert('Could not find barcode in image: ' + e.message);
                            }
                        }} className="mt-2 w-full bg-green-600 text-white px-4 py-3 rounded-lg font-bold">
                            Scan Barcode from Screenshot
                        </button>
                        <div id="temp-reader" style={{ display: 'none' }}></div>
                    </div>
                    <div id="reader" className="flex-1 bg-white"></div>
                </div>
            );
        };

        // BOOK FORM
        const BookForm = ({ book, onSave, onCancel, onBarcodeFound, globalCurrency, books = [] }) => {
            const [form, setForm] = useState(book ? { ...book, pages: book.pages || [] } : {
                title: '', phonetic: '', author_name: '', author_initials: '', owner: '', building: '', shelf: '', isbn: '',
                price: '', currency: '‚Çπ', year: '', lang: 'en', tags: [], status: 'avail', page_count: '', condition: 'Good',
                front: null, rear: null, thumb: null, pages: []
            });
            const [scanMode, setScanMode] = useState(false);
            const [scanError, setScanError] = useState(null); // { title, message }
            const [listeningField, setListeningField] = useState(null);

            // Auto-fill phonetic for English books when title changes (works with barcode scanner)
            useEffect(() => {
                if (form.lang === 'en' && form.title && !form.phonetic) {
                    setForm(f => ({ ...f, phonetic: f.title }));
                }
            }, [form.title]);

            // Capture image using Capacitor Camera (replaces unreliable HTML file input)            // Capture image using Capacitor Camera
            const captureImage = async (field, sourceType = 'Prompt') => {
                try {
                    setForm(prev => ({ ...prev, [field]: 'loading' }));

                    const { Camera, CameraSource, CameraResultType } = window.Capacitor?.Plugins || {};
                    if (Camera) {
                        // Map source type to CameraSource enum or use direct value
                        const sourceValue = CameraSource ?
                            (sourceType === 'Camera' ? CameraSource.Camera :
                                sourceType === 'Photos' ? CameraSource.Photos :
                                    CameraSource.Prompt) : sourceType;

                        const resultType = CameraResultType ? CameraResultType.DataUrl : 'dataUrl';

                        // Use Capacitor Camera plugin
                        const image = await Camera.getPhoto({
                            quality: 80,
                            allowEditing: false,
                            resultType: resultType,
                            source: sourceValue,
                            width: 800,
                            height: 1200,
                            correctOrientation: true
                        });

                        // Compress using existing ImageUtils
                        const compressed = await ImageUtils.compressDataUrl(image.dataUrl);
                        setForm(prev => ({ ...prev, [field]: compressed }));
                    } else {
                        // Fallback for Windows/Web: Show custom popup
                        const choice = await new Promise((resolve) => {
                            const overlay = document.createElement('div');
                            overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:9999';
                            const popup = document.createElement('div');
                            popup.style.cssText = 'background:white;border-radius:12px;padding:20px;min-width:220px;box-shadow:0 4px 20px rgba(0,0,0,0.3)';
                            popup.innerHTML = '<div style="font-weight:bold;margin-bottom:15px;text-align:center">Add Image</div>';
                            const browseBtn = document.createElement('button');
                            browseBtn.textContent = 'Browse File';
                            browseBtn.style.cssText = 'width:100%;padding:12px;margin-bottom:8px;border:1px solid #ddd;border-radius:8px;background:#f8f8f8;cursor:pointer;font-size:14px';
                            browseBtn.onclick = () => { document.body.removeChild(overlay); resolve('browse'); };
                            const pasteBtn = document.createElement('button');
                            pasteBtn.textContent = 'Paste from Clipboard';
                            pasteBtn.style.cssText = 'width:100%;padding:12px;border:1px solid #ddd;border-radius:8px;background:#f8f8f8;cursor:pointer;font-size:14px';
                            pasteBtn.onclick = () => { document.body.removeChild(overlay); resolve('paste'); };
                            const cancelBtn = document.createElement('button');
                            cancelBtn.textContent = 'Cancel';
                            cancelBtn.style.cssText = 'width:100%;padding:8px;margin-top:12px;border:none;background:transparent;color:#666;cursor:pointer';
                            cancelBtn.onclick = () => { document.body.removeChild(overlay); resolve(null); };
                            popup.appendChild(browseBtn);
                            popup.appendChild(pasteBtn);
                            popup.appendChild(cancelBtn);
                            overlay.appendChild(popup);
                            overlay.onclick = (e) => { if (e.target === overlay) { document.body.removeChild(overlay); resolve(null); } };
                            document.body.appendChild(overlay);
                        });
                        if (!choice) { setForm(prev => ({ ...prev, [field]: null })); return; }
                        if (choice === 'paste') {
                            try {
                                const clipItems = await navigator.clipboard.read();
                                let imgBlob = null;
                                for (let i = 0; i < clipItems.length; i++) {
                                    const item = clipItems[i];
                                    for (let j = 0; j < item.types.length; j++) {
                                        const mimeType = item.types[j];
                                        if (mimeType.indexOf('image') === 0) {
                                            imgBlob = await item.getType(mimeType);
                                            break;
                                        }
                                    }
                                    if (imgBlob) break;
                                }
                                if (imgBlob) {
                                    const res = await ImageUtils.process(imgBlob);
                                    setForm(prev => ({ ...prev, [field]: res }));
                                } else {
                                    alert('No image found in clipboard');
                                    setForm(prev => ({ ...prev, [field]: null }));
                                }
                            } catch (clipErr) {
                                alert('Clipboard error: ' + clipErr.message);
                                setForm(prev => ({ ...prev, [field]: null }));
                            }
                        } else {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = 'image/*';
                            input.onchange = async (e) => {
                                const file = e.target.files?.[0];
                                if (file) {
                                    const res = await ImageUtils.process(file);
                                    setForm(prev => ({ ...prev, [field]: res }));
                                } else {
                                    setForm(prev => ({ ...prev, [field]: null }));
                                }
                            };
                            input.click();
                        }
                    }
                } catch (err) {
                    setForm(prev => ({ ...prev, [field]: null }));
                    if (err.message && !err.message.includes('cancelled')) {
                        alert('Camera error: ' + err.message);
                    }
                }
            };

            // Legacy file input handler (for pages/additional images)
            const handleImg = async (e, field) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    try {
                        setForm(prev => ({ ...prev, [field]: 'loading' }));
                        const res = await ImageUtils.process(file);
                        setForm(prev => ({ ...prev, [field]: res }));
                    } catch (err) {
                        setForm(prev => ({ ...prev, [field]: null }));
                        alert("Error: " + err);
                    }
                }
                // Clear input to allow re-selecting same file
                e.target.value = '';
            };

            const handlePageAdd = async (e) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    try {
                        const res = await ImageUtils.process(file);
                        setForm(f => ({ ...f, pages: [...(f.pages || []), res] }));
                    } catch (err) { alert("Error: " + err); }
                }
            };

            // Capture page image using Capacitor Camera
            const capturePageImage = async (sourceType = 'Prompt') => {
                try {
                    const { Camera, CameraSource, CameraResultType } = window.Capacitor?.Plugins || {};
                    if (Camera) {
                        // Map source type to CameraSource enum
                        const sourceValue = CameraSource ?
                            (sourceType === 'Camera' ? CameraSource.Camera :
                                sourceType === 'Photos' ? CameraSource.Photos :
                                    CameraSource.Prompt) : sourceType;

                        const resultType = CameraResultType ? CameraResultType.DataUrl : 'dataUrl';

                        const image = await Camera.getPhoto({
                            quality: 80,
                            allowEditing: false,
                            resultType: resultType,
                            source: sourceValue,
                            width: 800,
                            height: 1200,
                            correctOrientation: true
                        });
                        const compressed = await ImageUtils.compressDataUrl(image.dataUrl);
                        setForm(f => ({ ...f, pages: [...(f.pages || []), compressed] }));
                    } else {
                        // Fallback for Windows/Web: Show custom popup
                        const choice = await new Promise((resolve) => {
                            const overlay = document.createElement('div');
                            overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:9999';
                            const popup = document.createElement('div');
                            popup.style.cssText = 'background:white;border-radius:12px;padding:20px;min-width:220px;box-shadow:0 4px 20px rgba(0,0,0,0.3)';
                            popup.innerHTML = '<div style="font-weight:bold;margin-bottom:15px;text-align:center">Add Page</div>';
                            const browseBtn = document.createElement('button');
                            browseBtn.textContent = 'Browse File';
                            browseBtn.style.cssText = 'width:100%;padding:12px;margin-bottom:8px;border:1px solid #ddd;border-radius:8px;background:#f8f8f8;cursor:pointer;font-size:14px';
                            browseBtn.onclick = () => { document.body.removeChild(overlay); resolve('browse'); };
                            const pasteBtn = document.createElement('button');
                            pasteBtn.textContent = 'Paste from Clipboard';
                            pasteBtn.style.cssText = 'width:100%;padding:12px;border:1px solid #ddd;border-radius:8px;background:#f8f8f8;cursor:pointer;font-size:14px';
                            pasteBtn.onclick = () => { document.body.removeChild(overlay); resolve('paste'); };
                            const cancelBtn = document.createElement('button');
                            cancelBtn.textContent = 'Cancel';
                            cancelBtn.style.cssText = 'width:100%;padding:8px;margin-top:12px;border:none;background:transparent;color:#666;cursor:pointer';
                            cancelBtn.onclick = () => { document.body.removeChild(overlay); resolve(null); };
                            popup.appendChild(browseBtn);
                            popup.appendChild(pasteBtn);
                            popup.appendChild(cancelBtn);
                            overlay.appendChild(popup);
                            overlay.onclick = (e) => { if (e.target === overlay) { document.body.removeChild(overlay); resolve(null); } };
                            document.body.appendChild(overlay);
                        });
                        if (!choice) return;
                        if (choice === 'paste') {
                            try {
                                const items = await navigator.clipboard.read();
                                let imgBlob = null;
                                for (let i = 0; i < items.length; i++) {
                                    for (let j = 0; j < items[i].types.length; j++) {
                                        if (items[i].types[j].indexOf('image') === 0) {
                                            imgBlob = await items[i].getType(items[i].types[j]);
                                            break;
                                        }
                                    }
                                    if (imgBlob) break;
                                }
                                if (imgBlob) {
                                    const res = await ImageUtils.process(imgBlob);
                                    setForm(f => ({ ...f, pages: [...(f.pages || []), res] }));
                                } else {
                                    alert('No image found in clipboard');
                                }
                            } catch (clipErr) {
                                alert('Clipboard error: ' + clipErr.message);
                            }
                        } else {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = 'image/*';
                            input.onchange = async (e) => {
                                const file = e.target.files?.[0];
                                if (file) {
                                    const res = await ImageUtils.process(file);
                                    setForm(f => ({ ...f, pages: [...(f.pages || []), res] }));
                                }
                            };
                            input.click();
                        }
                    }
                } catch (err) {
                    if (err.message && !err.message.includes('cancelled')) {
                        alert('Camera error: ' + err.message);
                    }
                }
            };



            const handleBarcode = async (isbn) => {
                setScanMode(false); // Immediate close to prevent crash
                try {
                    const exists = await db.books.where('isbn').equals(isbn).first();
                    if (exists) {
                        setScanError({
                            title: "Duplicate Found",
                            message: "This book is already in your library."
                        });
                        return;
                    }

                    if (navigator.onLine) {
                        try {
                            const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`);
                            const data = await res.json();
                            if (data.items && data.items[0]) {
                                const info = data.items[0].volumeInfo;
                                setForm(f => ({
                                    ...f, isbn: isbn, title: info.title,
                                    author_name: info.authors?.[0] || '', author_initials: '',
                                    publisher: info.publisher, pub_year: info.publishedDate?.substring(0, 4),
                                    front: info.imageLinks?.thumbnail, page_count: info.pageCount
                                }));
                            } else {
                                setScanError({ title: "Not Found", message: "Book details not found in online API." });
                            }
                        } catch (e) {
                            setScanError({ title: "API Error", message: "Please check internet connection." });
                        }
                    } else {
                        setForm(f => ({ ...f, isbn: isbn }));
                        setScanError({ title: "Offline", message: "ISBN saved. Please enter book details manually." });
                    }
                } catch (err) {
                    console.error('handleBarcode error:', err);
                    setScanError({ title: "Error", message: "Something went wrong. Please try again." });
                }
            };

            // NATIVE SCAN: Bypasses BarcodeScanner component entirely
            // Calls Scanner.scan() directly from button click ‚Äî no lifecycle conflicts
            const startNativeScan = async () => {
                const plugins = window.Capacitor?.Plugins || {};
                const Scanner = plugins.BarcodeScanner || plugins.BarcodeScanning || plugins.MlkitBarcodeScanning || plugins.CapacitorMlkitBarcodeScanning;

                if (!Scanner) {
                    // No native scanner ‚Äî use web fallback component
                    setScanMode(true);
                    return;
                }

                try {
                    // Check module availability
                    const { available } = await Scanner.isGoogleBarcodeScannerModuleAvailable();
                    if (!available) {
                        setScanError({ title: "Setup", message: "Installing scanner module. Please try again in a few seconds." });
                        await Scanner.installGoogleBarcodeScannerModule();
                        return;
                    }

                    // Check permissions
                    const permResult = await Scanner.requestPermissions();
                    if (permResult.camera !== 'granted') {
                        setScanError({ title: "Permission", message: "Camera permission is required to scan barcodes." });
                        return;
                    }

                    // Scan ‚Äî opens native camera, waits for result, closes camera
                    const result = await Scanner.scan({
                        formats: ['EAN_13', 'EAN_8', 'UPC_A', 'UPC_E'],
                    });

                    console.log('Native scan result:', result);

                    if (result.barcodes && result.barcodes.length > 0) {
                        // Small delay to let WebView fully resume after native Activity
                        await new Promise(r => setTimeout(r, 300));
                        await handleBarcode(result.barcodes[0].rawValue);
                    }
                    // If no barcodes, user cancelled ‚Äî do nothing
                } catch (err) {
                    // User cancelled scan ‚Äî do nothing
                    if (err.message && (err.message.includes('cancel') || err.message.includes('closed'))) return;
                    console.error('Native scan error:', err);
                    setScanError({ title: "Scanner Error", message: err.message || "Could not open scanner." });
                }
            };

            let activeRecognition = null;
            let voiceTimeout = null;

            const stopVoice = () => {
                if (activeRecognition) {
                    try { activeRecognition.stop(); } catch (e) { }
                    activeRecognition = null;
                }
                if (voiceTimeout) {
                    clearTimeout(voiceTimeout);
                    voiceTimeout = null;
                }
                setListeningField(null);
            };

            const startVoice = async (field) => {
                // 0. Toggle Logic
                if (listeningField === field) {
                    stopVoice();
                    return;
                }
                stopVoice();

                if (!navigator.onLine) return alert("No Internet Connection.");

                // Determine language
                const useNative = field === 'title' && form.lang !== 'en';
                const language = useNative
                    ? (form.lang === 'ml' ? 'ml-IN' : form.lang === 'ar' ? 'ar-SA' : 'hi-IN')
                    : 'en-US';

                // Use Native Plugin if in Capacitor
                const NativeSpeech = window.Capacitor?.Plugins?.SpeechRecognition;

                if (window.Capacitor && NativeSpeech) {
                    try {
                        // Check availability
                        const { available } = await NativeSpeech.available();
                        if (!available) return alert("Speech Recognition not available on this device.");

                        // Check/Request permissions
                        const permStatus = await NativeSpeech.checkPermissions();
                        if (permStatus.speechRecognition !== 'granted') {
                            const req = await NativeSpeech.requestPermissions();
                            if (req.speechRecognition !== 'granted') return alert("Microphone permission denied.");
                        }

                        setListeningField(field);

                        // Start native recognition
                        const result = await NativeSpeech.start({
                            language: language,
                            popup: false,
                            partialResults: false
                        });

                        if (result.matches && result.matches.length > 0) {
                            const transcript = result.matches[0];
                            if (field === 'tags') {
                                const newTags = transcript.split(/[\s,]+/).filter(Boolean);
                                setForm(f => ({ ...f, tags: [...(f.tags || []), ...newTags] }));
                            } else {
                                setForm(f => ({ ...f, [field]: transcript }));
                            }
                        }
                        stopVoice();
                    } catch (e) {
                        stopVoice();
                        if (e.message && e.message.includes('cancelled')) return; // User cancelled
                        alert("Voice Error: " + (e.message || e));
                    }
                } else {
                    // Fallback to Web Speech API (for browser testing)
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SpeechRecognition) return alert("Speech not supported in browser.");

                    try {
                        const recognition = new SpeechRecognition();
                        activeRecognition = recognition;
                        recognition.lang = language;
                        recognition.continuous = false;
                        recognition.interimResults = false;

                        recognition.onstart = () => setListeningField(field);
                        recognition.onend = () => stopVoice();
                        recognition.onerror = (e) => { stopVoice(); };
                        recognition.onresult = (event) => {
                            const transcript = event.results[0][0].transcript;
                            if (field === 'tags') {
                                const newTags = transcript.split(/[\s,]+/).filter(Boolean);
                                setForm(f => ({ ...f, tags: [...(f.tags || []), ...newTags] }));
                            } else {
                                setForm(f => ({ ...f, [field]: transcript }));
                            }
                            stopVoice();
                        };
                        recognition.start();
                    } catch (e) {
                        alert("Error: " + e.message);
                    }
                }
            };


            const saveCheck = async () => {
                const exists = await db.books.where('title').equalsIgnoreCase(form.title).toArray();
                if (exists.length > 0) {
                    const isSelf = form.id && exists.length === 1 && exists[0].id === form.id;
                    if (!isSelf && !confirm(`Possible Duplicate: "${form.title}" exists. Save anyway?`)) return;
                }
                onSave(form);
            };

            const handleChange = (field, val) => setForm(prev => ({ ...prev, [field]: val }));

            return (
                <div className="bg-white min-h-screen pb-24">
                    {scanMode && <BarcodeScanner onDetected={handleBarcode} onClose={() => setScanMode(false)} />}

                    {/* SAFE LOOP MODAL: Replacing Alerts to prevent white-screen crashes */}
                    {scanError && (
                        <div className="fixed inset-0 bg-black/80 z-[60] flex items-center justify-center p-6 animate-fade-in">
                            <div className="bg-white rounded-xl p-6 w-full max-w-sm text-center shadow-2xl">
                                <Icon name="AlertTriangle" size={48} className="mx-auto text-yellow-500 mb-4" />
                                <h3 className="font-bold text-xl mb-2">{scanError.title}</h3>
                                <p className="text-gray-600 mb-8">{scanError.message}</p>

                                <div className="flex gap-3">
                                    <button
                                        onClick={() => setScanError(null)}
                                        className="flex-1 py-3 text-gray-600 font-bold bg-gray-100 rounded-lg"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={() => {
                                            setScanError(null);
                                            startNativeScan();
                                        }}
                                        className="flex-1 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-lg"
                                    >
                                        Scan Again
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="p-4 border-b flex justify-between sticky top-0 bg-white z-20 shadow-sm">
                        <button onClick={onCancel} className="text-gray-500">Cancel</button>
                        <h2 className="font-bold">{book ? 'Edit' : 'Cataloging'}</h2>
                        <button onClick={saveCheck} className="text-blue-600 font-bold">Save</button>
                    </div>

                    <div className="p-4 space-y-5">
                        {!book && <button onClick={startNativeScan} className="w-full py-4 bg-gray-800 text-white rounded-xl flex flex-col items-center justify-center font-bold mb-4"><Icon name="Barcode" size={32} /> <span>Scan Barcode</span></button>}

                        {/* GALLERY */}
                        <div className="flex gap-3 overflow-x-auto pb-2 no-scrollbar">
                            {/* FRONT COVER */}
                            <div className="flex-shrink-0 w-28 h-40 bg-gray-100 rounded-lg border-2 border-dashed border-gray-300 relative overflow-hidden group">
                                {form.front === 'loading' ? (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                                        <div className="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                                        <span className="text-[10px] mt-1">Processing...</span>
                                    </div>
                                ) : form.front ? <img src={form.front} className="w-full h-full object-cover" /> : <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400"><Icon name="Maximize" /><span className="text-[10px]">Front</span></div>}
                                <div className="absolute bottom-0 left-0 right-0 flex bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <button onClick={() => captureImage('front', 'Prompt')} className="flex-1 p-2 text-white text-center hover:bg-black/30" title="Add Photo">
                                        <Icon name="Camera" size={14} />
                                    </button>
                                </div>
                            </div>

                            {/* REAR COVER */}
                            <div className="flex-shrink-0 w-28 h-40 bg-gray-100 rounded-lg border-2 border-dashed border-gray-300 relative overflow-hidden group">
                                {form.rear === 'loading' ? (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                                        <div className="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                                        <span className="text-[10px] mt-1">Processing...</span>
                                    </div>
                                ) : form.rear ? <img src={form.rear} className="w-full h-full object-cover" /> : <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400"><Icon name="Maximize" /><span className="text-[10px]">Rear</span></div>}
                                <div className="absolute bottom-0 left-0 right-0 flex bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <button onClick={() => captureImage('rear', 'Prompt')} className="flex-1 p-2 text-white text-center hover:bg-black/30" title="Add Photo">
                                        <Icon name="Camera" size={14} />
                                    </button>
                                </div>
                            </div>
                        </div>

                        {/* PAGES */}
                        <div className="flex gap-2 overflow-x-auto pb-2">
                            {(form.pages || []).map((p, i) => (
                                <div key={i} className="flex-shrink-0 w-28 h-40 relative group">
                                    <img src={p} className="w-full h-full object-cover rounded-lg border" />
                                    <button onClick={() => setForm(f => ({ ...f, pages: f.pages.filter((_, idx) => idx !== i) }))} className="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1"><Icon name="X" size={12} /></button>
                                </div>
                            ))}
                            {/* Add Page */}
                            <button onClick={() => capturePageImage('Prompt')} className="flex-shrink-0 w-28 h-40 bg-gray-100 border-2 border-dashed border-gray-300 rounded-lg flex flex-col items-center justify-center overflow-hidden cursor-pointer hover:bg-gray-50">
                                <Icon name="Plus" className="text-gray-400" />
                                <span className="text-[10px] font-bold text-gray-400 mt-1">Add Page</span>
                            </button>
                        </div>

                        {/* META DATA */}
                        <div className="space-y-3">
                            <div className="flex gap-2 mb-2">
                                {['en', 'ml', 'hi', 'ar'].map(l => (
                                    <button key={l} onClick={() => {
                                        // Auto-fill phonetic for English books
                                        const updates = { lang: l, language: LANG_MAP[l] };
                                        if (l === 'en' && form.title) {
                                            updates.phonetic = form.title;
                                        }
                                        setForm({ ...form, ...updates });
                                    }} className={`px-3 py-1 rounded text-xs font-bold uppercase border ${form.lang === l ? 'bg-blue-600 text-white' : 'bg-white text-gray-600'}`}>{l}</button>
                                ))}
                            </div>

                            <VoiceInput label="Title (Native)" field="title" value={form.title} onChange={(e) => {
                                const newTitle = e.target.value;
                                handleChange('title', newTitle);
                                // Auto-fill phonetic if English and title changed
                                if (form.lang === 'en' && newTitle) {
                                    handleChange('phonetic', newTitle);
                                }
                            }} onVoice={() => startVoice('title')} isListening={listeningField === 'title'} lang={form.lang} />
                            <div>
                                <VoiceInput label="Phonetic (Manual)" field="phonetic" value={form.phonetic} onChange={(e) => handleChange('phonetic', e.target.value)} onVoice={() => startVoice('phonetic')} isListening={listeningField === 'phonetic'} lang="en" />
                                {form.lang === 'en' && <p className="text-xs text-gray-500 mt-1 ml-1">‚úì Auto-filled for English books (editable)</p>}
                            </div>
                            <VoiceInput label="ISBN" field="isbn" value={form.isbn} onChange={(e) => handleChange('isbn', e.target.value)} onVoice={() => startVoice('isbn')} isListening={listeningField === 'isbn'} lang="en" />

                            <div className="flex gap-2 relative">
                                <div className="flex-1 relative">
                                    <AutocompleteInput label="Author Name" field="author_name" value={form.author_name} onChange={(e) => handleChange('author_name', e.target.value)} allBooks={books} placeholder="e.g., J.K. Rowling" />
                                    <button type="button" onClick={() => startVoice('author_name')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'author_name' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                                </div>
                                <div className="w-1/3">
                                    <label className="text-xs text-gray-500 font-bold">Initials</label>
                                    <input className="w-full p-3 border rounded-lg" value={form.author_initials || ''} onChange={(e) => handleChange('author_initials', e.target.value)} placeholder="A K" />
                                </div>
                            </div>

                            <div className="grid grid-cols-2 gap-4">
                                <div className="relative">
                                    <AutoSuggestInput label="Publisher" field="publisher" value={form.publisher} onChange={(e) => handleChange('publisher', e.target.value)} />
                                    <button type="button" onClick={() => startVoice('publisher')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'publisher' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                                </div>
                                <VoiceInput label="Pub Year" field="pub_year" value={form.pub_year} onChange={(e) => handleChange('pub_year', e.target.value)} onVoice={() => startVoice('pub_year')} isListening={listeningField === 'pub_year'} lang="en" type="number" />
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <VoiceInput label="Pages" field="page_count" value={form.page_count} onChange={(e) => handleChange('page_count', e.target.value)} type="number" lang="en" />
                                <AutocompleteInput label="Condition" field="condition" value={form.condition} onChange={(e) => handleChange('condition', e.target.value)} allBooks={books} placeholder="e.g., Good, New" />
                            </div>
                        </div>

                        {/* ASSET DATA */}
                        <h3 className="text-xs font-bold text-gray-400 uppercase mt-4">Asset Info</h3>
                        <div className="space-y-3">
                            <div className="relative">
                                <AutocompleteInput label="Owner" field="owner" value={form.owner} onChange={(e) => handleChange('owner', e.target.value)} allBooks={books} placeholder="e.g., Dad, Mom" />
                                <button type="button" onClick={() => startVoice('owner')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'owner' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                            </div>

                            <div className="grid grid-cols-2 gap-4">
                                <div className="flex gap-1">
                                    <div className="w-1/3">
                                        <label className="text-xs text-gray-500 font-bold">Currency</label>
                                        <input className="w-full p-3 border rounded-lg text-center font-bold" value={form.currency} onChange={e => handleChange('currency', e.target.value)} list="currencies" />
                                        <datalist id="currencies"><option value="‚Çπ" /><option value="$" /><option value="QAR" /></datalist>
                                    </div>
                                    <div className="w-2/3">
                                        <label className="text-xs text-gray-500 font-bold">Price</label>
                                        <input type="number" className="w-full p-3 border rounded-lg" value={form.price} onChange={e => handleChange('price', e.target.value)} />
                                    </div>
                                </div>
                                <VoiceInput label="Buy Year" field="buy_year" value={form.buy_year} onChange={(e) => handleChange('buy_year', e.target.value)} onVoice={() => startVoice('buy_year')} isListening={listeningField === 'buy_year'} lang="en" type="number" />
                            </div>
                        </div>

                        {/* LOCATION */}
                        <h3 className="text-xs font-bold text-gray-400 uppercase mt-4">Location</h3>
                        <div className="grid grid-cols-2 gap-4">
                            <AutocompleteInput label="Building" field="building" value={form.building} onChange={(e) => handleChange('building', e.target.value)} allBooks={books} placeholder="e.g., Main Library" />
                            <AutoSuggestInput label="Shelf" field="shelf" value={form.shelf} onChange={(e) => handleChange('shelf', e.target.value)} />
                        </div>


                        <TagTokenInput
                            label="Tags"
                            value={form.tags || []}
                            onChange={(newTags) => setForm(f => ({ ...f, tags: newTags }))}
                            allBooks={books}
                            placeholder="Add tags (e.g., Fiction, History)..."
                        />

                    </div>
                </div>
            );
        };

        // MULTI-TAG SEARCH INPUT
        const MultiTagInput = ({ options, value, onChange, placeholder }) => {
            const [input, setInput] = useState('');
            const [filteredOpts, setFilteredOpts] = useState([]);

            // Suggest logic
            useEffect(() => {
                if (!input) { setFilteredOpts([]); return; }
                const q = input.toLowerCase();
                const matches = options.filter(o => o.toLowerCase().includes(q) && !value.includes(o)).slice(0, 5);
                setFilteredOpts(matches);
            }, [input, options, value]);

            const addTag = (t) => {
                onChange([...value, t]);
                setInput('');
            };

            const removeTag = (t) => {
                onChange(value.filter(v => v !== t));
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (filteredOpts.length > 0) addTag(filteredOpts[0]);
                    else if (input) { addTag(input); }
                }
                if (e.key === 'Backspace' && !input && value.length > 0) {
                    removeTag(value[value.length - 1]);
                }
            };

            return (
                <div className="flex items-center gap-2 flex-wrap bg-gray-100 p-2 rounded-lg border focus-within:ring-2 focus-within:ring-blue-200">
                    <Icon name="Search" className="text-gray-400" size={16} />
                    {value.map(t => (
                        <span key={t} className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full flex items-center gap-1">
                            {t}
                            <button onClick={() => removeTag(t)} className="hover:text-red-500">√ó</button>
                        </span>
                    ))}
                    <div className="relative flex-1 min-w-[60px]">
                        <input
                            className="w-full bg-transparent text-sm focus:outline-none min-w-[100px]"
                            placeholder={value.length > 0 ? "" : placeholder}
                            value={input}
                            onChange={e => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                        />
                        {filteredOpts.length > 0 && (
                            <div className="absolute top-full left-0 bg-white border shadow-lg rounded mt-1 z-50 w-full min-w-[150px]">
                                {filteredOpts.map(o => (
                                    <div key={o} onClick={() => addTag(o)} className="p-2 text-sm hover:bg-gray-100 cursor-pointer">{o}</div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- BULK EDIT MODAL ---
        const BulkEditModal = ({ selectedIds, books, onClose, onApply }) => {
            const [field, setField] = useState('owner');
            const [value, setValue] = useState('');
            const [tagValue, setTagValue] = useState([]); // For TagTokenInput
            const [tagAction, setTagAction] = useState('add');

            // Preview: Show current values summary
            const preview = useMemo(() => {
                const selected = books.filter(b => selectedIds.includes(b.id));
                const counts = {};
                selected.forEach(b => {
                    let v;
                    if (field === 'tags') v = (b.tags || []).join(', ') || '(no tags)';
                    else v = b[field] || '(empty)';
                    counts[v] = (counts[v] || 0) + 1;
                });
                return Object.entries(counts).sort((a, b) => b[1] - a[1]);
            }, [selectedIds, books, field]);

            // Suggestions for autocomplete
            const suggestions = useMemo(() => {
                const set = new Set();
                books.forEach(b => {
                    if (field === 'owner' && b.owner) set.add(b.owner);
                    if (field === 'building' && b.building) set.add(b.building);
                    if (field === 'tags' && b.tags) b.tags.forEach(t => set.add(t));
                    if (field === 'publisher' && b.publisher) set.add(b.publisher);
                    if (field === 'author_name' && b.author_name) set.add(b.author_name);
                });
                return [...set].sort();
            }, [books, field]);

            // Reset tagValue when switching away from tags field
            useEffect(() => {
                if (field !== 'tags') {
                    setTagValue([]);
                }
            }, [field]);

            const handleApply = async () => {
                // Validate based on field type
                if (field === 'tags') {
                    if (tagValue.length === 0) return alert("Please enter at least one tag");
                } else {
                    if (!value.trim()) return alert("Please enter a value");
                }

                for (const id of selectedIds) {
                    const book = await db.books.get(id);
                    const update = {};

                    if (field === 'owner') update.owner = value.trim();
                    if (field === 'building') update.building = value.trim();
                    if (field === 'publisher') update.publisher = value.trim();
                    if (field === 'author_name') update.author_name = value.trim();
                    if (field === 'tags') {
                        // Use tagValue array directly (from TagTokenInput)
                        update.tags = tagAction === 'add'
                            ? [...new Set([...(book.tags || []), ...tagValue])]
                            : (book.tags || []).filter(t => !tagValue.includes(t));
                    }

                    await db.books.update(id, update);
                }
                alert(`Updated ${selectedIds.length} books!`);
                onApply();
            };

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 modal-overlay">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                        <div className="p-4 border-b flex justify-between items-center sticky top-0 bg-white">
                            <h3 className="font-bold text-lg">Bulk Edit ({selectedIds.length} books)</h3>
                            <button onClick={onClose} className="p-2 hover:bg-gray-100 rounded"><Icon name="X" /></button>
                        </div>
                        <div className="p-4 space-y-4">
                            <div>
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-2">Change</label>
                                <div className="flex gap-2 flex-wrap">
                                    {['owner', 'building', 'publisher', 'author_name', 'tags'].map(f => (
                                        <button key={f} onClick={() => { setField(f); setValue(''); }}
                                            className={`px-3 py-2 rounded text-sm font-bold capitalize ${field === f ? 'bg-blue-600 text-white' : 'bg-gray-100'}`}
                                        >{f.replace('_', ' ')}</button>
                                    ))}
                                </div>
                            </div>

                            {/* Tag Action Toggle */}
                            {field === 'tags' && (
                                <div className="flex gap-2">
                                    <button onClick={() => setTagAction('add')}
                                        className={`px-3 py-1 rounded text-xs font-bold ${tagAction === 'add' ? 'bg-green-600 text-white' : 'bg-gray-100'}`}
                                    >+ Add Tags</button>
                                    <button onClick={() => setTagAction('remove')}
                                        className={`px-3 py-1 rounded text-xs font-bold ${tagAction === 'remove' ? 'bg-red-600 text-white' : 'bg-gray-100'}`}
                                    >- Remove Tags</button>
                                </div>
                            )}

                            {/* Preview Current Values */}
                            <div className="bg-gray-50 p-3 rounded border">
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-2">üìä Current Values</label>
                                <div className="max-h-24 overflow-y-auto space-y-1">
                                    {preview.map(([v, count]) => (
                                        <div key={v} className="flex justify-between text-sm">
                                            <span className="truncate">{v}</span>
                                            <span className="font-bold text-gray-500">{count}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* New Value Input */}
                            <div>
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-2">
                                    {field === 'tags' ? (tagAction === 'add' ? 'Tags to Add' : 'Tags to Remove') : `New ${field}`}
                                </label>
                                {field === 'tags' ? (
                                    <TagTokenInput
                                        label=""
                                        value={tagValue}
                                        onChange={setTagValue}
                                        allBooks={books}
                                        placeholder={tagAction === 'add' ? "Add tags..." : "Remove tags..."}
                                    />
                                ) : (
                                    <>
                                        <input
                                            list="bulk-suggestions"
                                            className="w-full p-3 border rounded"
                                            placeholder={`Enter ${field}...`}
                                            value={value}
                                            onChange={e => setValue(e.target.value)}
                                        />
                                        <datalist id="bulk-suggestions">
                                            {suggestions.map(s => <option key={s} value={s} />)}
                                        </datalist>
                                    </>
                                )}
                            </div>

                            {/* Apply Button */}
                            <button
                                onClick={handleApply}
                                className="w-full py-3 bg-blue-600 text-white rounded-lg font-bold text-lg"
                            >
                                Apply to {selectedIds.length} Books
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- SLICER SEARCH ---
        const SlicerSearch = ({ books, onEdit }) => {
            const [activeFilters, setActiveFilters] = useState(() => {
                try {
                    const saved = sessionStorage.getItem('shelfLife_slicerFilters');
                    return saved ? JSON.parse(saved) : [];
                } catch { return []; }
            });
            const [pendingField, setPendingField] = useState('publisher');
            const [pendingValue, setPendingValue] = useState('');
            const [viewMode, setViewMode] = useState('grid');
            const [detailBook, setDetailBook] = useState(null);

            // Persist filters to sessionStorage
            useEffect(() => {
                sessionStorage.setItem('shelfLife_slicerFilters', JSON.stringify(activeFilters));
            }, [activeFilters]);

            const suggestions = useMemo(() => {
                const set = new Set();
                books.forEach(b => {
                    if (['publisher', 'author_name', 'owner', 'building', 'language', 'condition'].includes(pendingField)) {
                        if (b[pendingField]) set.add(b[pendingField]);
                    }
                    if (pendingField === 'tags' && b.tags) b.tags.forEach(t => set.add(t));
                    if (pendingField === 'pub_year' && b.pub_year) set.add(b.pub_year);
                });
                return [...set].sort();
            }, [books, pendingField]);

            const addFilter = () => {
                if (!pendingValue) return;
                setActiveFilters([...activeFilters, { field: pendingField, value: pendingValue }]);
                setPendingValue('');
            };

            const removeFilter = (index) => {
                const next = [...activeFilters];
                next.splice(index, 1);
                setActiveFilters(next);
            };

            const filtered = books.filter(b => {
                if (activeFilters.length === 0) return true;
                return activeFilters.every(f => {
                    if (f.field === 'tags') return b.tags && b.tags.includes(f.value);
                    return b[f.field] == f.value;
                });
            });

            return (
                <div className="flex flex-col min-h-screen">
                    <div className="bg-white p-4 border-b">
                        <h2 className="text-xl font-bold mb-4">Slicer Studio</h2>

                        <div className="flex gap-2 mb-2">
                            <select className="p-2 border rounded bg-gray-50 text-sm font-bold uppercase w-1/3" value={pendingField} onChange={e => setPendingField(e.target.value)}>
                                <option value="publisher">Publisher</option><option value="author_name">Author</option><option value="owner">Owner</option><option value="tags">Tags</option><option value="language">Language</option><option value="building">Location</option><option value="pub_year">Year</option><option value="condition">Condition</option>
                            </select>
                            <AutocompleteInput
                                value={pendingValue}
                                onChange={(e) => setPendingValue(e.target.value)}
                                suggestions={suggestions}
                                placeholder="Select or type value..."
                            />
                            <button onClick={addFilter} className="bg-blue-600 text-white px-4 rounded font-bold">+</button>
                        </div>
                        <div className="flex flex-wrap gap-2 min-h-[30px]">
                            {activeFilters.length === 0 && <span className="text-xs text-gray-400 italic py-1">No active filters. Showing all books.</span>}
                            {activeFilters.map((f, i) => (
                                <span key={i} className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full flex items-center gap-1 border border-blue-200">
                                    <b>{f.field}:</b> {f.value}
                                    <button onClick={() => removeFilter(i)} className="ml-1 text-blue-500 hover:text-red-500 font-bold">√ó</button>
                                </span>
                            ))}
                            {activeFilters.length > 0 && (
                                <button onClick={() => setActiveFilters([])} className="text-xs bg-red-100 text-red-600 px-2 py-1 rounded-full font-bold flex items-center gap-1">
                                    <Icon name="X" size={10} /> Clear All
                                </button>
                            )}
                        </div>
                        <div className="flex justify-between items-center mt-4 pt-2 border-t">
                            <span className="text-xs font-bold text-gray-500">{filtered.length} Results</span>
                            <div className="flex gap-2 items-center">
                                <button onClick={() => setViewMode(viewMode === 'grid' ? 'list' : 'grid')} className="p-2 border rounded text-gray-500 hover:bg-gray-100"><Icon name={viewMode === 'grid' ? 'LayoutList' : 'Grid'} size={16} /></button>
                                <button onClick={() => ExportUtils.csv(filtered, 'Slicer_vew_export')} className="text-xs font-bold text-gray-500 border rounded px-2 py-1 flex gap-1 items-center hover:bg-gray-50"><Icon name="Download" size={12} /> CSV</button>
                                <button onClick={() => ExportUtils.htmlText(filtered, 'mixed', "Filtered Report")} className="text-xs font-bold text-gray-500 border rounded px-2 py-1 flex gap-1 items-center hover:bg-gray-50"><Icon name="FileText" size={12} /> HTML</button>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 pb-24 bg-gray-50">
                        {viewMode === 'grid' ? (
                            <div className="grid grid-cols-2 gap-4">
                                {filtered.map(b => (
                                    <div key={b.id} onClick={() => setDetailBook(b)} className="bg-white p-2 rounded shadow text-center cursor-pointer hover:shadow-md transition-shadow">
                                        {b.thumb || b.front ? <img src={b.thumb || b.front} loading="lazy" className="h-20 mx-auto object-cover mb-2 rounded" alt="" /> : <div className="h-20 bg-gray-100 flex items-center justify-center mb-2 rounded"><Icon name="Book" /></div>}
                                        <div className="font-bold text-xs truncate">{b.title}</div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-2">
                                {filtered.map(b => (
                                    <div key={b.id} onClick={() => setDetailBook(b)} className="bg-white p-3 rounded shadow flex gap-3 items-center cursor-pointer hover:bg-gray-50">
                                        {b.thumb || b.front ? <img src={b.thumb || b.front} loading="lazy" className="w-10 h-14 object-cover rounded" alt="" /> : <div className="w-10 h-14 bg-gray-200 rounded flex items-center justify-center"><Icon name="Book" size={16} /></div>}
                                        <div className="flex-1 min-w-0">
                                            <div className="font-bold text-sm truncate">{b.title}</div>
                                            <div className="text-xs text-gray-500 truncate">{b.author_name || b.author} ‚Ä¢ {b.publisher}</div>
                                        </div>
                                        <div className="text-xs font-bold text-gray-400">{b.pub_year}</div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                    {detailBook && <DetailModal book={detailBook} onClose={() => setDetailBook(null)} onEdit={(b) => { onEdit(b); setDetailBook(null) }} />}
                </div>
            );
        };

        // --- LIBRARY & DETAIL ---
        const LibraryView = ({ books, onEdit, onDeleteMulti }) => {
            const [sort, setSort] = useState({ p: 'date_added', s: 'title', dir: 'desc' });
            const [detailBook, setDetailBook] = useState(null);
            const [selectMode, setSelectMode] = useState(false);
            const [selected, setSelected] = useState([]);
            const [viewMode, setViewMode] = useState('grid');
            const [search, setSearch] = useState(() => {
                try {
                    const saved = sessionStorage.getItem('shelfLife_libraryFilters');
                    return saved ? JSON.parse(saved) : { tags: [], query: '', showDupes: false };
                } catch { return { tags: [], query: '', showDupes: false }; }
            });
            const [showBulkEdit, setShowBulkEdit] = useState(false);

            // Persist search filters to sessionStorage
            useEffect(() => {
                sessionStorage.setItem('shelfLife_libraryFilters', JSON.stringify(search));
            }, [search]);

            const suggestions = useMemo(() => {
                const s = new Set();
                books.forEach(b => {
                    if (b.title) s.add(b.title);
                    if (b.phonetic) s.add(b.phonetic);
                    if (b.author_name || b.author) s.add(b.author_name || b.author);
                    if (b.publisher) s.add(b.publisher);
                    if (b.owner) s.add(b.owner);
                    if (b.tags) b.tags.forEach(t => s.add(t));
                });
                // DynamicSearchInput handles filtering (max 20 shown)
                return [...s].sort();
            }, [books]);

            const sorted = useMemo(() => {
                const res = books.filter(b => {
                    // DUPLICATE FILTER
                    if (search.showDupes && !(b.tags || []).includes('duplicate')) return false;

                    // TEXT SEARCH
                    if (search.query) {
                        const q = search.query.toLowerCase();
                        const match = (b.title || '').toLowerCase().includes(q) ||
                            (b.phonetic || '').toLowerCase().includes(q) ||
                            (b.author || '').toLowerCase().includes(q) ||
                            (b.author_name || '').toLowerCase().includes(q) ||
                            (b.isbn || '').toLowerCase().includes(q) ||
                            (b.tags || []).some(t => t.toLowerCase().includes(q)) ||
                            (b.owner || '').toLowerCase().includes(q) ||
                            (b.building || '').toLowerCase().includes(q) ||
                            (b.shelf || '').toLowerCase().includes(q) ||
                            (b.pub_year || '').toString().includes(q) ||
                            (b.publisher || '').toLowerCase().includes(q);
                        if (!match) return false;
                    }
                    // TAG FILTER
                    if (search.tags && search.tags.length > 0) {
                        const bTags = b.tags || [];
                        if (!search.tags.every(t => bTags.includes(t))) return false;
                    }
                    return true;
                });
                return res.sort((a, b) => {
                    const vA = a[sort.p] || '', vB = b[sort.p] || '';
                    if (vA < vB) return sort.dir === 'asc' ? -1 : 1; if (vA > vB) return sort.dir === 'asc' ? 1 : -1;
                    return (a[sort.s] || '').localeCompare(b[sort.s] || '');
                });
            }, [books, sort, search]);

            const toggleSelect = (id) => {
                setSelected(prev => prev.includes(id) ? prev.filter(i => i !== id) : [...prev, id]);
            };

            const handleCardClick = (b) => {
                if (selectMode) toggleSelect(b.id); else setDetailBook(b);
            };

            const handleMultiDelete = () => { onDeleteMulti(selected); setSelected([]); setSelectMode(false); };

            return (
                <div className="pb-24">
                    <div className="bg-white p-4 sticky top-0 z-10 shadow-sm flex flex-col gap-2">
                        <div className="flex justify-between items-center flex-wrap gap-2">
                            <h2 className="text-xl font-bold">Library</h2>
                            <div className="flex gap-2 items-center flex-wrap">
                                <button onClick={() => setViewMode(viewMode === 'grid' ? 'list' : 'grid')} className="p-2 border rounded text-gray-500 hover:bg-gray-100"><Icon name={viewMode === 'grid' ? 'LayoutList' : 'Grid'} size={16} /></button>

                                {selectMode ? (
                                    <>
                                        <button onClick={() => setSelected(sorted.map(b => b.id))} className="text-xs border rounded px-2 py-1 bg-gray-50">All</button>
                                        <button onClick={() => setSelected([])} className="text-xs border rounded px-2 py-1 bg-gray-50">None</button>
                                        {selected.length > 0 && (
                                            <button onClick={() => setShowBulkEdit(true)} className="text-xs bg-blue-100 text-blue-600 px-3 py-1 rounded font-bold flex items-center gap-1">
                                                <Icon name="Edit3" size={12} /> Edit ({selected.length})
                                            </button>
                                        )}
                                        <button onClick={handleMultiDelete} className="text-xs bg-red-100 text-red-600 px-3 py-1 rounded font-bold">Delete ({selected.length})</button>
                                    </>
                                ) : (
                                    <>
                                        <button
                                            onClick={() => setSearch(s => ({ ...s, showDupes: !s.showDupes }))}
                                            className={`text-[10px] px-2 py-1 rounded border font-bold ${search.showDupes ? 'bg-red-50 text-red-600 border-red-200' : 'bg-white text-gray-500'}`}
                                        >
                                            {search.showDupes ? 'Dupes Only' : 'Show Dupes'}
                                        </button>
                                        <select className="text-xs border rounded p-1" onChange={e => setSort({ ...sort, p: e.target.value })}>
                                            <option value="date_added">Recent</option><option value="title">Title</option><option value="author">Author</option><option value="year">Year</option>
                                        </select>
                                    </>
                                )}
                                <button onClick={() => ExportUtils.csv(sorted, 'Lib_vew_export')} className="p-2 border rounded text-gray-500 hover:bg-gray-100" title="Export CSV"><Icon name="Download" size={16} /></button>
                                <button onClick={() => { setSelectMode(!selectMode); setSelected([]) }} className={`text-xs border rounded p-1 ${selectMode ? 'bg-blue-600 text-white' : 'text-gray-500'}`}>{selectMode ? 'Done' : 'Select'}</button>
                            </div>
                        </div>
                        <MultiTagInput
                            options={[...new Set(books.flatMap(b => b.tags || []))].sort()}
                            value={search.tags}
                            onChange={tags => setSearch({ ...search, tags })}
                            placeholder="Filter by tags..."
                        />
                        <div className="mt-2 text-xs flex gap-2">
                            <DynamicSearchInput
                                value={search.query}
                                onChange={e => setSearch({ ...search, query: e.target.value })}
                                suggestions={suggestions}
                                placeholder="Search Title, Author, ISBN..."
                                icon="Search"
                            />
                            {(search.query || search.tags.length > 0 || search.showDupes) && (
                                <button
                                    onClick={() => setSearch({ tags: [], query: '', showDupes: false })}
                                    className="text-xs bg-red-100 text-red-600 px-2 py-1 rounded font-bold flex items-center gap-1"
                                >
                                    <Icon name="X" size={12} /> Clear
                                </button>
                            )}
                        </div>
                    </div>

                    <div className="p-4">
                        {/* Limit results to prevent keyboard overlap while typing */}
                        {search.query && sorted.length > 6 && (
                            <div className="text-xs text-center text-gray-500 mb-2 bg-blue-50 py-1 rounded">
                                Showing 6 of {sorted.length} results. Clear search to see all.
                            </div>
                        )}
                        {viewMode === 'grid' ? (
                            <div className="grid grid-cols-2 gap-4">
                                {(search.query ? sorted.slice(0, 6) : sorted).map(b => (
                                    <div key={b.id} onClick={() => handleCardClick(b)} className={`bg-white p-3 rounded-xl shadow-sm border relative cursor-pointer ${selected.includes(b.id) ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-100'}`}>
                                        {selectMode && <div className={`absolute top-2 right-2 w-5 h-5 rounded-full border-2 ${selected.includes(b.id) ? 'bg-blue-500 border-blue-500' : 'border-gray-300'} flex items-center justify-center`}>{selected.includes(b.id) && <Icon name="CheckSquare" className="text-white" size={12} />}</div>}
                                        <div className="w-full h-40 bg-gray-100 rounded-lg overflow-hidden mb-2">
                                            {b.front ? <img src={b.front} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-300"><Icon name="Book" size={32} /></div>}
                                        </div>
                                        <h3 className="font-bold leading-tight text-sm line-clamp-2">{b.title}</h3>
                                        <p className="text-xs text-gray-500 truncate">{b.author_name || b.author}</p>
                                        <div className="absolute top-2 left-2 bg-black/50 text-white text-[10px] px-2 rounded">{b.currency || ''} {b.price}</div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-2">
                                {(search.query ? sorted.slice(0, 6) : sorted).map(b => (
                                    <div key={b.id} onClick={() => handleCardClick(b)} className={`bg-white p-3 rounded-xl shadow-sm border flex gap-3 items-center relative cursor-pointer ${selected.includes(b.id) ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-100'}`}>
                                        {selectMode && <div className={`absolute top-2 right-2 w-5 h-5 rounded-full border-2 ${selected.includes(b.id) ? 'bg-blue-500 border-blue-500' : 'border-gray-300'} flex items-center justify-center`}>{selected.includes(b.id) && <Icon name="CheckSquare" className="text-white" size={12} />}</div>}
                                        {b.front ? <img src={b.front} className="w-12 h-16 object-cover rounded" /> : <div className="w-12 h-16 bg-gray-200 rounded flex items-center justify-center"><Icon name="Book" size={16} /></div>}
                                        <div className="flex-1 min-w-0">
                                            <h3 className="font-bold text-sm truncate">{b.title}</h3>
                                            <p className="text-xs text-gray-500 truncate">{b.author_name || b.author}</p>
                                            <div className="text-[10px] text-gray-400">{b.publisher} ‚Ä¢ {b.pub_year}</div>
                                        </div>
                                        <div className="font-bold text-sm">{b.currency || ''} {b.price}</div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* DETAIL MODAL (READ ONLY + GALLERY + ZOOM) */}
                    {detailBook && (
                        <DetailModal book={detailBook} onClose={() => setDetailBook(null)} onEdit={(b) => { onEdit(b); setDetailBook(null) }} />
                    )}

                    {/* BULK EDIT MODAL */}
                    {showBulkEdit && (
                        <BulkEditModal
                            selectedIds={selected}
                            books={books}
                            onClose={() => setShowBulkEdit(false)}
                            onApply={() => { setShowBulkEdit(false); setSelected([]); setSelectMode(false); }}
                        />
                    )}
                </div>
            );
        };

        // --- DETAIL MODAL WITH ZOOM ---
        const DetailModal = ({ book, onClose, onEdit }) => {
            const [zoomImg, setZoomImg] = useState(null);
            const [scale, setScale] = useState(1);
            const [pinchDistance, setPinchDistance] = useState(null);
            const [pinchScale, setPinchScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

            // Sanitize filename helper
            const sanitizeFilename = (name) => {
                return name
                    .replace(/[/\\:*?"<>|]/g, '_')
                    .substring(0, 50)
                    .trim() || 'Untitled';
            };

            const handleSaveImage = async (imgSrc) => {
                try {
                    if (isNativeCapacitor()) {
                        const { Filesystem } = window.Capacitor.Plugins;
                        const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                        const targetDir = Directory[baseStr] || Directory.Documents;
                        const base64Data = imgSrc.split(',')[1] || imgSrc;

                        // Save to ShelfLife/IMAGES
                        const imagesPath = 'ShelfLife/IMAGES';
                        try {
                            await Filesystem.mkdir({
                                path: imagesPath,
                                directory: targetDir,
                                recursive: true
                            });
                        } catch (mkdirErr) {
                            // Folder might already exist, ignore error
                        }

                        // Generate filename: BookTitle_Date.jpg
                        const date = new Date().toISOString().slice(0, 10);
                        const safeName = sanitizeFilename(book.title);
                        const fname = `${safeName}_${date}.jpg`;

                        try {
                            await Filesystem.writeFile({
                                path: `${imagesPath}/${fname}`,
                                data: base64Data,
                                directory: targetDir
                            });
                            alert(`‚úÖ Saved to Images/${fname}`);
                        } catch (saveErr) {
                            // Fallback: save to root folder
                            const fallbackName = `BookImage_${Date.now()}.jpg`;
                            await Filesystem.writeFile({
                                path: `ShelfLife/${fallbackName}`,
                                data: base64Data,
                                directory: targetDir
                            });
                            alert(`‚ö†Ô∏è Saved to root as ${fallbackName}`);
                        }
                    } else {
                        // Web fallback: download link
                        const a = document.createElement('a');
                        a.href = imgSrc;
                        const safeName = sanitizeFilename(book.title);
                        a.download = `${safeName}_${Date.now()}.jpg`;
                        a.click();
                    }
                } catch (e) {
                    alert("‚ùå Save failed: " + e.message);
                }
            };

            // Pinch zoom handlers with pan support
            const handleTouchStart = (e) => {
                // Prevent pull-to-refresh when zoomed
                if (scale > 1) {
                    e.preventDefault();
                }

                if (e.touches.length === 1 && scale > 1) {
                    // Single finger drag (only when zoomed)
                    setIsDragging(true);
                    setDragStart({
                        x: e.touches[0].pageX - position.x,
                        y: e.touches[0].pageY - position.y
                    });
                } else if (e.touches.length === 2) {
                    // Pinch zoom - always prevent default
                    e.preventDefault();
                    setIsDragging(false);
                    const distance = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    setPinchDistance(distance);
                    setPinchScale(scale);
                }
            };

            const handleTouchMove = (e) => {
                if (isDragging && e.touches.length === 1) {
                    // Pan/drag image
                    e.preventDefault();
                    setPosition({
                        x: e.touches[0].pageX - dragStart.x,
                        y: e.touches[0].pageY - dragStart.y
                    });
                } else if (e.touches.length === 2 && pinchDistance) {
                    // Pinch zoom
                    e.preventDefault();
                    const distance = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    const ratio = distance / pinchDistance;
                    const newScale = Math.min(Math.max(pinchScale * ratio, 0.5), 4);
                    setScale(newScale);
                }
            };

            const handleTouchEnd = () => {
                setIsDragging(false);
                setPinchDistance(null);
            };

            // Reset scale and position when image changes
            useEffect(() => {
                if (zoomImg) {
                    setScale(1);
                    setPosition({ x: 0, y: 0 });
                    setPinchDistance(null);
                }
            }, [zoomImg]);

            // Copy book details to clipboard
            const copyBookDetails = () => {
                const dateAdded = book.date_added ? new Date(book.date_added).toLocaleDateString() : 'Unknown';
                const text = `üìö ${book.title}${book.phonetic && book.phonetic !== book.title ? ` (${book.phonetic})` : ''}
                                ‚úçÔ∏è ${book.author_name || book.author || 'Unknown'}${book.author_initials ? ` (${book.author_initials})` : ''}
                                üìñ ISBN: ${book.isbn || 'N/A'}
                                üìÖ Published: ${book.pub_year || '?'} by ${book.publisher || 'Unknown'}
                                üåê Language: ${book.language || book.lang || 'EN'}
                                üìÑ Pages: ${book.page_count || 'N/A'}
                                üìç Location: ${book.building || '?'} / ${book.shelf || '?'}
                                üë§ Owner: ${book.owner || 'N/A'}
                                üìã Condition: ${book.condition || 'Good'} | ${book.status === 'avail' ? 'Available' : 'Lent'}
                                üí∞ Value: ${book.currency || ''} ${book.price || 'N/A'}
                                üè∑Ô∏è Tags: ${(book.tags || []).join(', ') || 'None'}
                                üìÖ Added: ${dateAdded}
                                
                                üìù Description:
                                ${book.description || 'No description.'}
                                
                                üóíÔ∏è Notes:
                                ${book.notes || 'No notes.'}

                                Exported from ShelfLife`;
                navigator.clipboard.writeText(text).then(() => {
                    alert('‚úÖ Copied to clipboard!');
                }).catch(() => {
                    alert('‚ùå Copy failed');
                });
            };

            return (
                <div className="fixed inset-0 bg-black/80 z-50 flex items-end sm:items-center justify-center p-4 modal-overlay">
                    {zoomImg && (
                        <div className="fixed inset-0 z-[60] bg-black flex flex-col items-center justify-center modal-overlay" style={{ overscrollBehavior: 'none' }}>
                            <div
                                className="flex-1 w-full overflow-hidden flex items-center justify-center"
                                style={{ touchAction: 'none', overscrollBehavior: 'none' }}
                                onTouchStart={handleTouchStart}
                                onTouchMove={handleTouchMove}
                                onTouchEnd={handleTouchEnd}
                            >
                                <img
                                    src={zoomImg}
                                    className="max-w-none object-contain"
                                    style={{
                                        transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,
                                        transformOrigin: 'center',
                                        maxHeight: '85vh'
                                    }}
                                    onDoubleClick={() => { setScale(s => s > 1 ? 1 : 2); setPosition({ x: 0, y: 0 }); }}
                                />
                            </div>
                            <div className="absolute bottom-6 flex gap-4">
                                <button onClick={() => setScale(s => Math.min(s + 0.5, 4))} className="text-white p-3 bg-white/20 rounded-full">
                                    <Icon name="Plus" size={24} />
                                </button>
                                <button onClick={() => setScale(s => Math.max(s - 0.5, 0.5))} className="text-white p-3 bg-white/20 rounded-full">
                                    <Icon name="Minus" size={24} />
                                </button>
                                <button onClick={() => handleSaveImage(zoomImg)} className="text-white p-3 bg-green-600 rounded-full">
                                    <Icon name="Download" size={24} />
                                </button>
                            </div>
                            <button onClick={() => { setZoomImg(null); setScale(1); setPosition({ x: 0, y: 0 }); }} className="absolute top-4 right-4 text-white p-2 bg-black/50 rounded-full">
                                <Icon name="X" size={32} />
                            </button>
                        </div>
                    )}

                    <div className="bg-white w-full max-w-md rounded-2xl overflow-hidden max-h-[90vh] overflow-y-auto modal-content">
                        <div className="relative h-64 bg-gray-100 overflow-x-auto whitespace-nowrap flex">
                            {/* Gallery View */}
                            {book.front && <img src={book.front} onClick={() => setZoomImg(book.front)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />}
                            {book.rear && <img src={book.rear} onClick={() => setZoomImg(book.rear)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />}
                            {(book.pages || []).map((p, i) => <img key={i} src={p} onClick={() => setZoomImg(p)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />)}
                            <button onClick={onClose} className="absolute top-4 right-4 bg-white/50 p-2 rounded-full"><Icon name="X" /></button>
                        </div>
                        <div className="p-4">
                            {/* Header with title and copy button */}
                            <div className="flex justify-between items-start mb-4">
                                <div className="flex-1">
                                    <h1 className="text-xl font-bold">{book.title}</h1>
                                    {book.phonetic && book.phonetic !== book.title && <p className="text-gray-500 text-sm italic">{book.phonetic}</p>}
                                    <p className="text-gray-600">{book.author_name || book.author} {book.author_initials && `(${book.author_initials})`}</p>
                                </div>
                                <button onClick={copyBookDetails} className="p-2 bg-blue-100 rounded-lg hover:bg-blue-200" title="Copy details">
                                    <Icon name="Copy" size={18} />
                                </button>
                            </div>

                            {/* Compact table with ALL fields */}
                            <div className="grid grid-cols-[auto_1fr] gap-x-3 gap-y-2 text-sm mb-4 bg-gray-50 p-3 rounded-lg">
                                <span className="text-gray-500">ISBN:</span>
                                <span className="font-medium">{book.isbn || '-'}</span>

                                <span className="text-gray-500">Publisher:</span>
                                <span className="font-medium">{book.publisher || '-'}</span>

                                <span className="text-gray-500">Year:</span>
                                <span className="font-medium">{book.pub_year || '-'}</span>

                                <span className="text-gray-500">Language:</span>
                                <span className="font-medium">{book.language || book.lang?.toUpperCase() || 'EN'}</span>

                                <span className="text-gray-500">Pages:</span>
                                <span className="font-medium">{book.page_count || '-'}</span>

                                <span className="text-gray-500">Building:</span>
                                <span className="font-medium">{book.building || '-'}</span>

                                <span className="text-gray-500">Shelf:</span>
                                <span className="font-medium">{book.shelf || '-'}</span>

                                <span className="text-gray-500">Owner:</span>
                                <span className="font-medium">{book.owner || '-'}</span>

                                <span className="text-gray-500">Condition:</span>
                                <span className="font-medium">{book.condition || 'Good'}</span>

                                <span className="text-gray-500">Status:</span>
                                <span className={`font-medium ${book.status === 'avail' ? 'text-green-600' : 'text-orange-600'}`}>
                                    {book.status === 'avail' ? '‚úì Available' : '‚óà Lent Out'}
                                </span>

                                <span className="text-gray-500">Price:</span>
                                <span className="font-medium">{book.currency || ''} {book.price || '-'}</span>
                            </div>

                            {/* Tags section */}
                            {(book.tags || []).length > 0 && (
                                <div className="mb-4">
                                    <span className="text-gray-500 text-xs uppercase font-bold block mb-1">Tags</span>
                                    <div className="flex flex-wrap gap-1">
                                        {book.tags.map((tag, i) => (
                                            <span key={i} className="px-2 py-0.5 bg-blue-100 text-blue-800 rounded text-xs">{tag}</span>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <button onClick={() => onEdit(book)} className="w-full py-3 bg-blue-600 text-white font-bold rounded-xl flex items-center justify-center gap-2">
                                <Icon name="Edit3" /> Edit / Update
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD ---
        const Dashboard = ({ books, onNavigateToSlicer }) => {
            const total = books.length;
            // Group by currency
            const assetBreakdown = useMemo(() => {
                const groups = {};
                books.forEach(b => {
                    const curr = b.currency || '?';
                    groups[curr] = (groups[curr] || 0) + (Number(b.price) || 0);
                });
                return groups;
            }, [books]);

            const pubStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.publisher || 'Unknown'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 25);
            }, [books]);

            // NEW: Lang/Loc Stats for Dash
            const langStats = useMemo(() => {
                const c = {}; books.forEach(b => { c[b.lang || 'en'] = (c[b.lang || 'en'] || 0) + 1 });
                const total = books.length || 1; let current = 0;
                const colors = { en: '#3b82f6', ml: '#10b981', ar: '#f59e0b', hi: '#ef4444' };
                return Object.entries(c).map(([l, v]) => {
                    const pct = (v / total) * 100; const str = `${colors[l] || '#ccc'} ${current}% ${current + pct}%`; current += pct; return str;
                }).join(', ');
            }, [books]);

            const locStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.building || 'Unknown'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 25);
            }, [books]);

            const tagStats = useMemo(() => {
                const c = {}; books.forEach(b => { if (b.tags) b.tags.forEach(t => c[t] = (c[t] || 0) + 1) });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 25);
            }, [books]);

            const condStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.condition || 'Good'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]);
            }, [books]);

            const ownerStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.owner || 'Unassigned'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);
            }, [books]);

            const repairList = books.filter(b => b.condition === 'Torn' || b.condition === 'Loose' || (b.tags && b.tags.includes('repair')));

            return (
                <div className="p-4 space-y-6 pb-24">
                    <h2 className="text-2xl font-bold">Analytics</h2>
                    <div className="grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow border border-blue-100"><p className="text-xs text-gray-500 font-bold uppercase">Total Books</p><p className="text-3xl font-bold text-blue-600">{total}</p></div>
                        <div className="bg-white p-4 rounded-xl shadow border border-green-100"><p className="text-xs text-gray-500 font-bold uppercase">Asset Value</p>
                            {Object.entries(assetBreakdown).map(([curr, val]) => (
                                <div key={curr} className="text-lg font-bold text-green-600">{curr} {val.toLocaleString()}</div>
                            ))}
                            {Object.keys(assetBreakdown).length === 0 && <p className="text-xl font-bold text-gray-400">0</p>}
                        </div>
                    </div>

                    {repairList.length > 0 && <div className="bg-red-50 p-4 rounded-xl border border-red-200 text-red-800 font-bold flex items-center gap-2"><Icon name="AlertCircle" /> {repairList.length} Books Need Repair</div>}

                    <div className="bg-white p-4 rounded-xl shadow border flex gap-4">
                        <div className="pie-chart flex-shrink-0" style={{ '--pie-gradient': langStats }}></div>
                        <div><h3 className="font-bold mb-2">Language Mix</h3><div className="text-xs text-gray-500">Visual breakdown of your library languages.</div></div>
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Top Publishers</h3>
                        {pubStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('publisher', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-purple-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Locations</h3>
                        {locStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('building', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-blue-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Top Tags</h3>
                        {tagStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('tags', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-green-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">By Owner</h3>
                        {ownerStats.length === 0 && <p className="text-gray-400 text-sm">No owners assigned</p>}
                        {ownerStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('owner', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-orange-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Condition</h3>
                        {condStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('condition', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-red-400" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- TOOLS ---
        const Tools = ({ books }) => {
            const [lastRestore, setLastRestore] = useState(null);
            const [showWhatsNew, setShowWhatsNew] = useState(false);
            const [showReports, setShowReports] = useState(false);
            const [showTagManager, setShowTagManager] = useState(false);
            const [showHelp, setShowHelp] = useState(false);
            const [showFindReplace, setShowFindReplace] = useState(false);
            const [showCSVImport, setShowCSVImport] = useState(false);
            // Find & Replace state
            const [frField, setFrField] = useState('owner');
            const [frFind, setFrFind] = useState('');
            const [frReplace, setFrReplace] = useState('');
            const [frCaseSensitive, setFrCaseSensitive] = useState(false);
            const [frExactMatch, setFrExactMatch] = useState(true);
            const [frPreview, setFrPreview] = useState([]);
            const [frApplied, setFrApplied] = useState(false);
            // CSV Import state
            const [csvFile, setCsvFile] = useState(null);
            const [csvData, setCsvData] = useState([]);
            const [csvPreview, setCsvPreview] = useState({ total: 0, matched: 0, unmatched: 0 });
            const [csvProcessing, setCsvProcessing] = useState(false);
            const [csvDone, setCsvDone] = useState(false);
            const [imageExportStatus, setImageExportStatus] = useState({ exporting: false, current: 0, total: 0, message: '' });
            const APP_VERSION = '2.9.0';
            const BUILD_DATE = '2026-02-16 19:45';
            const COMMIT_HASH = 'a184546';

            useEffect(() => {
                try {
                    const stored = localStorage.getItem('shelfLife_restore_meta');
                    if (stored) setLastRestore(JSON.parse(stored));
                } catch (e) {
                    console.error("Failed to parse restore meta:", e);
                    setLastRestore(null);
                }
            }, []);

            // Consolidated Chunked Backup Helper
            const performChunkedBackup = async (textOnly = false) => {
                try {
                    const allBooks = await db.books.toArray();
                    const now = new Date();
                    const ts = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0') + '_' + String(now.getHours()).padStart(2, '0') + '-' + String(now.getMinutes()).padStart(2, '0') + '-' + String(now.getSeconds()).padStart(2, '0');
                    const typePrefix = textOnly ? 'TXT_BK' : 'FULL_BK';
                    const deviceName = localStorage.getItem('shelfLife_deviceName') || 'Desktop';

                    // Prepare books
                    const processedBooks = textOnly
                        ? allBooks.map(b => ({ ...b, front: null, rear: null, thumb: null, pages: [] }))
                        : allBooks;

                    // Create signature
                    const signature = {
                        __shelflife_signature__: {
                            version: '2.0',
                            created: now.toISOString(),
                            device_nickname: deviceName,
                            device_model: 'Desktop',
                            device_platform: 'windows',
                            type: typePrefix,
                            book_count: allBooks.length
                        }
                    };

                    const backupData = [signature, ...processedBooks];
                    const filename = `SL_${typePrefix}_${deviceName}_${ts}.json`;
                    const jsonStr = JSON.stringify(backupData);

                    if (isTauri()) {
                        // Tauri: Save As dialog
                        try {
                            const { save } = window.__TAURI__.dialog;
                            const { writeTextFile } = window.__TAURI__.fs;
                            const filePath = await save({
                                defaultPath: filename,
                                filters: [{ name: 'JSON', extensions: ['json'] }]
                            });
                            if (filePath) {
                                await writeTextFile(filePath, jsonStr);
                                alert(`‚úÖ Backup (${textOnly ? 'Text Only' : 'Full'}) Complete!\n\nüìö ${allBooks.length} books\nüìÇ Saved to: ${filePath}`);
                            }
                        } catch (tauriErr) {
                            console.error('Tauri save failed:', tauriErr);
                            // Fall through to browser download
                            const blob = new Blob([jsonStr], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url; a.download = filename;
                            document.body.appendChild(a); a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            alert(`‚úÖ Backup (${textOnly ? 'Text Only' : 'Full'}) Complete!\n\nüìö ${allBooks.length} books\nüìÇ Downloaded: ${filename}`);
                        }
                    } else if (isNativeCapacitor()) {
                        // Capacitor: Chunked backup to native filesystem
                        const { Filesystem, Device } = window.Capacitor.Plugins;
                        const folder = 'ShelfLife/Backups';
                        const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                        const targetDir = Directory[baseStr] || Directory.Documents;
                        try { await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true }); } catch (e) { }

                        let deviceInfo = { model: 'Unknown', platform: 'unknown' };
                        try {
                            if (Device) {
                                const info = await Device.getInfo();
                                deviceInfo = { model: info.model || 'Unknown', platform: info.platform || 'unknown', manufacturer: info.manufacturer || '' };
                            }
                        } catch (e) { }
                        signature.__shelflife_signature__.device_model = deviceInfo.model;
                        signature.__shelflife_signature__.device_platform = deviceInfo.platform;
                        signature.__shelflife_signature__.device_manufacturer = deviceInfo.manufacturer;

                        const TARGET_SIZE = 9 * 1024 * 1024;
                        let part = 1;
                        let currentChunk = [signature];
                        let currentSize = JSON.stringify(signature).length;

                        for (const rawBook of allBooks) {
                            const book = textOnly ? { ...rawBook, front: null, rear: null, thumb: null, pages: [] } : rawBook;
                            const s = JSON.stringify(book);
                            if (currentSize + s.length > TARGET_SIZE && currentChunk.length > 0) {
                                const fname = `SL_${typePrefix}_${deviceName}_Part${part}_${ts}.json`;
                                await Filesystem.writeFile({ path: `${folder}/${fname}`, data: JSON.stringify(currentChunk), directory: targetDir, encoding: Encoding.UTF8 });
                                part++;
                                currentChunk = [];
                                currentSize = 0;
                            }
                            currentChunk.push(book);
                            currentSize += s.length;
                        }
                        if (currentChunk.length > 0) {
                            const fname = `SL_${typePrefix}_${deviceName}_Part${part}_${ts}.json`;
                            await Filesystem.writeFile({ path: `${folder}/${fname}`, data: JSON.stringify(currentChunk), directory: targetDir, encoding: Encoding.UTF8 });
                        }
                        alert(`Backup (${textOnly ? 'Text Only' : 'Full'}) Complete!\nSaved ${part} file(s) to:\n${baseStr}/${folder}/\n\nDevice: ${deviceName}\nModel: ${deviceInfo.model}`);
                    } else {
                        // Browser fallback: Download
                        const blob = new Blob([jsonStr], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url; a.download = filename;
                        document.body.appendChild(a); a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        alert(`‚úÖ Backup (${textOnly ? 'Text Only' : 'Full'}) Complete!\n\nüìö ${allBooks.length} books\nüìÇ Downloaded: ${filename}`);
                    }

                    // Track backup for reminder system
                    localStorage.setItem('shelfLife_lastBackupDate', new Date().toISOString());
                    localStorage.setItem('shelfLife_entriesSinceBackup', '0');
                } catch (e) {
                    alert("Backup Error: " + e.message);
                }
            };

            // Native Restore Helper (REVERTED TO MANUAL SCAN to prevent FilePicker Crashes)
            const performNativeRestore = async () => {
                if (!isNativeCapacitor()) { alert("Restore requires Android App (Native Filesystem)."); return; }
                try {
                    const { Filesystem } = window.Capacitor.Plugins;

                    // Force Manual/Default Folder Logic (Safer)
                    const folder = localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups';
                    const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                    const targetDir = Directory[baseStr] || Directory.Documents;

                    let folderInput = folder;
                    // Optional: Ask user to confirm folder if they want to change it
                    // folderInput = prompt("Confirm Backup Folder to Scan:", folder);
                    if (!folderInput) return;

                    // Read the folder
                    const ret = await Filesystem.readdir({
                        path: folderInput,
                        directory: targetDir
                    }).catch(e => {
                        // If default fails, maybe try the root Documents?
                        // But for now, just return empty to show "No backups"
                        return { files: [] };
                    });

                    // Parse Backup Files
                    const groups = {};
                    (ret.files || []).forEach(f => {
                        // ... (rest of parsing logic remains same)
                        const name = f.name;
                        let ts = null;
                        // NEW format: SL_FULL_BK_DEVICE_Part1_TIMESTAMP.json or SL_TXT_BK_...
                        const mNew2 = name.match(/SL_(?:FULL_BK|TXT_BK)_(.+)_Part\d+_(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}(?:-\d{2})?)\.json/);
                        // OLD format: SL_BK_DEVICE_Part1_TIMESTAMP.json
                        const mNew = name.match(/SL_BK_(.+)_Part\d+(?:_TextOnly)?_(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})\.json/);
                        if (mNew2) {
                            ts = `${mNew2[1]} (${mNew2[2]})`;
                        } else if (mNew) {
                            ts = `${mNew[1]} (${mNew[2]})`;
                        } else {
                            const mold = name.match(/ShelfLife_Part\d+(?:_TextOnly)?_(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})\.json/);
                            if (mold) ts = `UnknownDevice (${mold[1]})`;
                        }

                        if (ts) {
                            if (!groups[ts]) groups[ts] = 0;
                            groups[ts]++;
                        }
                    });

                    const choices = Object.keys(groups).sort().reverse();
                    if (choices.length === 0) {
                        // DEBUG: Show what files were actually found
                        const fileList = (ret.files || []).map(f => f.name).slice(0, 10);
                        const debugInfo = fileList.length > 0
                            ? `\n\nFiles found (first 10):\n${fileList.join('\n')}`
                            : '\n\n(Folder appears empty or unreadable)';
                        alert(`No backups found in ${baseStr}/${folderInput}.${debugInfo}\n\nExpected format:\nSL_BK_DEVICE_Part1_YYYY-MM-DD_HH-MM-SS.json`);
                        return;
                    }

                    // ... (Rest of selection and restore logic)
                    const selection = prompt(`Found ${choices.length} Backup Sets:\n` + choices.map((c, i) => `${i + 1}. ${c} \n   [${groups[c]} files]`).join('\n') + "\n\nEnter number to restore:");
                    if (!selection) return;
                    const index = parseInt(selection) - 1;
                    if (isNaN(index) || index < 0 || index >= choices.length) return;

                    const targetSet = choices[index];

                    const modeInput = prompt(`Selected: ${targetSet}\n\nChoose Restore Mode:\n[1] REPLACE (Wipe & Import)\n[2] APPEND (Add New, Skip Duplicates)\n[3] MERGE (Add All, Mark Duplicates)\n\nEnter 1, 2, or 3:`, "1");

                    if (!modeInput || !['1', '2', '3'].includes(modeInput)) return;
                    const modeMap = { '1': 'Replace', '2': 'Append', '3': 'Merge' };
                    const mode = modeMap[modeInput];

                    if (mode === 'Replace' && !confirm("WARNING: REPLACE mode will PERMANENTLY DELETE your current library.\nAre you sure?")) return;

                    if (mode === 'Replace') await db.books.clear();
                    const existingBooks = (mode !== 'Replace') ? await db.books.toArray() : [];

                    const isDuplicate = (newB, existB) => {
                        return existB.some(b =>
                            (b.title || '').toLowerCase().trim() === (newB.title || '').toLowerCase().trim() &&
                            (b.author_name || b.author || '').toLowerCase().trim() === (newB.author_name || newB.author || '').toLowerCase().trim() &&
                            (b.language || 'en') === (newB.language || 'en') &&
                            (b.building || '').toLowerCase().trim() === (newB.building || '').toLowerCase().trim()
                        );
                    };

                    const isLegacy = targetSet.startsWith("UnknownDevice");
                    // Match timestamp with or without seconds
                    const datePart = targetSet.match(/\d{4}-\d{2}-\d{2}_\d{2}-\d{2}(?:-\d{2})?/)[0];
                    const fileList = (ret.files || []).filter(f => f.name.includes(datePart)).sort();

                    let stats = { total: 0, added: 0, duplicates: 0, skipped: 0 };

                    for (const f of fileList) {
                        const c = await Filesystem.readFile({
                            path: `${folderInput}/${f.name}`,
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        const chunkData = JSON.parse(c.data);
                        stats.total += chunkData.length;

                        const toAdd = [];
                        for (let book of chunkData) {
                            if (book.author && !book.author_name) {
                                const parts = book.author.trim().split(' ');
                                let name = parts.pop() || '';
                                let initials = parts.join(' ') || '';
                                if (!initials && !name) name = book.author;
                                book.author_name = name;
                                book.author_initials = initials;
                                delete book.author;
                            }

                            if (mode === 'Replace') {
                                toAdd.push(book);
                                stats.added++;
                            } else {
                                const dup = isDuplicate(book, existingBooks);
                                if (dup) {
                                    stats.duplicates++;
                                    if (mode === 'Merge') {
                                        book.tags = [...(book.tags || []), 'duplicate'];
                                        toAdd.push(book);
                                        stats.added++;
                                    } else {
                                        stats.skipped++;
                                    }
                                } else {
                                    toAdd.push(book);
                                    stats.added++;
                                }
                            }
                        }

                        if (toAdd.length > 0) {
                            await db.books.bulkAdd(toAdd);
                            if (mode !== 'Replace') existingBooks.push(...toAdd);
                        }
                    }

                    const logEntry = {
                        id: 'log_' + Date.now(),
                        timestamp: new Date().toISOString(),
                        source: targetSet,
                        mode: mode,
                        total: stats.total,
                        added: stats.added,
                        duplicates: stats.duplicates,
                        skipped: stats.skipped,
                        status: 'Success'
                    };
                    const logs = JSON.parse(localStorage.getItem('shelfLife_restoreLogs') || '[]');
                    logs.unshift(logEntry);
                    localStorage.setItem('shelfLife_restoreLogs', JSON.stringify(logs.slice(0, 50)));
                    localStorage.setItem('shelfLife_restore_meta', JSON.stringify({ name: targetSet, date: new Date().toLocaleString() }));

                    alert(`Restore Complete (${mode})\n\nScanned: ${stats.total}\nAdded: ${stats.added}\nDuplicates: ${stats.duplicates}\nSkipped: ${stats.skipped}`);
                    window.location.reload();

                } catch (e) {
                    alert("Restore Error: " + e.message);
                }
            };

            // Legacy/Single File Import
            const handleLegacyImport = (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (evt) => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        if (!Array.isArray(data)) throw new Error("Invalid JSON Format");
                        if (!confirm(`Restore ${data.length} books from file "${file.name}"?\nWarning: This will REPLACE your library.`)) return;

                        await db.books.clear();
                        await db.books.bulkAdd(data);
                        alert("Legacy Restore Complete!");
                        window.location.reload();
                    } catch (err) {
                        alert("Import Failed: " + err.message);
                    }
                };
                reader.readAsText(file);
            };

            // Smart Restore: Pick one file, app handles all chunks
            const handleSmartRestore = async (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                // Allow multi-select for all parts
                const allFiles = Array.from(files).filter(f => f.name.endsWith('.json'));
                if (allFiles.length === 0) { alert("No JSON files selected"); return; }

                // Sort by filename to ensure Part1, Part2... order
                allFiles.sort((a, b) => a.name.localeCompare(b.name));

                // Parse first file to get signature info
                const firstFileContent = await readFileAsText(allFiles[0]);
                const firstData = JSON.parse(firstFileContent);
                const signature = firstData.find(b => b.__shelflife_signature__)?.__shelflife_signature__;

                const signatureInfo = signature
                    ? `Device: ${signature.device_nickname || 'Unknown'}\nModel: ${signature.device_model || 'Unknown'}\nBooks: ${signature.book_count || '?'}`
                    : 'Legacy backup (no signature)';

                const modeInput = prompt(`Restoring ${allFiles.length} file(s):\n${allFiles.map(f => f.name).join('\n')}\n\n${signatureInfo}\n\nChoose Restore Mode:\n[1] REPLACE (Wipe & Import)\n[2] APPEND (Add New, Skip Duplicates)\n[3] MERGE (Add All, Mark Duplicates)\n\nEnter 1, 2, or 3:`, "1");

                if (!modeInput || !['1', '2', '3'].includes(modeInput)) return;
                const modeMap = { '1': 'Replace', '2': 'Append', '3': 'Merge' };
                const mode = modeMap[modeInput];

                if (mode === 'Replace' && !confirm("WARNING: REPLACE mode will PERMANENTLY DELETE your current library.\nAre you sure?")) return;

                if (mode === 'Replace') await db.books.clear();
                const existingBooks = (mode !== 'Replace') ? await db.books.toArray() : [];

                const isDuplicate = (newB, existB) => {
                    return existB.some(b =>
                        (b.title || '').toLowerCase().trim() === (newB.title || '').toLowerCase().trim() &&
                        (b.author_name || b.author || '').toLowerCase().trim() === (newB.author_name || newB.author || '').toLowerCase().trim() &&
                        (b.language || 'en') === (newB.language || 'en') &&
                        (b.building || '').toLowerCase().trim() === (newB.building || '').toLowerCase().trim()
                    );
                };

                let stats = { total: 0, added: 0, duplicates: 0, skipped: 0 };

                for (const file of allFiles) {
                    try {
                        const content = await readFileAsText(file);
                        let chunkData = JSON.parse(content);

                        // Handle sync file format: {_shelflife_sync: true, books: [...]}
                        if (!Array.isArray(chunkData)) {
                            if (chunkData._shelflife_sync && Array.isArray(chunkData.books)) {
                                chunkData = chunkData.books;
                            } else if (chunkData.books && Array.isArray(chunkData.books)) {
                                chunkData = chunkData.books;
                            } else {
                                console.warn(`Skipping ${file.name}: not a recognized format`);
                                continue;
                            }
                        }

                        const toAdd = [];
                        for (let book of chunkData) {
                            // Skip signature objects
                            if (book.__shelflife_signature__) continue;

                            stats.total++;

                            // Author migration
                            if (book.author && !book.author_name) {
                                const parts = book.author.trim().split(' ');
                                let name = parts.pop() || '';
                                let initials = parts.join(' ') || '';
                                if (!initials && !name) name = book.author;
                                book.author_name = name;
                                book.author_initials = initials;
                                delete book.author;
                            }

                            if (mode === 'Replace') {
                                toAdd.push(book);
                                stats.added++;
                            } else {
                                const dup = isDuplicate(book, existingBooks);
                                if (dup) {
                                    stats.duplicates++;
                                    if (mode === 'Merge') {
                                        book.tags = [...(book.tags || []), 'duplicate'];
                                        toAdd.push(book);
                                        stats.added++;
                                    } else {
                                        stats.skipped++;
                                    }
                                } else {
                                    toAdd.push(book);
                                    stats.added++;
                                }
                            }
                        }

                        if (toAdd.length > 0) {
                            await db.books.bulkAdd(toAdd);
                            if (mode !== 'Replace') existingBooks.push(...toAdd);
                        }
                    } catch (err) {
                        console.error(`Error processing ${file.name}:`, err);
                    }
                }
                // Generate automatic restore logs (TXT and CSV)
                const now = new Date();
                const ts = now.toISOString().replace(/[:.]/g, '-').slice(0, 16);
                const logFolder = 'ShelfLife/Restore';
                const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';

                const txtLog = `========================================
                                ShelfLife Restore Log
========================================
Date: ${now.toLocaleString()}
Mode: ${mode.toUpperCase()}
----------------------------------------
SOURCE FILES:
${allFiles.map((f, i) => `${i + 1}. ${f.name}`).join('\n')}
${signature ? `\nBackup Device: ${signature.device_nickname || 'Unknown'}\nBackup Model: ${signature.device_model || 'Unknown'}` : '\nLegacy backup (no signature)'}
----------------------------------------
RESULT:
Total Scanned: ${stats.total}
Added: ${stats.added}
Duplicates Found: ${stats.duplicates}
Skipped: ${stats.skipped}
========================================`;

                const csvLog = `Date,Mode,Files,Scanned,Added,Duplicates,Skipped\n"${now.toISOString()}","${mode}","${allFiles.map(f => f.name).join('; ')}",${stats.total},${stats.added},${stats.duplicates},${stats.skipped}`;

                // Save logs if on Capacitor
                if (isNativeCapacitor()) {
                    try {
                        const { Filesystem } = window.Capacitor.Plugins;
                        const targetDir = Directory[baseStr] || Directory.Documents;

                        await Filesystem.writeFile({
                            path: `${logFolder}/restore_log_${ts}.txt`,
                            directory: targetDir,
                            data: txtLog,
                            encoding: Encoding.UTF8
                        });

                        await Filesystem.writeFile({
                            path: `${logFolder}/restore_log_${ts}.csv`,
                            directory: targetDir,
                            data: csvLog,
                            encoding: Encoding.UTF8
                        });
                    } catch (logErr) {
                        console.error('Failed to save restore logs:', logErr);
                    }
                }

                alert(`Restore Complete (${mode})\n\nScanned: ${stats.total}\nAdded: ${stats.added}\nDuplicates: ${stats.duplicates}\nSkipped: ${stats.skipped}\n\nüìù Logs saved to ${logFolder}/`);
                window.location.reload();
            };

            // Helper to read file as text
            const readFileAsText = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsText(file);
                });
            };
            const verifyFolder = async () => {
                if (!isNativeCapacitor()) return alert("This feature requires the Android app.");
                try {
                    const { Filesystem } = window.Capacitor.Plugins;
                    const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                    const targetDir = Directory[baseStr] || Directory.Documents;

                    // NEW FOLDER STRUCTURE (v2.2+)
                    const root = 'ShelfLife';
                    const folders = [
                        root,
                        `${root}/Backups`,
                        `${root}/IMAGES`,
                        `${root}/Restore`,
                        `${root}/Exports`,
                        `${root}/to_merge`
                    ];

                    // Create all folders
                    for (const f of folders) {
                        try {
                            await Filesystem.mkdir({ path: f, directory: targetDir, recursive: true });
                        } catch (e) {
                            // Ignore if exists
                        }
                    }

                    await Filesystem.writeFile({
                        path: `${root}/Backups/Test_Write.txt`,
                        data: "Access Verified " + new Date().toISOString(),
                        directory: targetDir,
                        encoding: Encoding.UTF8
                    });

                    alert(`Storage Verified! ‚úÖ\n\nCreated/Verified:\nüìÇ ${root}/\n  ‚îú‚îÄ Backups/\n  ‚îú‚îÄ IMAGES/\n  ‚îú‚îÄ Restore/\n  ‚îú‚îÄ Exports/\n  ‚îî‚îÄ to_merge/`);
                } catch (err) {
                    alert(`Storage Error: ${err.message}\nCheck app permissions.`);
                }
            };

            // Sync to folder for recovery (enhanced: delete old, show comparison)
            const syncToFolder = async () => {
                try {
                    const allBooks = await db.books.toArray();
                    const deviceName = localStorage.getItem('shelfLife_deviceName') || 'Desktop';
                    const syncData = {
                        _shelflife_sync: true,
                        timestamp: new Date().toISOString(),
                        version: APP_VERSION,
                        device: deviceName,
                        count: allBooks.length,
                        books: allBooks
                    };
                    const filename = `shelflife_sync_${deviceName}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                    const jsonStr = JSON.stringify(syncData);

                    // Check for Tauri (Windows/Mac/Linux desktop app)
                    if (window.__TAURI__) {
                        try {
                            const { save } = window.__TAURI__.dialog;
                            const { writeTextFile, BaseDirectory } = window.__TAURI__.fs;

                            // Ask user where to save
                            const filePath = await save({
                                defaultPath: filename,
                                filters: [{ name: 'JSON', extensions: ['json'] }]
                            });

                            if (filePath) {
                                await writeTextFile(filePath, jsonStr);
                                alert(`‚úÖ Sync Complete!\n\nüìö ${allBooks.length} books\nüì± Device: ${deviceName}\nüìÇ Saved to: ${filePath}`);
                            }
                            return;
                        } catch (tauriErr) {
                            console.error('Tauri save failed:', tauriErr);
                            // Fall through to browser download
                        }
                    }

                    // Check for Capacitor (Android/iOS)
                    if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Filesystem) {
                        const { Filesystem } = window.Capacitor.Plugins;
                        const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                        const targetDir = Directory[baseStr] || Directory.Documents;
                        const folder = 'ShelfLife/sync_root_folder';

                        try {
                            await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true });
                        } catch (mkdirErr) {
                            if (!mkdirErr.message?.includes('exist')) throw mkdirErr;
                        }

                        // Read existing sync files for comparison
                        let previousCount = 0;
                        let oldFiles = [];
                        try {
                            const dirContents = await Filesystem.readdir({ path: folder, directory: targetDir });
                            oldFiles = dirContents.files.filter(f => f.name && f.name.startsWith('shelflife_sync_') && f.name.endsWith('.json'));
                            if (oldFiles.length > 0) {
                                const latestFile = oldFiles.sort((a, b) => (b.name || '').localeCompare(a.name || ''))[0];
                                try {
                                    const prevData = await Filesystem.readFile({
                                        path: `${folder}/${latestFile.name}`,
                                        directory: targetDir,
                                        encoding: Encoding.UTF8
                                    });
                                    const parsed = JSON.parse(prevData.data);
                                    previousCount = parsed.count || 0;
                                } catch (e) { }
                            }
                        } catch (e) { }

                        await Filesystem.writeFile({
                            path: `${folder}/${filename}`,
                            data: jsonStr,
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });

                        // Delete old sync files
                        for (const oldFile of oldFiles) {
                            try {
                                await Filesystem.deleteFile({ path: `${folder}/${oldFile.name}`, directory: targetDir });
                            } catch (e) { }
                        }

                        const diff = allBooks.length - previousCount;
                        const diffText = previousCount === 0 ? 'First sync!' :
                            (diff > 0 ? `+${diff} new books since last sync` :
                                diff < 0 ? `${diff} books (some deleted)` : 'No change in book count');
                        alert(`‚úÖ Sync Complete!\n\nüìö ${allBooks.length} books\nüìä ${diffText}\nüì± Device: ${deviceName}\nüìÇ ${folder}/${filename}\n\n${oldFiles.length > 0 ? `üóëÔ∏è Deleted ${oldFiles.length} old sync file(s)` : ''}`);
                        return;
                    }

                    // Browser fallback - download file
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    alert(`‚úÖ Sync Complete!\n\nüìö ${allBooks.length} books\nüì± Device: ${deviceName}\nüìÇ Downloaded: ${filename}`);
                } catch (err) {
                    alert(`Sync Error: ${err.message}\nCheck app permissions.`);
                }
            };

            // --- SETTINGS COMPONENT FIX ---
            const [tempDeviceName, setTempDeviceName] = useState(localStorage.getItem('shelfLife_deviceName') || 'MYPHONE');

            return (
                <div className="p-4 space-y-4 pb-24">
                    <h2 className="text-2xl font-bold">Tools</h2>

                    {/* ABOUT SECTION */}
                    <div className="bg-gradient-to-br from-blue-500 to-blue-700 p-4 rounded-xl shadow-lg text-white">
                        <h3 className="font-bold text-xl mb-2">üìö ShelfLife</h3>
                        <div className="space-y-1 text-sm">
                            <p><span className="font-bold">Version:</span> {APP_VERSION}</p>
                            <p><span className="font-bold">Build:</span> {BUILD_DATE}</p>
                            <p><span className="font-bold">Commit:</span> {COMMIT_HASH}</p>
                        </div>
                        <div className="mt-3 pt-3 border-t border-white/30">
                            <button
                                onClick={() => setShowWhatsNew(!showWhatsNew)}
                                className="text-xs font-bold mb-1 flex items-center gap-1 hover:underline w-full"
                            >
                                ‚ú® What's New in v2.5 {showWhatsNew ? '‚ñº' : '‚ñ∂'}
                            </button>
                            {showWhatsNew && (
                                <ul className="text-xs space-y-0.5 list-disc list-inside mt-2">
                                    <li>üì∑ Improved camera (Capacitor plugin)</li>
                                    <li>üè∑Ô∏è Tag Manager: Browse All, Title Case</li>
                                    <li>üìÅ Merge Studio: Multi-folder picker</li>
                                    <li>üíæ Sync to Folder with comparison</li>
                                    <li>üîç Slicer: Keyboard-aware search</li>
                                    <li>üìö Help Guide (in Tools section)</li>
                                </ul>
                            )}
                        </div>
                    </div>

                    {/* REPORTS SECTION - COLLAPSIBLE */}
                    <div className="bg-white p-4 rounded-xl shadow border border-blue-100">
                        <button
                            onClick={() => setShowReports(!showReports)}
                            className="w-full font-bold text-blue-800 flex justify-between items-center"
                        >
                            <span className="flex items-center gap-2"><Icon name="BarChart2" size={18} /> Reports & Exports</span>
                            <Icon name={showReports ? 'ChevronUp' : 'ChevronDown'} size={18} />
                        </button>

                        {showReports && (
                            <div className="mt-3 pt-3 border-t">
                                <p className="text-[10px] text-gray-400 mb-2 italic">Reports saved to ShelfLife/Exports</p>
                                <div className="space-y-2">
                                    <button onClick={() => ExportUtils.htmlText(books, 'Mix', 'Library Inventory')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="List" /> HTML Text Report</button>
                                    <button onClick={() => ExportUtils.htmlVisual(books, 'Mix', 'Visual Catalogue')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="Image" /> HTML Visual Catalogue</button>
                                    <button onClick={() => ExportUtils.htmlDashboard(books, 'Library Dashboard')} className="w-full py-3 bg-gradient-to-r from-indigo-500 to-purple-500 text-white rounded-lg flex items-center justify-center gap-2 text-sm font-bold"><Icon name="LayoutDashboard" /> HTML Dashboard</button>
                                    <button onClick={() => ExportUtils.csv(books, 'Library_Export')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="Download" /> Export CSV</button>

                                    {/* Export Images to ZIP */}
                                    <button
                                        onClick={async () => {
                                            if (imageExportStatus.exporting) return;
                                            setImageExportStatus({ exporting: true, current: 0, total: 0, message: 'Preparing...' });
                                            const result = await ExportUtils.imagesZip(books, (current, total, message) => {
                                                setImageExportStatus({ exporting: true, current, total, message });
                                            });
                                            setImageExportStatus({ exporting: false, current: 0, total: 0, message: '' });
                                            if (result.success) {
                                                const fileList = result.files.map(f => `‚Ä¢ ${f.filename} (${f.imageCount} images, ~${f.sizeMB}MB)`).join('\n');
                                                alert(`‚úÖ Exported ${result.totalImages} images!\n\n${result.totalParts} ZIP file(s):\n${fileList}\n\nSaved to: ${result.folder}`);
                                            } else if (result.error && result.error !== 'User cancelled') {
                                                const partialMsg = result.partialFiles?.length ? `\n(Partial: ${result.partialFiles.length} files saved before error)` : '';
                                                alert(`‚ùå Export failed: ${result.error}${partialMsg}`);
                                            }
                                        }}
                                        disabled={imageExportStatus.exporting}
                                        className={`w-full py-3 rounded-lg flex items-center justify-center gap-2 text-sm transition ${imageExportStatus.exporting ? 'bg-green-100 text-green-700' : 'bg-green-50 hover:bg-green-100 text-green-700'}`}
                                    >
                                        {imageExportStatus.exporting ? (
                                            <>
                                                <span className="animate-pulse">üì¶</span>
                                                <span className="text-xs">{imageExportStatus.message} ({imageExportStatus.current}/{imageExportStatus.total})</span>
                                            </>
                                        ) : (
                                            <><Icon name="Image" /> Export Images (ZIP)</>
                                        )}
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* TAG MANAGER SECTION */}
                    <div className="bg-white p-4 rounded-xl shadow border border-purple-100">
                        <h3 className="font-bold mb-3 text-purple-800 flex items-center gap-2"><Icon name="Tag" size={18} /> Tag Manager</h3>
                        <p className="text-xs text-gray-500 mb-3">Manage all your tags in one place - rename, delete, merge duplicates.</p>
                        <button
                            onClick={() => setShowTagManager(true)}
                            className="w-full py-3 bg-purple-50 text-purple-700 rounded-lg flex items-center justify-center gap-2 text-sm font-bold hover:bg-purple-100 transition"
                        >
                            <Icon name="Tag" size={18} /> Open Tag Manager
                        </button>
                    </div>

                    {/* BULK EDIT SECTION */}
                    <div className="bg-white p-4 rounded-xl shadow border border-teal-100">
                        <h3 className="font-bold mb-3 text-teal-800 flex items-center gap-2"><Icon name="Edit3" size={18} /> Bulk Edit</h3>
                        <p className="text-xs text-gray-500 mb-3">Mass-update fields across multiple books at once.</p>
                        <div className="space-y-2">
                            <button
                                onClick={() => setShowFindReplace(true)}
                                className="w-full py-3 bg-teal-50 text-teal-700 rounded-lg flex items-center justify-center gap-2 text-sm font-bold hover:bg-teal-100 transition"
                            >
                                <Icon name="Search" size={18} /> Find & Replace
                            </button>
                            <button
                                onClick={() => setShowCSVImport(true)}
                                className="w-full py-3 bg-teal-50 text-teal-700 rounded-lg flex items-center justify-center gap-2 text-sm font-bold hover:bg-teal-100 transition"
                            >
                                <Icon name="Upload" size={18} /> Import CSV (Merge)
                            </button>
                        </div>
                    </div>

                    {/* FIND & REPLACE MODAL */}
                    {showFindReplace && (() => {
                        const fieldOptions = [
                            { value: 'owner', label: 'üë§ Owner' },
                            { value: 'building', label: 'üè† Building' },
                            { value: 'shelf', label: 'üìö Shelf' },
                            { value: 'publisher', label: 'üìñ Publisher' },
                            { value: 'author_name', label: '‚úçÔ∏è Author Name' },
                            { value: 'author_initials', label: 'üî§ Author Initials' },
                            { value: 'language', label: 'üåç Language' },
                            { value: 'condition', label: 'üìã Condition' },
                            { value: 'currency', label: 'üí∞ Currency' },
                            { value: 'tags', label: 'üè∑Ô∏è Tags (individual)' }
                        ];
                        // Convert wildcard pattern (* = any chars) to regex
                        const wildcardToRegex = (pattern, caseSensitive) => {
                            const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&').replace(/\*/g, '.*');
                            return new RegExp(escaped, caseSensitive ? '' : 'i');
                        };
                        const hasWildcard = frFind.includes('*');
                        const doPreview = () => {
                            if (!frFind.trim()) { setFrPreview([]); return; }
                            const regex = hasWildcard ? wildcardToRegex(frFind, frCaseSensitive) : null;
                            const matches = books.filter(b => {
                                if (frField === 'tags') {
                                    return (b.tags || []).some(t => {
                                        const val = t || '';
                                        if (hasWildcard) return regex.test(val);
                                        if (frExactMatch) return frCaseSensitive ? val === frFind : val.toLowerCase() === frFind.toLowerCase();
                                        return frCaseSensitive ? val.includes(frFind) : val.toLowerCase().includes(frFind.toLowerCase());
                                    });
                                } else {
                                    const val = b[frField] || '';
                                    if (hasWildcard) return regex.test(val);
                                    if (frExactMatch) return frCaseSensitive ? val === frFind : val.toLowerCase() === frFind.toLowerCase();
                                    return frCaseSensitive ? val.includes(frFind) : val.toLowerCase().includes(frFind.toLowerCase());
                                }
                            });
                            setFrPreview(matches.slice(0, 50));
                        };
                        const doApply = async () => {
                            if (!frFind.trim()) return;

                            // Re-scan ALL matches (ignore preview limit)
                            const regex = hasWildcard ? wildcardToRegex(frFind, frCaseSensitive) : null;
                            const allMatches = books.filter(b => {
                                if (frField === 'tags') {
                                    return (b.tags || []).some(t => {
                                        const val = t || '';
                                        if (hasWildcard) return regex.test(val);
                                        if (frExactMatch) return frCaseSensitive ? val === frFind : val.toLowerCase() === frFind.toLowerCase();
                                        return frCaseSensitive ? val.includes(frFind) : val.toLowerCase().includes(frFind.toLowerCase());
                                    });
                                } else {
                                    const val = b[frField] || '';
                                    if (hasWildcard) return regex.test(val);
                                    if (frExactMatch) return frCaseSensitive ? val === frFind : val.toLowerCase() === frFind.toLowerCase();
                                    return frCaseSensitive ? val.includes(frFind) : val.toLowerCase().includes(frFind.toLowerCase());
                                }
                            });

                            if (allMatches.length === 0) return;

                            for (const book of allMatches) {
                                if (frField === 'tags') {
                                    const newTags = (book.tags || []).map(t => {
                                        if (hasWildcard) {
                                            if (regex.test(t)) return frReplace;
                                            return t;
                                        }
                                        const matches_ = frExactMatch
                                            ? (frCaseSensitive ? t === frFind : t.toLowerCase() === frFind.toLowerCase())
                                            : (frCaseSensitive ? t.includes(frFind) : t.toLowerCase().includes(frFind.toLowerCase()));
                                        if (matches_) return frExactMatch ? frReplace : t.replace(new RegExp(frFind, frCaseSensitive ? 'g' : 'gi'), frReplace);
                                        return t;
                                    });
                                    await db.books.update(book.id, { tags: newTags });
                                } else {
                                    const oldVal = book[frField] || '';
                                    let newVal;
                                    if (hasWildcard) {
                                        newVal = oldVal.replace(regex, frReplace);
                                    } else {
                                        newVal = frExactMatch ? frReplace : oldVal.replace(new RegExp(frFind, frCaseSensitive ? 'g' : 'gi'), frReplace);
                                    }
                                    await db.books.update(book.id, { [frField]: newVal });
                                }
                            }
                            setFrApplied(true);
                            setTimeout(() => { setShowFindReplace(false); window.location.reload(); }, 1500);
                        };
                        const closeModal = () => { setShowFindReplace(false); setFrFind(''); setFrReplace(''); setFrPreview([]); setFrApplied(false); };
                        return (
                            <div className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4" onClick={closeModal}>
                                <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg max-h-[90vh] overflow-hidden" onClick={e => e.stopPropagation()}>
                                    <div className="bg-gradient-to-r from-teal-500 to-cyan-500 p-4 text-white">
                                        <div className="flex justify-between items-center">
                                            <h3 className="font-bold text-lg flex items-center gap-2">üîÑ Find & Replace</h3>
                                            <button onClick={closeModal} className="w-8 h-8 rounded-full bg-white/20 flex items-center justify-center hover:bg-white/30">‚úï</button>
                                        </div>
                                        <p className="text-sm opacity-90 mt-1">Mass-update a field across all matching books</p>
                                    </div>
                                    <div className="p-4 space-y-4 max-h-[60vh] overflow-y-auto">
                                        <div>
                                            <label className="block text-xs font-bold text-gray-600 uppercase mb-1">Field</label>
                                            <select value={frField} onChange={e => setFrField(e.target.value)} className="w-full p-3 border rounded-lg text-sm bg-gray-50">
                                                {fieldOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
                                            </select>
                                        </div>
                                        <div className="grid grid-cols-2 gap-3">
                                            <div>
                                                <label className="block text-xs font-bold text-gray-600 uppercase mb-1">Find</label>
                                                <input type="text" value={frFind} onChange={e => setFrFind(e.target.value)} placeholder="Text to find..." className="w-full p-3 border rounded-lg text-sm" />
                                            </div>
                                            <div>
                                                <label className="block text-xs font-bold text-gray-600 uppercase mb-1">Replace With</label>
                                                <input type="text" value={frReplace} onChange={e => setFrReplace(e.target.value)} placeholder="Replacement text..." className="w-full p-3 border rounded-lg text-sm" />
                                            </div>
                                        </div>
                                        <div className="flex gap-4 text-sm">
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input type="checkbox" checked={frCaseSensitive} onChange={e => setFrCaseSensitive(e.target.checked)} className="w-4 h-4" /> Case sensitive
                                            </label>
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input type="checkbox" checked={frExactMatch} onChange={e => setFrExactMatch(e.target.checked)} className="w-4 h-4" /> Exact match only
                                            </label>
                                        </div>
                                        <button onClick={doPreview} className="w-full py-2 bg-gray-100 rounded-lg text-sm font-bold hover:bg-gray-200">üîç Preview Changes</button>
                                        {frPreview.length > 0 && (
                                            <div className="bg-teal-50 rounded-lg p-3 border border-teal-200">
                                                <div className="text-sm font-bold text-teal-800 mb-2">üìö {frPreview.length} book(s) will be updated</div>
                                                <div className="max-h-32 overflow-y-auto space-y-1 text-xs">
                                                    {frPreview.map(b => (
                                                        <div key={b.id} className="bg-white rounded p-2 flex justify-between items-center">
                                                            <span className="truncate">{b.title}</span>
                                                            <span className="text-teal-600 font-mono">{frField === 'tags' ? (b.tags || []).join(', ') : b[frField] || '(empty)'}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    <div className="p-4 border-t flex gap-3">
                                        <button onClick={closeModal} className="flex-1 py-3 border rounded-lg font-bold text-gray-600 hover:bg-gray-50">Cancel</button>
                                        <button onClick={doApply} disabled={frPreview.length === 0 || frApplied} className={`flex-1 py-3 rounded-lg font-bold text-white ${frApplied ? 'bg-green-500' : frPreview.length > 0 ? 'bg-teal-600 hover:bg-teal-700' : 'bg-gray-300 cursor-not-allowed'}`}>
                                            {frApplied ? '‚úÖ Applied!' : `Apply to ${frPreview.length} Books`}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        );
                    })()}

                    {/* CSV IMPORT MODAL */}
                    {showCSVImport && (() => {
                        const parseCSV = (text) => {
                            const lines = text.split(/\r?\n/).filter(l => l.trim());
                            if (lines.length < 2) return [];
                            const headers = lines[0].split(',').map(h => h.replace(/^"|"$/g, '').trim());
                            const rows = [];
                            for (let i = 1; i < lines.length; i++) {
                                const values = []; let current = ''; let inQuotes = false;
                                for (const char of lines[i]) {
                                    if (char === '"') inQuotes = !inQuotes;
                                    else if (char === ',' && !inQuotes) { values.push(current.trim()); current = ''; }
                                    else current += char;
                                }
                                values.push(current.trim());
                                const row = {}; headers.forEach((h, idx) => { row[h] = values[idx] || ''; }); rows.push(row);
                            }
                            return rows;
                        };
                        const handleFile = async (e) => {
                            const file = e.target.files?.[0]; if (!file) return;
                            setCsvFile(file);
                            const text = await file.text();
                            const parsed = parseCSV(text);
                            setCsvData(parsed);
                            let matched = 0, unmatched = 0;
                            for (const row of parsed) {
                                const id = parseInt(row.ID || row.id || '0');
                                if (id && books.find(b => b.id === id)) matched++; else unmatched++;
                            }
                            setCsvPreview({ total: parsed.length, matched, unmatched });
                        };
                        const doImport = async () => {
                            if (csvData.length === 0) return;
                            setCsvProcessing(true);
                            const now = new Date();
                            const ts = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
                            let log = `CSV Import Log - ${now.toLocaleString()}\n${'='.repeat(45)}\nFile: ${csvFile?.name || 'Unknown'}\nTotal rows: ${csvData.length}\n`;
                            let updated = 0, skipped = 0; const changes = [];
                            for (const row of csvData) {
                                const id = parseInt(row.ID || row.id || '0');
                                const existingBook = books.find(b => b.id === id);
                                if (!existingBook) { skipped++; log += `SKIP: ID ${id} not found\n`; continue; }
                                const updates = {};
                                const fieldMap = { 'Title': 'title', 'AuthorName': 'author_name', 'AuthorInitials': 'author_initials', 'Publisher': 'publisher', 'Year': 'pub_year', 'Pages': 'page_count', 'Condition': 'condition', 'Price': 'price', 'Currency': 'currency', 'Owner': 'owner', 'Building': 'building', 'Shelf': 'shelf', 'ISBN': 'isbn', 'Status': 'status' };
                                for (const [csvKey, dbKey] of Object.entries(fieldMap)) {
                                    if (row[csvKey] !== undefined && row[csvKey] !== (existingBook[dbKey] || '').toString()) {
                                        const oldVal = existingBook[dbKey] || ''; const newVal = row[csvKey];
                                        if (oldVal.toString() !== newVal.toString()) {
                                            updates[dbKey] = ['pub_year', 'page_count', 'price'].includes(dbKey) ? (parseFloat(newVal) || newVal) : newVal;
                                            changes.push(`ID ${id}: ${dbKey} "${oldVal}" ‚Üí "${newVal}"`);
                                        }
                                    }
                                }
                                const newTags = [];
                                for (let i = 1; i <= 10; i++) { const tagVal = row[`Tag_${i}`]; if (tagVal && tagVal.trim()) newTags.push(tagVal.trim()); }
                                if (newTags.length > 0) {
                                    const oldTags = existingBook.tags || [];
                                    if (JSON.stringify(oldTags) !== JSON.stringify(newTags)) { updates.tags = newTags; changes.push(`ID ${id}: tags [${oldTags.join(', ')}] ‚Üí [${newTags.join(', ')}]`); }
                                }
                                if (Object.keys(updates).length > 0) { await db.books.update(id, updates); updated++; }
                            }
                            log += `\nUpdated: ${updated} books\nSkipped: ${skipped} (ID not found)\n\nChanges:\n${changes.slice(0, 100).join('\n')}${changes.length > 100 ? `\n... and ${changes.length - 100} more` : ''}`;
                            try { const blob = new Blob([log], { type: 'text/plain' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `csv_import_${ts}.txt`; document.body.appendChild(a); a.click(); document.body.removeChild(a); } catch (e) { console.error('Failed to save log:', e); }
                            setCsvProcessing(false); setCsvDone(true);
                            setTimeout(() => { setShowCSVImport(false); window.location.reload(); }, 2000);
                        };
                        const closeModal = () => { setShowCSVImport(false); setCsvFile(null); setCsvData([]); setCsvPreview({ total: 0, matched: 0, unmatched: 0 }); setCsvDone(false); };
                        return (
                            <div className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4" onClick={closeModal}>
                                <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg max-h-[90vh] overflow-hidden" onClick={e => e.stopPropagation()}>
                                    <div className="bg-gradient-to-r from-teal-500 to-emerald-500 p-4 text-white">
                                        <div className="flex justify-between items-center">
                                            <h3 className="font-bold text-lg flex items-center gap-2">üì• Import CSV (Merge)</h3>
                                            <button onClick={closeModal} className="w-8 h-8 rounded-full bg-white/20 flex items-center justify-center hover:bg-white/30">‚úï</button>
                                        </div>
                                        <p className="text-sm opacity-90 mt-1">Update existing books from an edited CSV file</p>
                                    </div>
                                    <div className="p-4 space-y-4 max-h-[60vh] overflow-y-auto">
                                        <div className="bg-amber-50 border border-amber-200 rounded-lg p-3 text-sm text-amber-800">
                                            <b>üí° How it works:</b>
                                            <ol className="list-decimal list-inside mt-1 space-y-1 text-xs">
                                                <li>Export CSV from Reports section (includes ID column)</li>
                                                <li>Edit in Excel (keep ID column unchanged)</li>
                                                <li>Import here - changes merge by ID, images preserved</li>
                                            </ol>
                                        </div>
                                        <div>
                                            <label className="block text-xs font-bold text-gray-600 uppercase mb-2">Select CSV File</label>
                                            <input type="file" accept=".csv" onChange={handleFile} className="w-full p-3 border-2 border-dashed rounded-lg text-sm bg-gray-50" />
                                        </div>
                                        {csvPreview.total > 0 && (
                                            <div className="bg-teal-50 rounded-lg p-4 border border-teal-200">
                                                <div className="text-sm font-bold text-teal-800 mb-2">üìä Preview</div>
                                                <div className="grid grid-cols-3 gap-2 text-center text-sm">
                                                    <div className="bg-white rounded p-2"><div className="text-2xl font-bold text-gray-800">{csvPreview.total}</div><div className="text-xs text-gray-500">Total Rows</div></div>
                                                    <div className="bg-white rounded p-2"><div className="text-2xl font-bold text-green-600">{csvPreview.matched}</div><div className="text-xs text-gray-500">ID Matched</div></div>
                                                    <div className="bg-white rounded p-2"><div className="text-2xl font-bold text-red-500">{csvPreview.unmatched}</div><div className="text-xs text-gray-500">Not Found</div></div>
                                                </div>
                                                {csvPreview.unmatched > 0 && <p className="text-xs text-amber-600 mt-2">‚ö†Ô∏è {csvPreview.unmatched} rows have IDs not found in your library - these will be skipped.</p>}
                                            </div>
                                        )}
                                    </div>
                                    <div className="p-4 border-t flex gap-3">
                                        <button onClick={closeModal} className="flex-1 py-3 border rounded-lg font-bold text-gray-600 hover:bg-gray-50">Cancel</button>
                                        <button onClick={doImport} disabled={csvPreview.matched === 0 || csvProcessing || csvDone} className={`flex-1 py-3 rounded-lg font-bold text-white ${csvDone ? 'bg-green-500' : csvProcessing ? 'bg-teal-400' : csvPreview.matched > 0 ? 'bg-teal-600 hover:bg-teal-700' : 'bg-gray-300 cursor-not-allowed'}`}>
                                            {csvDone ? '‚úÖ Import Complete!' : csvProcessing ? '‚è≥ Importing...' : `Import ${csvPreview.matched} Books`}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        );
                    })()}

                    <div className="bg-white p-4 rounded-xl shadow border border-orange-100">
                        <h3 className="font-bold mb-3 text-orange-800">Backup & Restore</h3>
                        {lastRestore && <div className="text-xs text-gray-500 mb-3 bg-gray-50 p-2 rounded border">Last Restored: <b>{lastRestore.name}</b><br />{lastRestore.date}</div>}

                        {/* DATA SYNC SETTINGS */}
                        <div className="bg-white p-4 rounded-xl shadow border border-blue-100 mt-4">
                            <h3 className="font-bold mb-3 text-blue-800">Sync & Device</h3>
                            <div className="mb-4">
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-1">This Device Name</label>
                                <div className="flex gap-2">
                                    <input
                                        className="flex-1 p-2 border rounded text-sm uppercase font-bold tracking-widest"
                                        maxLength={10}
                                        value={tempDeviceName}
                                        onChange={(e) => setTempDeviceName(e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, ''))}
                                    />
                                    <button
                                        onClick={() => {
                                            if (!tempDeviceName) return alert("Name cannot be empty");
                                            localStorage.setItem('shelfLife_deviceName', tempDeviceName);
                                            alert("Device Name Saved: " + tempDeviceName);
                                        }}
                                        className="px-3 py-2 bg-blue-600 text-white rounded font-bold text-xs"
                                    >
                                        SAVE
                                    </button>
                                </div>
                                <p className="text-[10px] text-gray-400 mt-1">Used in backups (A-Z, 0-9 Only). Example: SL_BK_MYPHONE_...</p>
                            </div>

                            <h4 className="text-xs font-bold text-gray-500 uppercase mb-2">History</h4>
                            <div className="max-h-32 overflow-y-auto bg-gray-50 p-2 rounded border text-xs space-y-2">
                                {(() => {
                                    let logs = [];
                                    try { logs = JSON.parse(localStorage.getItem('shelfLife_restoreLogs') || '[]'); } catch (e) { logs = []; }
                                    if (!Array.isArray(logs)) logs = [];

                                    if (logs.length === 0) return <div className="text-gray-400 text-center italic py-2">No restore history</div>;

                                    return logs.map((log, i) => (
                                        <div key={i} className="border-b pb-1 last:border-0">
                                            <div className="flex justify-between font-bold text-gray-700">
                                                <span>{new Date(log.timestamp).toLocaleDateString()}</span>
                                                <span className={`uppercase text-[10px] px-1 rounded ${log.status === 'Success' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>{log.mode}</span>
                                            </div>
                                            <div className="truncate text-gray-500">{log.source}</div>
                                            <div className="flex gap-2 mt-1 text-[10px] text-gray-400">
                                                <span>+{log.added} New</span>
                                                <span>{log.duplicates} Dupe</span>
                                                {log.skipped > 0 && <span>{log.skipped} Skip</span>}
                                            </div>
                                        </div>
                                    ));
                                })()}
                            </div>
                            <p className="text-xs text-gray-400 mt-2 text-center">üìù Restore logs are automatically saved to your backup folder</p>
                        </div>


                        <h4 className="font-bold text-xs uppercase text-yellow-800 mb-2">Backups</h4>
                        <div className="grid grid-cols-2 gap-2 mb-4">
                            <button onClick={() => performChunkedBackup(false)} className="py-2 bg-yellow-600 text-white rounded text-xs font-bold flex flex-col items-center gap-1"><Icon name="Save" size={16} /> Full Backup<span className="text-[9px] opacity-80">(Images)</span></button>
                            <button onClick={() => performChunkedBackup(true)} className="py-2 bg-yellow-700 text-white rounded text-xs font-bold flex flex-col items-center gap-1"><Icon name="FileText" size={16} /> Text-Only<span className="text-[9px] opacity-80">(No Images)</span></button>
                        </div>

                        <h4 className="font-bold text-xs uppercase text-yellow-800 mb-2">Restore</h4>
                        <div className="space-y-2">
                            <label className="w-full py-3 bg-green-600 text-white rounded text-sm font-bold flex items-center justify-center gap-2 cursor-pointer hover:bg-green-700">
                                <Icon name="RefreshCcw" /> Restore Backup
                                <input type="file" onChange={handleSmartRestore} accept=".json" multiple className="hidden" />
                            </label>
                            <p className="text-[9px] text-gray-500 text-center">Supports all formats: chunked backups, legacy files, single/multiple files</p>
                        </div>

                        <h4 className="font-bold text-xs uppercase text-blue-800 mb-2 mt-4">Sync</h4>
                        <div className="space-y-2 mb-4">
                            <button onClick={syncToFolder} className="w-full py-3 bg-blue-600 text-white rounded text-sm font-bold flex items-center justify-center gap-2 hover:bg-blue-700">
                                <Icon name="RefreshCw" /> Sync to Folder
                            </button>
                            <p className="text-[9px] text-gray-500 text-center">Exports full database to ShelfLife/sync_root_folder/.<br />üí° <em>Tip: Use "Restore Backup" to recover from sync files.</em></p>
                        </div>

                    </div>

                    {/* Tag Manager Modal */}
                    <TagManagerModal
                        isOpen={showTagManager}
                        onClose={() => setShowTagManager(false)}
                        books={books}
                        onTagsUpdated={() => {
                            // Slight delay to ensure UI updates before reload
                            setTimeout(() => window.location.reload(), 100);
                        }}
                    />

                    {/* DATA HANDLING HUB (MERGE STUDIO) */}
                    <div className="bg-white p-4 rounded-xl shadow border border-purple-200">
                        <h3 className="font-bold mb-3 text-purple-800 flex items-center gap-2"><Icon name="Merge" size={18} /> Merge Studio</h3>
                        <p className="text-xs text-gray-500 mb-3">Merge backup files from multiple devices into a unified master file.</p>
                        <DataHandlingHub />
                    </div>

                    {/* HELP & TIPS SECTION */}
                    <div className="bg-white p-4 rounded-xl shadow border border-green-200">
                        <button
                            onClick={() => setShowHelp(!showHelp)}
                            className="w-full font-bold text-green-800 flex justify-between items-center"
                        >
                            <span className="flex items-center gap-2"><Icon name="HelpCircle" size={18} /> Help & Tips</span>
                            <Icon name={showHelp ? 'ChevronUp' : 'ChevronDown'} size={18} />
                        </button>

                        {showHelp && (
                            <div className="mt-3 pt-3 border-t max-h-[400px] overflow-y-auto space-y-4 text-sm">
                                {/* Quick Start */}
                                <div>
                                    <h4 className="font-bold text-green-700 mb-1">üöÄ Quick Start</h4>
                                    <ol className="list-decimal list-inside text-xs text-gray-600 space-y-1">
                                        <li><b>Add your first book</b> ‚Äì Tap + ‚Üí Scan barcode OR take photo</li>
                                        <li><b>Organize with tags</b> ‚Äì Add tags like "Fiction", "To Read"</li>
                                        <li><b>Set up backups</b> ‚Äì Go to Tools ‚Üí Verify Folder</li>
                                    </ol>
                                </div>

                                {/* Features */}
                                <div>
                                    <h4 className="font-bold text-green-700 mb-1">üìñ Features Guide</h4>
                                    <div className="text-xs text-gray-600 space-y-2">
                                        <p><b>üì∑ Adding Books:</b> Scan ISBN for auto-fill, take cover photos, voice input (tap mic icon), multiple languages supported.</p>
                                        <p><b>üìö Library View:</b> Tap book for details, long-press for quick actions. Multi-select: Long-press ‚Üí select more ‚Üí bulk edit/delete.</p>
                                        <p><b>üîç Slicer Search:</b> Stack multiple filters (Publisher + Tag + Year). Export filtered results to CSV/HTML.</p>
                                        <p><b>üè∑Ô∏è Tag Manager:</b> Search or browse all tags. Select 1 tag ‚Üí Rename. Select 2+ tags ‚Üí Merge. All new tags auto-capitalize (Title Case).</p>
                                        <p><b>üíæ Backups:</b> Full Backup (with images, larger). Text-Only (no images, smaller). Sync to Folder (quick snapshot).</p>
                                    </div>
                                </div>

                                {/* Tips */}
                                <div>
                                    <h4 className="font-bold text-green-700 mb-1">üí° Tips & Tricks</h4>
                                    <ul className="text-xs text-gray-600 space-y-1 list-disc list-inside">
                                        <li>üé§ Voice input works best with short phrases</li>
                                        <li>üì± Device name appears in backup filenames</li>
                                        <li>üîÑ Data auto-refreshes every second</li>
                                        <li>üìÇ Sync files can be restored using "Restore Backup"</li>
                                    </ul>
                                </div>

                                {/* Troubleshooting */}
                                <div>
                                    <h4 className="font-bold text-green-700 mb-1">üîß Troubleshooting</h4>
                                    <ul className="text-xs text-gray-600 space-y-1 list-disc list-inside">
                                        <li><b>App won't load?</b> Clear app cache, reinstall</li>
                                        <li><b>Camera not working?</b> Check app permissions in Settings</li>
                                        <li><b>Backup failing?</b> Verify storage permissions</li>
                                    </ul>
                                </div>
                            </div>
                        )}
                    </div>
                </div >
            );
        };

        // --- DATA HANDLING HUB (MERGE STUDIO) ---
        const DataHandlingHub = () => {
            const [files, setFiles] = useState([]);
            const [selectedFiles, setSelectedFiles] = useState([]);
            const [mergeMode, setMergeMode] = useState('merge'); // merge or append
            const [loading, setLoading] = useState(false);
            const [step, setStep] = useState('scan'); // scan, preview, processing, complete

            const folder = localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups';
            const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';

            // Pick files for merge (replaces folder scan for Android 11+ compatibility)
            const handleFilePick = async (e) => {
                const pickedFiles = e.target.files;
                if (!pickedFiles || pickedFiles.length === 0) return;

                setLoading(true);
                try {
                    const scannedFiles = [];

                    for (const file of Array.from(pickedFiles)) {
                        if (!file.name.endsWith('.json')) continue;

                        try {
                            const content = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = (evt) => resolve(evt.target.result);
                                reader.onerror = reject;
                                reader.readAsText(file);
                            });

                            const data = JSON.parse(content);
                            const books = Array.isArray(data) ? data : [data];
                            const signature = books.find(b => b.__shelflife_signature__)?.__shelflife_signature__ || null;
                            const actualBooks = books.filter(b => !b.__shelflife_signature__);

                            scannedFiles.push({
                                name: file.name,
                                books: actualBooks,
                                count: actualBooks.length,
                                signature: signature,
                                hasImages: actualBooks.some(b => b.front || b.rear),
                                size: content.length
                            });
                        } catch (err) {
                            console.error(`Failed to parse ${file.name}:`, err);
                        }
                    }

                    // Append to existing files (allows multi-instance picking from different folders)
                    const existingNames = new Set(files.map(f => f.name));
                    const newFiles = scannedFiles.filter(f => !existingNames.has(f.name)); // Skip duplicates by name

                    if (newFiles.length === 0 && scannedFiles.length > 0) {
                        alert('These files are already added.');
                    } else {
                        setFiles(prev => [...prev, ...newFiles]);
                        // Select all including new files
                        setSelectedFiles(prev => [...prev, ...newFiles.map((_, i) => files.length + i)]);
                        if (files.length + newFiles.length > 0) setStep('preview');
                    }
                    if (scannedFiles.length === 0) alert('No valid JSON files found in selection.');
                } catch (err) {
                    alert('File Pick Error: ' + err.message);
                } finally {
                    setLoading(false);
                    e.target.value = ''; // Allow re-selecting same files
                }
            };

            // Calculate totals
            const totalBooks = useMemo(() => {
                return selectedFiles.reduce((sum, i) => sum + files[i]?.count || 0, 0);
            }, [selectedFiles, files]);

            // Execute merge
            const executeMerge = async () => {
                if (selectedFiles.length === 0) { alert("Select at least one file"); return; }
                setLoading(true);
                setStep('processing');

                try {
                    const now = new Date();
                    const ts = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0') + '_' + String(now.getHours()).padStart(2, '0') + '-' + String(now.getMinutes()).padStart(2, '0');
                    const deviceName = localStorage.getItem('shelfLife_deviceName') || 'Desktop';

                    // Collect all books (shared logic)
                    const masterMap = new Map();
                    const duplicates = [];
                    const sourceInfo = [];
                    let hasAnyImages = false;

                    for (const idx of selectedFiles) {
                        const file = files[idx];
                        sourceInfo.push({ name: file.name, count: file.count, type: file.signature?.type || 'UNKNOWN' });
                        if (file.hasImages) hasAnyImages = true;

                        for (const book of file.books) {
                            const key = `${book.title}|${book.isbn || ''}`.toLowerCase();
                            if (masterMap.has(key)) {
                                duplicates.push({ existing: masterMap.get(key), incoming: book });
                                if (mergeMode === 'merge') {
                                    book.tags = [...new Set([...(book.tags || []), 'duplicate'])];
                                    masterMap.set(`dup_${Date.now()}_${Math.random()}`, book);
                                }
                            } else {
                                masterMap.set(key, book);
                            }
                        }
                    }

                    const allBooks = [...masterMap.values()];
                    const typePrefix = hasAnyImages ? 'FULL' : 'TXT';

                    // Create signature
                    const signature = {
                        __shelflife_signature__: {
                            version: '2.0',
                            created: now.toISOString(),
                            device: deviceName,
                            type: `MASTER_${typePrefix}`,
                            book_count: allBooks.length,
                            sources: sourceInfo
                        }
                    };

                    const masterName = `SL_MASTER_${typePrefix}_${deviceName}_${ts}.json`;
                    const masterJson = JSON.stringify([signature, ...allBooks]);

                    const txtLog = `========================================
ShelfLife Merge Log
========================================
Date: ${now.toLocaleString()}
Device: ${deviceName}
Mode: ${mergeMode.toUpperCase()}
----------------------------------------
SOURCE FILES:
${sourceInfo.map((s, i) => `${i + 1}. ${s.name} - ${s.count} books`).join('\n')}
----------------------------------------
RESULT:
Total Unique: ${allBooks.length}
Duplicates Found: ${duplicates.length}
Mode Action: ${mergeMode === 'merge' ? 'Tagged as duplicate' : 'Skipped'}
========================================`;

                    // Platform-specific file saving
                    if (isTauri()) {
                        // Tauri: Save As dialog
                        try {
                            const { save } = window.__TAURI__.dialog;
                            const { writeTextFile } = window.__TAURI__.fs;

                            const filePath = await save({
                                defaultPath: masterName,
                                filters: [{ name: 'JSON', extensions: ['json'] }]
                            });

                            if (filePath) {
                                await writeTextFile(filePath, masterJson);
                                // Also save log file next to it
                                const logPath = filePath.replace(/\.json$/i, '_log.txt');
                                try { await writeTextFile(logPath, txtLog); } catch (e) { }

                                setStep('complete');
                                alert(`‚úÖ Merge Complete!\n\nMaster: ${masterName}\nBooks: ${allBooks.length}\nDuplicates: ${duplicates.length}\n\nSaved to: ${filePath}`);
                            }
                        } catch (tauriErr) {
                            console.error('Tauri save failed, falling back to download:', tauriErr);
                            // Fall through to browser download
                            const blob = new Blob([masterJson], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url; a.download = masterName;
                            document.body.appendChild(a); a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            setStep('complete');
                            alert(`‚úÖ Merge Complete!\n\nBooks: ${allBooks.length}\nDuplicates: ${duplicates.length}\n\nDownloaded: ${masterName}`);
                        }
                    } else if (isNativeCapacitor()) {
                        // Capacitor: Native filesystem
                        const { Filesystem } = window.Capacitor.Plugins;
                        const targetDir = Directory[baseStr] || Directory.Documents;
                        const sessionFolder = `ShelfLife/merge_${ts}`;

                        await Filesystem.mkdir({ path: sessionFolder, directory: targetDir, recursive: true });
                        await Filesystem.writeFile({ path: `${sessionFolder}/${masterName}`, directory: targetDir, data: masterJson, encoding: Encoding.UTF8 });
                        await Filesystem.writeFile({ path: `${sessionFolder}/merge_log.txt`, directory: targetDir, data: txtLog, encoding: Encoding.UTF8 });

                        const csvHeader = 'File,Date,Mode,Books,Output\n';
                        const csvRow = `"${sourceInfo.map(s => s.name).join('; ')}",${now.toISOString()},${mergeMode},${allBooks.length},"${masterName}"`;
                        await Filesystem.writeFile({ path: `${sessionFolder}/merge_report.csv`, directory: targetDir, data: csvHeader + csvRow, encoding: Encoding.UTF8 });

                        setStep('complete');
                        alert(`‚úÖ Merge Complete!\n\nMaster: ${masterName}\nBooks: ${allBooks.length}\nDuplicates: ${duplicates.length}\n\nSaved to: ${sessionFolder}`);
                    } else {
                        // Browser: Download file
                        const blob = new Blob([masterJson], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url; a.download = masterName;
                        document.body.appendChild(a); a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        setStep('complete');
                        alert(`‚úÖ Merge Complete!\n\nBooks: ${allBooks.length}\nDuplicates: ${duplicates.length}\n\nDownloaded: ${masterName}`);
                    }

                    // Reset
                    setFiles([]);
                    setSelectedFiles([]);
                    setStep('scan');

                } catch (e) {
                    alert("Merge Error: " + e.message);
                    setStep('preview');
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="space-y-3">
                    {step === 'scan' && (
                        <div className="text-center py-4">
                            <p className="text-sm text-gray-500 mb-3">
                                Select backup JSON files to merge
                            </p>
                            <label className="px-6 py-3 bg-purple-600 text-white rounded-lg font-bold flex items-center gap-2 mx-auto cursor-pointer hover:bg-purple-700 w-fit">
                                <Icon name="FolderOpen" size={18} />
                                {loading ? 'Loading...' : 'Merge backup files'}
                                <input
                                    type="file"
                                    accept=".json"
                                    multiple
                                    onChange={handleFilePick}
                                    disabled={loading}
                                    className="hidden"
                                />
                            </label>
                            <p className="text-xs text-gray-400 mt-2">Select one or more .json backup files</p>
                        </div>
                    )}

                    {step === 'preview' && (
                        <>
                            <div className="text-xs font-bold text-gray-500 uppercase mb-2">
                                {files.length} Files Found ‚Ä¢ {totalBooks} Total Books
                            </div>

                            <div className="max-h-48 overflow-y-auto space-y-2 border rounded p-2 bg-gray-50">
                                {files.map((f, i) => (
                                    <label key={i} className="flex items-center gap-2 p-2 bg-white rounded border cursor-pointer hover:bg-blue-50">
                                        <input
                                            type="checkbox"
                                            checked={selectedFiles.includes(i)}
                                            onChange={(e) => {
                                                if (e.target.checked) setSelectedFiles([...selectedFiles, i]);
                                                else setSelectedFiles(selectedFiles.filter(x => x !== i));
                                            }}
                                        />
                                        <div className="flex-1 min-w-0">
                                            <div className="font-bold text-sm truncate">{f.name}</div>
                                            {f.signature && (
                                                <div className="text-xs text-blue-600">
                                                    üì± {f.signature.device_nickname || 'Unknown'} ‚Ä¢ {f.signature.device_model || ''} {f.signature.device_manufacturer ? `(${f.signature.device_manufacturer})` : ''}
                                                </div>
                                            )}
                                            <div className="text-xs text-gray-500">
                                                {f.count} books ‚Ä¢ {f.hasImages ? 'üì∑ With Images' : 'üìù Text Only'}
                                            </div>
                                        </div>
                                    </label>
                                ))}
                            </div>

                            <div className="flex gap-2 flex-wrap">
                                <button
                                    onClick={() => setSelectedFiles(files.map((_, i) => i))}
                                    className="text-xs px-2 py-1 border rounded"
                                >All</button>
                                <button
                                    onClick={() => setSelectedFiles([])}
                                    className="text-xs px-2 py-1 border rounded"
                                >None</button>
                                <label className="text-xs px-2 py-1 border rounded bg-purple-50 text-purple-700 cursor-pointer hover:bg-purple-100">
                                    + Add More
                                    <input type="file" accept=".json" multiple onChange={handleFilePick} className="hidden" />
                                </label>
                                <button
                                    onClick={() => { setFiles([]); setSelectedFiles([]); setStep('scan'); }}
                                    className="text-xs px-2 py-1 border rounded bg-red-50 text-red-600 hover:bg-red-100"
                                >Clear All</button>
                            </div>

                            <div className="flex gap-2 mt-2">
                                <button
                                    onClick={() => setMergeMode('merge')}
                                    className={`flex-1 py-2 rounded text-sm font-bold ${mergeMode === 'merge' ? 'bg-purple-600 text-white' : 'bg-gray-100'}`}
                                >MERGE (Tag Dupes)</button>
                                <button
                                    onClick={() => setMergeMode('append')}
                                    className={`flex-1 py-2 rounded text-sm font-bold ${mergeMode === 'append' ? 'bg-purple-600 text-white' : 'bg-gray-100'}`}
                                >APPEND (Skip Dupes)</button>
                            </div>

                            <div className="flex gap-2 mt-3">
                                <button
                                    onClick={() => { setStep('scan'); setFiles([]); }}
                                    className="flex-1 py-2 border rounded font-bold text-gray-600"
                                >Cancel</button>
                                <button
                                    onClick={executeMerge}
                                    disabled={loading || selectedFiles.length === 0}
                                    className="flex-1 py-2 bg-green-600 text-white rounded font-bold disabled:opacity-50"
                                >
                                    {loading ? 'Processing...' : `Merge ${selectedFiles.length} Files`}
                                </button>
                            </div>
                        </>
                    )}

                    {step === 'processing' && (
                        <div className="text-center py-8">
                            <div className="w-10 h-10 border-4 border-purple-500 border-t-transparent rounded-full animate-spin mx-auto mb-3"></div>
                            <p className="text-sm text-gray-500">Processing merge...</p>
                        </div>
                    )}
                </div>
            );
        };

        // --- TAG MANAGER ---
        const TagManager = ({ books, onClose }) => {
            const tags = useMemo(() => { const t = {}; books.forEach(b => { if (b.tags) b.tags.forEach(x => t[x] = (t[x] || 0) + 1) }); return Object.entries(t).sort((a, b) => b[1] - a[1]); }, [books]);

            const handleRename = async (oldTag) => {
                const newTag = prompt(`Rename ${oldTag} to:`);
                if (!newTag || newTag === oldTag) return;
                const affected = books.filter(b => b.tags && b.tags.includes(oldTag));
                for (const b of affected) {
                    const newTags = b.tags.filter(t => t !== oldTag);
                    if (!newTags.includes(newTag)) newTags.push(newTag);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert("Tag Renamed!");
            };

            const handleMerge = async (oldTag) => {
                const target = prompt(`Merge #${oldTag} into existing tag (Books will move to new tag):`);
                if (!target || target === oldTag) return;
                const affected = books.filter(b => b.tags && b.tags.includes(oldTag));
                for (const b of affected) {
                    let newTags = b.tags.filter(t => t !== oldTag);
                    if (!newTags.includes(target)) newTags.push(target);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert(`Merged #${oldTag} -> #${target}`);
            };

            const handleDelete = async (tag) => {
                if (!confirm(`Delete tag "${tag}" from ${tags.find(t => t[0] === tag)[1]} books?`)) return;
                const affected = books.filter(b => b.tags && b.tags.includes(tag));
                for (const b of affected) {
                    let newTags = b.tags.filter(t => t !== tag);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert("Tag Deleted");
            };

            return (
                <div className="h-64 overflow-y-auto border rounded p-2">
                    {tags.length === 0 && <p className="text-sm text-gray-400">No tags used.</p>}
                    {tags.map(([t, c]) => (
                        <div key={t} className="flex justify-between p-2 border-b text-sm items-center">
                            <span><b>{t}</b> ({c})</span>
                            <div className="flex gap-2">
                                <button onClick={() => handleRename(t)} title="Rename" className="text-blue-500"><Icon name="Edit3" size={14} /></button>
                                <button onClick={() => handleMerge(t)} title="Merge" className="text-purple-500"><Icon name="Merge" size={14} /></button>
                                <button onClick={() => handleDelete(t)} title="Delete" className="text-red-500"><Icon name="Trash2" size={14} /></button>
                            </div>
                        </div>
                    ))}
                </div>
            );
        };

        // --- APP HEADER ---
        const AppHeader = ({ title = "ShelfLife" }) => (
            <div className="bg-blue-900 text-white p-4 shadow-md sticky top-0 z-50 flex items-center justify-between no-print">
                <div className="flex items-center gap-3">
                    <div className="bg-white/10 p-2 rounded-lg"><Icon name="Library" size={20} /></div>
                    <div>
                        <h1 className="font-bold text-lg leading-none">{title}</h1>
                        <p className="text-[10px] text-blue-200 opacity-80">Personal Library Manager</p>
                    </div>
                </div>
            </div>
        );

        // --- SETUP MODAL ---
        const SetupModal = ({ onComplete }) => {
            const [folder, setFolder] = useState('ShelfLife_Backups');
            const [base, setBase] = useState('DOCUMENTS');
            const [status, setStatus] = useState('');
            const [devName, setDevName] = useState(localStorage.getItem('shelfLife_deviceName') || '');
            const [detectedName, setDetectedName] = useState('');

            // Auto-detect device name from existing backups or hardware model
            useEffect(() => {
                const detectDeviceName = async () => {
                    if (!isNativeCapacitor()) return;
                    try {
                        const { Filesystem, Device } = window.Capacitor.Plugins;
                        const targetDir = Directory.Documents;

                        // Try to read existing backups
                        try {
                            const ret = await Filesystem.readdir({ path: 'ShelfLife_Backups', directory: targetDir });
                            const backupFile = (ret.files || []).find(f => f.name.match(/SL_(?:BK|FULL_BK|TXT_BK)_([A-Z0-9]+)_Part/));
                            if (backupFile) {
                                const match = backupFile.name.match(/SL_(?:BK|FULL_BK|TXT_BK)_([A-Z0-9]+)_Part/);
                                if (match) {
                                    setDetectedName(match[1]);
                                    if (!devName) setDevName(match[1]);
                                    return;
                                }
                            }
                        } catch (e) { /* No existing backups */ }

                        // Fallback: Use hardware model
                        if (Device) {
                            try {
                                const info = await Device.getInfo();
                                const hwName = (info.model || info.name || 'MYPHONE').toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 10);
                                setDetectedName(hwName);
                                if (!devName) setDevName(hwName);
                            } catch (e) {
                                if (!devName) setDevName('MYPHONE');
                            }
                        } else {
                            if (!devName) setDevName('MYPHONE');
                        }
                    } catch (e) {
                        if (!devName) setDevName('MYPHONE');
                    }
                };
                detectDeviceName();
            }, []);

            const requestPerms = async () => {
                if (!isNativeCapacitor()) return;
                try {
                    const { Filesystem, Camera } = window.Capacitor.Plugins;
                    setStatus('Requesting permissions...');
                    try { await Filesystem.requestPermissions(); } catch (e) { }
                    try { await Camera.requestPermissions(); } catch (e) { }

                    // Save Prefs
                    localStorage.setItem('shelfLife_backupFolder', folder);
                    localStorage.setItem('shelfLife_backupBase', base);
                    localStorage.setItem('shelfLife_deviceName', devName || 'MYPHONE');

                    // Test Create with Force Write
                    const targetDir = Directory[base] || Directory.Documents;
                    try {
                        // Create main folder (ignore if exists)
                        try {
                            await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true });
                        } catch (mkdirErr) {
                            // Folder exists is OK, continue
                            console.log('Main folder mkdir:', mkdirErr.message);
                        }

                        // Create to_merge subfolder (ignore if exists)
                        try {
                            await Filesystem.mkdir({ path: `${folder}/to_merge`, directory: targetDir, recursive: true });
                        } catch (mkdirErr) {
                            console.log('to_merge folder mkdir:', mkdirErr.message);
                        }

                        // Create a test file to REALLY verify write access
                        await Filesystem.writeFile({
                            path: `${folder}/.test_marker`,
                            data: 'Setup Complete ' + new Date().toISOString(),
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        // Clean up
                        try { await Filesystem.deleteFile({ path: `${folder}/.test_marker`, directory: targetDir }); } catch (e) { }

                        setStatus('Permissions Granted & Folder Verified!');
                    } catch (e) {
                        setStatus('Error: ' + e.message);
                        alert("Folder Creation Failed.\nTry changing 'Storage Location' to External, or use a different folder name.");
                    }
                } catch (e) {
                    setStatus('Setup Error: ' + e.message);
                }
            };

            return (
                <div className="fixed inset-0 bg-black/80 z-[100] flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl p-6 w-full max-w-sm shadow-2xl animate-[fadeIn_0.3s_ease-out]">
                        <div className="text-center mb-6">
                            <div className="inline-block p-4 bg-blue-100 rounded-full text-blue-600 mb-3"><Icon name="Library" size={32} /></div>
                            <h2 className="text-xl font-bold text-gray-800">Welcome to ShelfLife</h2>
                            <p className="text-sm text-gray-500 mt-1">Let's set up your secure storage.</p>
                        </div>

                        <div className="space-y-4">
                            <div className="border-b pb-4 mb-4">
                                <label className="block text-xs font-bold text-gray-700 uppercase mb-1">Device Nickname</label>
                                <input
                                    className="w-full p-3 border rounded-lg bg-gray-50 focus:ring-2 focus:ring-blue-500 outline-none transition-all uppercase"
                                    maxLength={10}
                                    placeholder="MYPHONE"
                                    value={devName}
                                    onChange={(e) => {
                                        const val = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                                        setDevName(val);
                                    }}
                                />
                                {detectedName && <p className="text-[10px] text-blue-500 mt-1">Auto-detected from existing backups: {detectedName}</p>}
                                <p className="text-[10px] text-gray-400 mt-1">Backup filename: SL_BK_{devName || 'MYPHONE'}_Part1_...</p>
                            </div>


                            {isNativeCapacitor() && <div>
                                <label className="block text-xs font-bold text-gray-700 uppercase mb-1">Storage Location</label>
                                <div className="flex gap-2">
                                    <select className="p-3 border rounded-lg bg-gray-50 text-xs font-bold" value={base} onChange={e => setBase(e.target.value)}>
                                        <option value="DOCUMENTS">Documents/</option>
                                        <option value="EXTERNAL_STORAGE">External/</option>
                                    </select>
                                    <input
                                        className="flex-1 p-3 border rounded-lg bg-gray-50 focus:ring-2 focus:ring-blue-500 outline-none transition-all"
                                        value={folder}
                                        onChange={e => setFolder(e.target.value)}
                                        placeholder="FolderName"
                                    />
                                </div>
                                <p className="text-[10px] text-gray-400 mt-1">Files will be saved to: {base}/{folder}/</p>
                            </div>}

                            {isNativeCapacitor() && <button onClick={requestPerms} className="w-full py-2 bg-gray-100 hover:bg-gray-200 text-gray-800 font-bold rounded-lg border border-gray-300 text-xs">
                                üîì Grant Storage Permissions & Test
                            </button>}
                            {status && <div className={`text-center text-[10px] font-bold p-1 rounded ${status.includes('Error') ? 'text-red-600 bg-red-50' : 'text-green-600 bg-green-50'}`}>{status}</div>}

                            <button onClick={onComplete} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-lg transform transition active:scale-95">
                                Start Using App
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- APP ROOT ---
        const App = () => {
            const [view, setView] = useState('library');
            const [books, setBooks] = useState([]);
            const [editBook, setEditBook] = useState(null);
            const [currency, setCurrency] = useState(() => localStorage.getItem('shelfLife_currency') || '‚Çπ');
            const [showSetup, setShowSetup] = useState(false);

            useEffect(() => {
                // Startup Check for Folder
                if (!localStorage.getItem('shelfLife_backupFolder')) {
                    setShowSetup(true);
                }

                const l = async () => {
                    await migrateAuthors();
                    await migrateLanguage();
                    setBooks(await db.books.toArray());
                };
                l();
                setInterval(async () => setBooks(await db.books.toArray()), 1000);

                // Android Back Button & Permissions Logic
                try {
                    if (isNativeCapacitor()) {
                        const { App } = window.Capacitor.Plugins;
                        // Handle Back Button
                        App.addListener('backButton', ({ canGoBack }) => {
                            if (canGoBack) {
                                window.history.back();
                            } else {
                                if (confirm('Do you want to exit ShelfLife?')) {
                                    App.exitApp();
                                }
                            }
                        });

                        // Request Permissions
                        (async () => {
                            try {
                                const { Filesystem } = window.Capacitor.Plugins;
                                await Filesystem.readdir({ path: 'Documents', directory: Directory.External }).catch(() => { });
                            } catch (e) { console.log("Perms check silent fail", e); }
                        })();

                        console.log("Native listeners active");

                        // Exit confirmation on back button
                        const CapApp = window.Capacitor.Plugins.App;
                        if (CapApp && CapApp.addListener) {
                            CapApp.addListener('backButton', ({ canGoBack }) => {
                                if (!canGoBack) {
                                    if (confirm("Do you want to exit ShelfLife?")) {
                                        CapApp.exitApp();
                                    }
                                } else {
                                    window.history.back();
                                }
                            });
                        }
                    }
                } catch (e) { console.error("Native setup error", e); }

            }, []);

            // Pull-to-refresh REMOVED in v2.5 - redundant with 1-second auto-refresh and disruptive full-page reload

            useEffect(() => {
                localStorage.setItem('shelfLife_currency', currency);
            }, [currency]);

            // Save Logic
            const save = async (inputData) => {
                const d = { ...inputData };

                // Enforce Title Case
                ['title', 'author', 'publisher', 'series', 'owner', 'building', 'shelf'].forEach(k => {
                    if (d[k] && typeof d[k] === 'string') d[k] = toTitleCase(d[k].trim());
                });
                if (d.tags && Array.isArray(d.tags)) {
                    d.tags = d.tags.map(t => toTitleCase(t));
                }

                try {
                    if (d.id) await db.books.put(d);
                    else {
                        await db.books.add({ ...d, date_added: Date.now() });

                        // Track entries since backup for reminder
                        const count = parseInt(localStorage.getItem('shelfLife_entriesSinceBackup') || '0') + 1;
                        localStorage.setItem('shelfLife_entriesSinceBackup', count.toString());
                    }
                    setEditBook(null);
                    setView('library');

                    // Check if backup reminder needed
                    const lastBackup = localStorage.getItem('shelfLife_lastBackupDate');
                    const entriesSince = parseInt(localStorage.getItem('shelfLife_entriesSinceBackup') || '0');
                    const daysSince = lastBackup ? Math.floor((Date.now() - new Date(lastBackup).getTime()) / 86400000) : 999;

                    if ((daysSince >= 7 || entriesSince >= 10) && !sessionStorage.getItem('backupReminderShown')) {
                        sessionStorage.setItem('backupReminderShown', 'true');
                        setTimeout(() => {
                            if (confirm(`Backup Reminder:\n${entriesSince} new entries since last backup.\nWould you like to backup now?`)) {
                                setView('settings');
                            }
                        }, 1000);
                    }
                } catch (err) {
                    alert("Database Error: " + err.message + "\nCheck storage space?");
                }
            };

            const deleteMulti = async (ids) => { if (confirm(`Delete ${ids.length} books?`)) { await db.books.bulkDelete(ids); } };

            if (editBook || view === 'add') return (
                <div className="max-w-md mx-auto min-h-screen bg-gray-50">
                    <AppHeader />
                    <BookForm book={editBook} onSave={save} onCancel={() => { setEditBook(null); setView('library') }} onBarcodeFound={(b) => { setEditBook(b); setView('add') }} globalCurrency={currency} books={books} />
                </div>
            );

            return (
                <div className="max-w-md mx-auto min-h-screen bg-gray-50 shadow-2xl relative overflow-hidden">
                    {showSetup && <SetupModal onComplete={() => setShowSetup(false)} />}

                    <AppHeader />

                    <main className="p-4 pb-24 safe-area-top">
                        {view === 'library' && <LibraryView books={books} onEdit={(b) => { setEditBook(b); }} onDeleteMulti={deleteMulti} />}
                        {view === 'search' && <SlicerSearch books={books} onEdit={(b) => { setEditBook(b); setView('add') }} />}
                        {view === 'reports' && <Dashboard books={books} onNavigateToSlicer={(field, value) => {
                            // Set the slicer filter in sessionStorage and navigate
                            sessionStorage.setItem('shelfLife_slicerFilters', JSON.stringify([{ field, value }]));
                            setView('search');
                        }} />}
                        {view === 'settings' && <Tools books={books} currency={currency} setCurrency={setCurrency} />}
                    </main>

                    <nav className="fixed bottom-0 w-full max-w-md bg-white border-t flex justify-around py-3 pb-safe z-30 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                        <button onClick={() => setView('library')} className={view === 'library' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Library" /><span className="block text-[10px]">Lib</span></button>
                        <button onClick={() => setView('search')} className={view === 'search' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Search" /><span className="block text-[10px]">Search</span></button>
                        <button onClick={() => setView('add')} className={view === 'add' ? 'text-blue-600' : 'text-gray-400'}><Icon name="PlusSquare" /><span className="block text-[10px]">Add</span></button>
                        <button onClick={() => setView('reports')} className={view === 'reports' ? 'text-blue-600' : 'text-gray-400'}><Icon name="BarChart2" /><span className="block text-[10px]">Stats</span></button>
                        <button onClick={() => setView('settings')} className={view === 'settings' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Settings" /><span className="block text-[10px]">Tools</span></button>
                    </nav>
                </div>
            );
        };

        // Platform Mode Detection for CSS Styling (e.g. Text Selection)
        if (!isNativeCapacitor()) {
            document.body.classList.add('is-pwa');
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>

</html>