<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Home Library by Anees</title>

    <!-- PWA MANIFEST (Embedded) -->
    <link rel="manifest"
        href="data:application/manifest+json;base64,ewogICAgIm5hbWUiOiAiU2hlbGZMaWZlIFVsdGltYXRlIiwKICAgICJzaG9ydF9uYW1lIjogIlNoZWxZTGlmZSIsCiAgICAic3RhcnRfdXJsIjogIi4iLAogICAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgICAiYmFja2dyb3VuZF9jb2xvciI6ICIjZjNmNGY2IiwKICAgICJ0aGVtZV9jb2xvciI6ICIjMjU2M2ViIiwKICAgICJpY29ucyI6IFtdCn0=">

    <!-- OFFLINE LIBRARIES (Downloaded via Cloud Build) -->
    <script src="libs/react.js"></script>
    <script src="libs/react-dom.js"></script>
    <script src="libs/babel.min.js"></script>
    <script src="libs/tailwindcss.js"></script>
    <script src="libs/dexie.js"></script>
    <script src="libs/html5-qrcode.min.js"></script>
    <script src="libs/jszip.min.js"></script>

    <!-- OFFLINE FONTS (Bundled in APK) -->
    <style>
        @font-face {
            font-family: 'Noto Sans';
            font-weight: 400;
            src: url('fonts/NotoSans-Regular.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Noto Sans';
            font-weight: 700;
            src: url('fonts/NotoSans-Bold.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Noto Sans Malayalam';
            src: url('fonts/NotoSansMalayalam.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Noto Sans Arabic';
            src: url('fonts/NotoSansArabic.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Noto Sans Devanagari';
            src: url('fonts/NotoSansDevanagari.woff2') format('woff2');
        }
    </style>

    <style>
        body {
            font-family: 'Noto Sans', sans-serif;
            background-color: #f3f4f6;
            overscroll-behavior: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .font-ml {
            font-family: 'Noto Sans Malayalam', sans-serif;
        }

        .font-ar {
            font-family: 'Noto Sans Arabic', sans-serif;
        }

        .font-hi {
            font-family: 'Noto Sans Devanagari', sans-serif;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .pie-chart {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: conic-gradient(var(--pie-gradient));
        }

        /* Disable overscroll in modal overlays (prevent native pull-to-refresh) */
        .modal-overlay {
            overscroll-behavior: none !important;
            /* Note: touch-action handled by JS isModalOpen() check */
        }

        /* Allow scrolling inside modal content but prevent overscroll */
        .modal-content {
            overscroll-behavior: contain;
        }

        /* Pull to Refresh Spinner */
        #ptr-spinner {
            position: fixed;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: top 0.3s ease;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="ptr-spinner">
        <div className="spinner"></div>
    </div>
    <div id="root"></div>

    <script>
        // --- SERVICE WORKER REGISTRATION (Robust for PWA) ---
        if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || window.location.hostname === 'localhost')) {
            const swCode = `
        const CACHE_NAME = 'shelflife-v2';
        const FILES_TO_CACHE = [
            './',
            'https://unpkg.com/react@18/umd/react.development.js',
            'https://unpkg.com/react-dom@18/umd/react-dom.development.js',
            'https://unpkg.com/@babel/standalone/babel.min.js',
            'https://cdn.tailwindcss.com',
            'https://unpkg.com/dexie@3.2.4/dist/dexie.js',
            'https://unpkg.com/html5-qrcode',
            'https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&family=Noto+Sans+Malayalam&family=Noto+Sans+Arabic&family=Noto+Sans+Devanagari&display=swap'
        ];
        
        self.addEventListener('install', (evt) => {
            evt.waitUntil(
                caches.open(CACHE_NAME).then((cache) => {
                    return cache.addAll(FILES_TO_CACHE).catch(err => console.log('Cache error:', err));
                })
            );
            self.skipWaiting();
        });

        self.addEventListener('activate', (evt) => {
            evt.waitUntil(self.clients.claim());
        });

        self.addEventListener('fetch', (evt) => {
            evt.respondWith(
                caches.match(evt.request).then((resp) => {
                    return resp || fetch(evt.request).catch(() => new Response("Offline"));
                })
            );
        });
    `;

            // Create blob URL for SW
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);

            navigator.serviceWorker.register(swUrl)
                .then((reg) => console.log('SW Registered'))
                .catch((err) => console.log('SW Failed:', err));
        }
    </script>



    <script type="text/babel">

        // ==========================================
        // 1. UTILITIES
        // ==========================================

        const ImageUtils = {
            // Process image with proper memory cleanup
            process: (file, maxWidth = 500, quality = 0.65) => new Promise((resolve, reject) => {
                // Validate file size (max 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    reject(new Error('Image too large. Max 10MB allowed.'));
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();

                    // Cleanup function for Image object
                    const cleanup = () => {
                        img.onload = null;
                        img.onerror = null;
                        img.src = '';
                    };

                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            let w = img.width, h = img.height;

                            // More aggressive resizing for memory savings
                            if (w > maxWidth) {
                                h = Math.round(h * (maxWidth / w));
                                w = maxWidth;
                            }

                            canvas.width = w;
                            canvas.height = h;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, w, h);

                            // Use WebP for smaller size
                            const result = canvas.toDataURL('image/webp', quality);

                            // Cleanup canvas
                            canvas.width = 0;
                            canvas.height = 0;
                            cleanup();

                            resolve(result);
                        } catch (err) {
                            cleanup();
                            reject(err);
                        }
                    };

                    img.onerror = (err) => {
                        cleanup();
                        reject(new Error('Failed to load image'));
                    };

                    img.src = e.target.result;
                };

                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            }),

            // Create smaller thumbnail for list view (optimize memory)
            createThumbnail: (base64, maxSize = 100) => new Promise((resolve) => {
                if (!base64 || base64 === 'loading') {
                    resolve(null);
                    return;
                }

                const img = new Image();
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        let w = img.width, h = img.height;

                        if (w > h) {
                            h = Math.round(h * (maxSize / w));
                            w = maxSize;
                        } else {
                            w = Math.round(w * (maxSize / h));
                            h = maxSize;
                        }

                        canvas.width = w;
                        canvas.height = h;
                        canvas.getContext('2d').drawImage(img, 0, 0, w, h);

                        const result = canvas.toDataURL('image/webp', 0.5);
                        canvas.width = 0;
                        canvas.height = 0;
                        img.src = '';
                        resolve(result);
                    } catch {
                        resolve(base64); // Fallback to original
                    }
                };
                img.onerror = () => resolve(null);
                img.src = base64;
            }),

            // Compress data URL (for Capacitor Camera output)
            compressDataUrl: (dataUrl, maxWidth = 500, quality = 0.65) => new Promise((resolve, reject) => {
                if (!dataUrl) {
                    resolve(null);
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        let w = img.width, h = img.height;
                        if (w > maxWidth) {
                            h = Math.round(h * (maxWidth / w));
                            w = maxWidth;
                        }
                        canvas.width = w;
                        canvas.height = h;
                        canvas.getContext('2d').drawImage(img, 0, 0, w, h);
                        const result = canvas.toDataURL('image/webp', quality);
                        canvas.width = 0;
                        canvas.height = 0;
                        img.src = '';
                        resolve(result);
                    } catch (err) {
                        resolve(dataUrl); // Fallback
                    }
                };
                img.onerror = () => resolve(dataUrl);
                img.src = dataUrl;
            })
        };

        // Initialize Capacitor Enums globally for script usage
        const Directory = {
            Documents: 'DOCUMENTS',
            Data: 'DATA',
            Cache: 'CACHE',
            External: 'EXTERNAL', // often maps to generic external storage
            ExternalStorage: 'EXTERNAL_STORAGE' // Android specific
        };

        const Encoding = {
            UTF8: 'utf8',
            ASCII: 'ascii',
            UTF16: 'utf16'
        };

        const ExportUtils = {
            getTimestamp: () => {
                const now = new Date();
                return now.toISOString().replace(/[:.]/g, '-').slice(0, 16);
            },
            download: async (content, name, mimeType, specificFolder = null, specificBase = null) => {
                if (window.Capacitor) {
                    try {
                        const { Filesystem } = window.Capacitor.Plugins;
                        // Use specific folder if provided, else default to ShelfLife/Exports
                        const folder = specificFolder || 'ShelfLife/Exports';
                        const baseStr = specificBase || localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';

                        // Map string to Directory Constant
                        // Note: We use global Directory object defined above
                        const targetDir = Directory[baseStr] || Directory.Documents;

                        // Ensure folder exists
                        try {
                            await Filesystem.mkdir({
                                path: folder, // Write relative to Base (e.g. Documents/ShelfLife)
                                directory: targetDir,
                                recursive: true
                            });
                        } catch (e) { }

                        const cleanPath = folder ? `${folder}/${name}` : name;

                        await Filesystem.writeFile({
                            path: cleanPath,
                            data: content,
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        alert(`Saved to: ${baseStr}/${cleanPath}`);
                    } catch (e) {
                        console.error(e);
                        alert("Save failed. " + e.message);
                    }
                } else {
                    // Browser Download
                    try {
                        let dataUri = '';
                        if (mimeType === 'application/json' || mimeType.includes('text')) {
                            // Use UTF-8 BOM only for CSV to assist Excel opening
                            const prefix = mimeType.includes('csv') ? "\uFEFF" : "";
                            const base64 = btoa(unescape(encodeURIComponent(prefix + content)));
                            dataUri = `data:${mimeType};base64,${base64}`;
                        } else {
                            dataUri = content;
                        }
                        const a = document.createElement('a');
                        a.href = dataUri;
                        a.download = name;
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => document.body.removeChild(a), 100);
                    } catch (e) {
                        alert("Export failed: " + e.message);
                    }
                }
            },
            csv: (books, filenamePrefix = "ShelfLife_Export", specificFolder = null, specificBase = null) => {
                const folder = specificFolder || 'ShelfLife/Exports';
                const base = specificBase || localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS';

                const maxTags = books.reduce((max, b) => Math.max(max, (b.tags || []).length), 0);
                let header = "Title,AuthorName,AuthorInitials,Publisher,Year,Pages,Condition,Price,Currency,Owner,Building,Shelf,ISBN,Status";
                for (let i = 1; i <= maxTags; i++) header += `,Tag_${i}`;
                header += "\n";
                const rows = books.map(b => {
                    const core = `"${(b.title || '').replace(/"/g, '""')}","${(b.author_name || b.author || '').replace(/"/g, '""')}","${(b.author_initials || '').replace(/"/g, '""')}","${(b.publisher || '').replace(/"/g, '""')}","${b.pub_year || ''}","${b.page_count || ''}","${b.condition || ''}","${b.price || ''}","${b.currency || ''}","${b.owner || ''}","${b.building || ''}","${b.shelf || ''}","${b.isbn || ''}","${b.status || ''}"`;
                    const tags = (b.tags || []);
                    const tagCells = Array.from({ length: maxTags }, (_, i) => `"${(tags[i] || '').replace(/"/g, '""')}"`).join(',');
                    return `${core},${tagCells}`;
                }).join('\n');

                // Sanitize filename
                const safePrefix = filenamePrefix.replace(/[^a-z0-9_]/gi, '_');
                const timestamp = ExportUtils.getTimestamp().replace(/[-:]/g, ''); // Compact timestamp
                ExportUtils.download("\uFEFF" + header + rows, `${safePrefix}_${timestamp}.csv`, "text/csv;charset=utf-8", folder, base);
            },
            htmlText: (books, type, title = "Library Inventory", specificFolder = null, specificBase = null) => {
                const folder = specificFolder || 'ShelfLife/Exports';
                const base = specificBase || localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS';

                let html = `<html><head><meta charset="UTF-8"><style>body{font-family:sans-serif;padding:20px;} table{width:100%;border-collapse:collapse;} th,td{border:1px solid #ddd;padding:8px;} th{background:#f3f3f3;} tr:nth-child(even){background:#f9f9f9;}</style></head><body><h1>${title}</h1><table><tr><th>Title</th><th>Author</th><th>Publisher</th><th>Year</th><th>Loc</th><th>Cond</th><th>Price</th></tr>${books.map(b => `<tr><td>${b.title}</td><td>${b.author_name || b.author} ${b.author_initials || ''}</td><td>${b.publisher}</td><td>${b.pub_year}</td><td>${b.building} ${b.shelf}</td><td>${b.condition}</td><td>${b.currency || ''} ${b.price}</td></tr>`).join('')}</table></body></html>`;
                ExportUtils.download(html, `ShelfLife_List_${ExportUtils.getTimestamp()}.html`, "text/html;charset=utf-8", folder, base);
            },
            htmlVisual: (books, type, title = "Visual Catalogue", specificFolder = null, specificBase = null) => {
                const folder = specificFolder || 'ShelfLife/Exports';
                const base = specificBase || localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS';

                let html = `<html><head><meta charset="UTF-8"><style>body{font-family:sans-serif;padding:20px;} .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:20px;} .card{border:1px solid #ddd;padding:10px;text-align:center;border-radius:8px;} img{width:100%;height:150px;object-fit:cover;margin-bottom:10px;border-radius:4px;} .meta{font-size:12px;color:#666;}</style></head><body><h1>${title}</h1><div class="grid">${books.map(b => `<div class="card">${b.front ? `<img src="${b.front}"/>` : ''}<b>${b.title}</b><br><small>${b.author_name || b.author} ${b.author_initials || ''}</small><br><span class="meta">${b.publisher} • ${b.pub_year}</span></div>`).join('')}</div></body></html>`;
                ExportUtils.download(html, `ShelfLife_Visual_${ExportUtils.getTimestamp()}.html`, "text/html;charset=utf-8", folder, base);
            },

            // Export all book cover images to multiple independent ZIP files
            // Each ZIP is standalone and extractable independently
            // onProgress: (current, total, message) => void
            imagesZip: async (books, onProgress = () => { }) => {
                if (!window.JSZip) {
                    alert("JSZip library not loaded. Cannot export images.");
                    return { success: false, error: "JSZip not available" };
                }
                if (!window.Capacitor) {
                    alert("Export Images to ZIP requires Android App.");
                    return { success: false, error: "Native FS required" };
                }

                const { Filesystem } = window.Capacitor.Plugins;
                const MAX_IMAGES_PER_ZIP = 150;
                const MAX_SIZE_PER_ZIP = 100 * 1024 * 1024; // 100MB per ZIP

                // Collect all images with metadata
                const allImages = [];
                const filenameCounts = {};

                for (const book of books) {
                    const safeTitle = (book.title || 'Unknown').replace(/[^a-z0-9\s]/gi, '').replace(/\s+/g, '_').slice(0, 50);
                    if (book.front && book.front.startsWith('data:image')) {
                        allImages.push({ title: safeTitle, type: 'front', data: book.front, size: Math.round(book.front.length * 0.75) });
                    }
                    if (book.back && book.back.startsWith('data:image')) {
                        allImages.push({ title: safeTitle, type: 'back', data: book.back, size: Math.round(book.back.length * 0.75) });
                    }
                    if (book.spine && book.spine.startsWith('data:image')) {
                        allImages.push({ title: safeTitle, type: 'spine', data: book.spine, size: Math.round(book.spine.length * 0.75) });
                    }
                }

                if (allImages.length === 0) {
                    alert("No images found in your library.");
                    return { success: false, error: "No images" };
                }

                const totalSize = allImages.reduce((sum, img) => sum + img.size, 0);
                const estimatedParts = Math.max(1, Math.ceil(allImages.length / MAX_IMAGES_PER_ZIP), Math.ceil(totalSize / MAX_SIZE_PER_ZIP));

                if (estimatedParts > 1) {
                    const sizeMB = Math.round(totalSize / (1024 * 1024));
                    if (!confirm(`Total: ${allImages.length} images (~${sizeMB}MB)\nWill create ${estimatedParts} independent ZIP files.\n\nContinue?`)) {
                        return { success: false, error: "User cancelled" };
                    }
                }

                onProgress(0, allImages.length, `Starting export of ${allImages.length} images...`);

                const deviceName = localStorage.getItem('shelfLife_deviceName') || 'MYPHONE';
                const now = new Date();
                const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
                const baseFilename = `${deviceName}_Images_${dateStr}`;

                const folder = 'ShelfLife/Exports';
                const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                const targetDir = Directory[baseStr] || Directory.Documents;
                try { await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true }); } catch (e) { }

                const savedFiles = [];
                let processedCount = 0;
                let partNumber = 1;
                let currentZip = new JSZip();
                let currentZipSize = 0;
                let currentZipImageCount = 0;

                try {
                    for (let i = 0; i < allImages.length; i++) {
                        const img = allImages[i];
                        const baseFn = `${img.title}_${img.type}`;
                        if (!filenameCounts[baseFn]) filenameCounts[baseFn] = 0;
                        filenameCounts[baseFn]++;
                        const filename = filenameCounts[baseFn] > 1 ? `${baseFn}_${filenameCounts[baseFn]}.jpg` : `${baseFn}.jpg`;

                        currentZip.file(filename, img.data.split(',')[1], { base64: true });
                        currentZipSize += img.size;
                        currentZipImageCount++;
                        processedCount++;
                        onProgress(processedCount, allImages.length, `Adding: ${filename}`);

                        const isLast = i === allImages.length - 1;
                        const shouldSave = isLast || currentZipImageCount >= MAX_IMAGES_PER_ZIP || currentZipSize >= MAX_SIZE_PER_ZIP;

                        if (shouldSave && currentZipImageCount > 0) {
                            const zipFilename = estimatedParts > 1 || savedFiles.length > 0 ? `${baseFilename}_Part${partNumber}.zip` : `${baseFilename}.zip`;
                            onProgress(processedCount, allImages.length, `Compressing Part ${partNumber}...`);

                            const zipBlob = await currentZip.generateAsync({ type: "base64", compression: "DEFLATE", compressionOptions: { level: 6 } }, (m) => {
                                onProgress(processedCount, allImages.length, `Compressing Part ${partNumber}: ${Math.round(m.percent)}%`);
                            });

                            await Filesystem.writeFile({ path: `${folder}/${zipFilename}`, data: zipBlob, directory: targetDir });
                            savedFiles.push({ filename: zipFilename, imageCount: currentZipImageCount, sizeMB: Math.round((zipBlob.length * 0.75) / (1024 * 1024)) });

                            if (!isLast) {
                                currentZip = new JSZip();
                                currentZipSize = 0;
                                currentZipImageCount = 0;
                                partNumber++;
                            }
                            await new Promise(r => requestAnimationFrame(r));
                        }
                    }

                    onProgress(allImages.length, allImages.length, "Complete!");
                    return { success: true, files: savedFiles, totalImages: allImages.length, totalParts: savedFiles.length, folder: `${baseStr}/${folder}` };

                } catch (error) {
                    console.error("Image ZIP export failed:", error);
                    return { success: false, error: error.message || "Export failed", partialFiles: savedFiles };
                }
            }
        };

        const ICONS = {
            Library: `<path d="m16 6 4 14"/><path d="M12 6v14"/><path d="M8 8v12"/><path d="M4 4v16"/>`,
            PlusSquare: `<rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/><path d="M12 8v8"/>`,
            BarChart2: `<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>`,
            Settings: `<path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/>`,
            Search: `<circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/>`,
            Edit3: `<path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/>`,
            Book: `<path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>`,
            Camera: `<path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/>`,
            FileText: `<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/>`,
            List: `<line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/>`,
            Image: `<rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>`,
            Download: `<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/>`,
            X: `<path d="M18 6 6 18"/><path d="m6 6 12 12"/>`,
            MapPin: `<path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/>`,
            AlertCircle: `<circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/>`,
            Trash2: `<path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/>`,
            Eye: `<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>`,
            Plus: `<path d="M5 12h14"/><path d="M12 5v14"/>`,
            Upload: `<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/>`,
            Filter: `<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>`,
            Barcode: `<path d="M3 5v14"/><path d="M8 5v14"/><path d="M12 5v14"/><path d="M17 5v14"/><path d="M21 5v14"/>`,
            CheckSquare: `<polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>`,
            Mic: `<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="23"/><line x1="8" x2="16" y1="23" y2="23"/>`,
            Grid: `<rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/>`,
            LayoutList: `<rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/><path d="M14 4h7"/><path d="M14 9h7"/><path d="M14 15h7"/><path d="M14 20h7"/>`,
            Merge: `<path d="m8 6 4-4 4 4"/><path d="M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22"/><path d="m20 22-5-5"/>`,
            Minus: `<path d="M5 12h14"/>`,
            ChevronUp: `<path d="m18 15-6-6-6 6"/>`,
            ChevronDown: `<path d="m6 9 6 6 6-6"/>`,
            Tag: `<path d="M12 2H2v10l9.29 9.29c.94.94 2.48.94 3.42 0l6.58-6.58c.94-.94.94-2.48 0-3.42L12 2Z"/><path d="M7 7h.01"/>`
        };

        const Icon = ({ name, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={`lucide lucide-${name} ${className}`} dangerouslySetInnerHTML={{ __html: ICONS[name] || ICONS['Book'] }} />
        );

        // --- TRANSLITERATION ---
        const TRANSLITERATE_MAP = {
            'അ': 'a', 'आ': 'aa', 'ഇ': 'i', 'ഈ': 'ee', 'ഉ': 'u', 'ഊ': 'oo', 'എ': 'e', 'ഏ': 'ea', 'ഐ': 'ai', 'ഒ': 'o', 'ഓ': 'oa', 'ഔ': 'au', 'ം': 'm', 'ക': 'ka', 'ഖ': 'kha', 'ഗ': 'ga', 'ഘ': 'gha', 'ങ': 'nga', 'ച': 'cha', 'ഛ': 'chha', 'ജ': 'ja', 'ഝ': 'jha', 'ഞ': 'nja', 'ട': 'ta', 'ഠ': 'ttha', 'ഡ': 'da', 'ഢ': 'ddha', 'ണ': 'na', 'ത': 'tha', 'ഥ': 'thha', 'ദ': 'da', 'ധ': 'dha', 'ന': 'na', 'പ': 'pa', 'ഫ': 'pha', 'ബ': 'ba', 'ഭ': 'bha', 'മ': 'ma', 'യ': 'ya', 'ര': 'ra', 'ല': 'la', 'വ': 'va', 'ശ': 'sha', 'ഷ': 'sha', 'സ': 'sa', 'ഹ': 'ha', 'ള': 'la', 'ഴ': 'zha', 'റ': 'ra', 'अ': 'a', 'आ': 'aa', 'इ': 'i', 'ई': 'ee', 'उ': 'u', 'ऊ': 'oo', 'ए': 'e', 'ऐ': 'ai', 'ओ': 'o', 'औ': 'au', 'ं': 'n', 'क': 'ka', 'ख': 'kha', 'ग': 'ga', 'घ': 'gha', 'च': 'cha', 'छ': 'chha', 'ज': 'ja', 'झ': 'jha', 'ट': 'ta', 'ठ': 'ttha', 'ड': 'da', 'ढ': 'ddha', 'ण': 'na', 'त': 'tha', 'थ': 'thha', 'द': 'da', 'ध': 'dha', 'न': 'na', 'प': 'pa', 'फ': 'pha', 'ब': 'ba', 'भ': 'bha', 'म': 'ma', 'य': 'ya', 'र': 'ra', 'ल': 'la', 'व': 'va', 'श': 'sha', 'ष': 'sha', 'स': 'sa', 'ह': 'ha'
        };
        const transliterate = (text) => text.split('').map(char => TRANSLITERATE_MAP[char] || char).join('');

        // ==========================================
        // 2. DATABASE
        // ==========================================
        const db = new Dexie("ShelfLife_Final_v40");
        // V1 Schema: Original
        db.version(1).stores({ books: "++id, title, phonetic, author, owner, publisher, language, building, shelf, status, date_added, isbn, page_count, condition, currency" });

        // V2: Add tags multi-entry index for Tag Manager
        db.version(2).stores({
            books: "++id, title, phonetic, author, owner, publisher, language, building, shelf, status, date_added, isbn, page_count, condition, currency, *tags"
        });

        // V2 Schema (Implied): Split Author
        // We use the same database name to keep it simple, but we handle the data migration in code.
        // On app load, we check and migrate "author" -> "author_name" + "author_initials"

        const migrateAuthors = async () => {
            const books = await db.books.toArray();
            let migratedCount = 0;
            const updates = [];

            for (const book of books) {
                if (book.author && !book.author_name) {
                    const parts = book.author.trim().split(' ');
                    let name = parts.pop() || '';
                    let initials = parts.join(' ') || '';

                    // IF single word, treat as Name, no initials
                    if (!initials && !name) { name = book.author; }

                    updates.push({
                        key: book.id,
                        changes: {
                            author: undefined, // Remove old
                            author_name: name,
                            author_initials: initials
                        }
                    });
                    migratedCount++;
                }
            }

            if (migratedCount > 0) {
                await db.transaction('rw', db.books, async () => {
                    for (const u of updates) {
                        await db.books.update(u.key, u.changes);
                    }
                });
                console.log(`Migrated ${migratedCount} books to new Author format.`);
            }
        };

        // Language Code to Full Name Map
        const LANG_MAP = {
            'en': 'English',
            'ml': 'Malayalam',
            'hi': 'Hindi',
            'ar': 'Arabic'
        };

        // Migrate lang code to full language name
        const migrateLanguage = async () => {
            const books = await db.books.toArray();
            let migratedCount = 0;

            for (const book of books) {
                if (book.lang && !book.language) {
                    await db.books.update(book.id, {
                        language: LANG_MAP[book.lang] || book.lang
                    });
                    migratedCount++;
                }
            }

            if (migratedCount > 0) {
                console.log(`Migrated ${migratedCount} books to new Language format.`);
            }
        };

        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        // AUTO-SUGGEST INPUT with viewport-aware dropdown (avoids keyboard)
        const AutoSuggestInput = ({ label, value, onChange, field, placeholder }) => {
            const [suggestions, setSuggestions] = useState([]);
            const [showDropdown, setShowDropdown] = useState(false);
            const [maxHeight, setMaxHeight] = useState(150);
            const [filteredSuggestions, setFilteredSuggestions] = useState([]);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Fetch suggestions from database
            useEffect(() => {
                db.books.toArray().then(all => {
                    const set = new Set(all.map(b => b[field]).filter(Boolean));
                    setSuggestions([...set].sort());
                });
            }, [field]);

            // Calculate dropdown height based on viewport
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 150;
                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20;
                return Math.max(80, Math.min(viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap, 200));
            }, []);

            // Filter suggestions based on input
            useEffect(() => {
                if (!value || value.length < 1) {
                    setFilteredSuggestions([]);
                    setShowDropdown(false);
                    return;
                }
                const q = value.toLowerCase();
                const filtered = suggestions.filter(s => s.toLowerCase().includes(q)).slice(0, 15);
                setFilteredSuggestions(filtered);
                setShowDropdown(filtered.length > 0);
            }, [value, suggestions]);

            // Recalculate height on viewport changes
            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());
                updateHeight();
                window.addEventListener('resize', updateHeight);
                window.visualViewport?.addEventListener('resize', updateHeight);
                return () => {
                    window.removeEventListener('resize', updateHeight);
                    window.visualViewport?.removeEventListener('resize', updateHeight);
                };
            }, [calculateMaxHeight]);

            // Close dropdown on outside click
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target) &&
                        inputRef.current && !inputRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            const selectSuggestion = (s) => {
                onChange({ target: { value: s } });
                setShowDropdown(false);
            };

            return (
                <div className="relative">
                    <label className="text-xs text-gray-500 font-bold">{label}</label>
                    <input
                        ref={inputRef}
                        className="w-full p-3 border rounded-lg"
                        value={value}
                        onChange={onChange}
                        placeholder={placeholder}
                        onFocus={() => filteredSuggestions.length > 0 && setShowDropdown(true)}
                    />
                    {showDropdown && filteredSuggestions.length > 0 && (
                        <div
                            ref={dropdownRef}
                            className="absolute left-0 right-0 top-full mt-1 bg-white border rounded-lg shadow-lg z-50 overflow-y-auto"
                            style={{ maxHeight: `${maxHeight}px` }}
                        >
                            {filteredSuggestions.map((s, i) => (
                                <div
                                    key={i}
                                    className="px-3 py-2 hover:bg-blue-50 cursor-pointer text-sm border-b last:border-b-0"
                                    onClick={() => selectSuggestion(s)}
                                >
                                    {s}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        // DYNAMIC SEARCH INPUT with viewport-aware dropdown (avoids keyboard)
        const DynamicSearchInput = ({ value, onChange, suggestions, placeholder, icon }) => {
            const [showDropdown, setShowDropdown] = useState(false);
            const [maxHeight, setMaxHeight] = useState(150);
            const [filteredSuggestions, setFilteredSuggestions] = useState([]);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Calculate max dropdown height based on available viewport space
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 150;

                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;

                // Estimate keyboard takes ~40% of screen on mobile
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20; // Gap above keyboard

                // Available space = from bottom of input to keyboard
                const available = viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap;

                // Clamp between 80px (min) and 250px (max)
                return Math.max(80, Math.min(available, 250));
            }, []);

            // Filter suggestions based on input
            useEffect(() => {
                if (!value || value.length < 1) {
                    setFilteredSuggestions([]);
                    setShowDropdown(false);
                    return;
                }

                const q = value.toLowerCase();
                const filtered = suggestions.filter(s =>
                    s.toLowerCase().includes(q)
                ).slice(0, 20); // Max 20 suggestions

                setFilteredSuggestions(filtered);
                setShowDropdown(filtered.length > 0);
            }, [value, suggestions]);

            // Recalculate height on viewport changes
            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());

                updateHeight();
                window.addEventListener('resize', updateHeight);
                window.visualViewport?.addEventListener('resize', updateHeight);

                return () => {
                    window.removeEventListener('resize', updateHeight);
                    window.visualViewport?.removeEventListener('resize', updateHeight);
                };
            }, [calculateMaxHeight]);

            // Close dropdown when clicking outside
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target) &&
                        inputRef.current && !inputRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            const selectSuggestion = (s) => {
                onChange({ target: { value: s } });
                setShowDropdown(false);
            };

            return (
                <div className="relative flex-1">
                    {icon && <Icon name={icon} className="absolute left-2 top-2 text-gray-400" size={14} />}
                    <input
                        ref={inputRef}
                        className={`w-full p-2 border rounded ${icon ? 'pl-8' : ''}`}
                        placeholder={placeholder}
                        value={value}
                        onChange={onChange}
                        onFocus={() => filteredSuggestions.length > 0 && setShowDropdown(true)}
                    />
                    {showDropdown && filteredSuggestions.length > 0 && (
                        <div
                            ref={dropdownRef}
                            className="absolute left-0 right-0 top-full mt-1 bg-white border rounded-lg shadow-lg z-50 overflow-y-auto"
                            style={{ maxHeight: `${maxHeight}px` }}
                        >
                            {filteredSuggestions.map((s, i) => (
                                <div
                                    key={i}
                                    className="px-3 py-2 hover:bg-blue-50 cursor-pointer text-sm border-b last:border-b-0"
                                    onClick={() => selectSuggestion(s)}
                                >
                                    {s}
                                </div>
                            ))}
                            {filteredSuggestions.length === 20 && (
                                <div className="px-3 py-1 text-xs text-gray-400 text-center bg-gray-50">
                                    Showing first 20 results
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // VOICE INPUT (Wrapped)
        const VoiceInput = ({ label, value, onChange, onVoice, isListening, lang, type = "text", placeholder }) => {
            return (
                <div className="relative">
                    <label className="text-xs text-gray-500 font-bold">{label}</label>
                    <div className="relative">
                        <input
                            type={type}
                            className="w-full p-3 border rounded-lg pr-10"
                            placeholder={placeholder}
                            value={value}
                            onChange={onChange}
                            lang={lang}
                        />
                        <button
                            type="button"
                            onClick={onVoice}
                            className={`absolute right-2 top-2 p-1 rounded-full ${isListening ? 'bg-red-500 text-white animate-pulse' : 'text-gray-400'}`}
                        >
                            <Icon name="Mic" size={20} />
                        </button>
                    </div>
                </div>
            );
        };

        // TAG TOKEN INPUT (Pills/Chips with Autocomplete)
        const TagTokenInput = ({ label, value = [], onChange, allBooks = [], placeholder = "Add tags..." }) => {
            const [input, setInput] = useState('');
            const [showDropdown, setShowDropdown] = useState(false);
            const [suggestions, setSuggestions] = useState([]);
            const [selectedIndex, setSelectedIndex] = useState(-1);
            const [maxHeight, setMaxHeight] = useState(150);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Calculate dropdown height based on viewport
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 150;
                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20;
                return Math.max(80, Math.min(viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap, 200));
            }, []);

            // Recalculate height on viewport changes
            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());
                updateHeight();
                window.visualViewport?.addEventListener('resize', updateHeight);
                return () => window.visualViewport?.removeEventListener('resize', updateHeight);
            }, [calculateMaxHeight]);

            // Extract all unique tags from library
            const allTags = useMemo(() => {
                const tagSet = new Set();
                allBooks.forEach(book => {
                    if (book.tags && Array.isArray(book.tags)) {
                        book.tags.forEach(tag => {
                            if (tag && tag.trim()) tagSet.add(tag.trim());
                        });
                    }
                });
                return Array.from(tagSet).sort();
            }, [allBooks]);

            // Filter suggestions based on input
            useEffect(() => {
                if (!input.trim()) {
                    setSuggestions([]);
                    setShowDropdown(false);
                    return;
                }

                const filtered = allTags.filter(tag =>
                    tag.toLowerCase().includes(input.toLowerCase()) &&
                    !value.includes(tag)
                );
                setSuggestions(filtered.slice(0, 8)); // Limit to 8 suggestions
                setShowDropdown(true); // Always show dropdown if input exists
                setSelectedIndex(-1);
            }, [input, allTags, value]);

            // Add tag (with Title Case formatting)
            const addTag = (tag) => {
                const formatted = toTitleCase(tag);
                if (!formatted || value.some(v => v.toLowerCase() === formatted.toLowerCase())) return;

                const newTags = [...value, formatted];
                onChange(newTags);
                setInput('');
                setShowDropdown(false);
                setSelectedIndex(-1);
                inputRef.current?.focus();
            };

            // Remove tag
            const removeTag = (indexToRemove) => {
                const newTags = value.filter((_, index) => index !== indexToRemove);
                onChange(newTags);
                inputRef.current?.focus();
            };

            // Keyboard navigation
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        addTag(suggestions[selectedIndex]);
                    } else if (input.trim()) {
                        addTag(input);
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setSelectedIndex(prev =>
                        prev < suggestions.length - 1 ? prev + 1 : prev
                    );
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setSelectedIndex(prev => prev > 0 ? prev - 1 : -1);
                } else if (e.key === 'Backspace' && !input && value.length > 0) {
                    removeTag(value.length - 1);
                } else if (e.key === 'Escape') {
                    setShowDropdown(false);
                    setSelectedIndex(-1);
                }
            };

            // Click outside to close dropdown
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            return (
                <div className="relative" ref={dropdownRef}>
                    <label className="text-xs text-gray-500 font-bold">{label}</label>
                    <div className="w-full p-2 border rounded-lg min-h-[44px] flex flex-wrap gap-2 items-center cursor-text"
                        onClick={() => inputRef.current?.focus()}>
                        {/* Tag Pills */}
                        {value.map((tag, index) => (
                            <div key={index}
                                className="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-medium">
                                <span>{tag}</span>
                                <button type="button"
                                    onClick={(e) => { e.stopPropagation(); removeTag(index); }}
                                    className="hover:bg-blue-200 rounded-full p-0.5 transition">
                                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>
                        ))}

                        {/* Input Field */}
                        <input
                            ref={inputRef}
                            type="text"
                            className="flex-1 min-w-[120px] outline-none bg-transparent"
                            placeholder={value.length === 0 ? placeholder : ""}
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                            onFocus={() => input && setShowDropdown(suggestions.length > 0)}
                        />
                    </div>

                    {/* Autocomplete Dropdown */}
                    {showDropdown && (
                        <div className="absolute z-50 w-full mt-1 bg-white border rounded-lg shadow-lg overflow-y-auto"
                            style={{ maxHeight: `${maxHeight}px` }}>
                            {suggestions.map((suggestion, index) => (
                                <div key={index}
                                    className={`px-3 py-2 cursor-pointer transition ${index === selectedIndex ? 'bg-blue-100' : 'hover:bg-gray-100'}`}
                                    onClick={() => addTag(suggestion)}>
                                    {suggestion}
                                </div>
                            ))}
                            {/* Option to create new tag */}
                            {input && !allTags.includes(input.trim()) && (
                                <div className={`px-3 py-2 cursor-pointer border-t text-blue-600 font-medium transition ${selectedIndex === suggestions.length ? 'bg-blue-50' : 'hover:bg-gray-50'}`}
                                    onClick={() => addTag(input)}>
                                    + Create "{input.trim()}"
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // TAG MANAGER - Colorful chip tokens with full CRUD operations
        const TAG_COLORS = [
            { bg: 'bg-blue-100', text: 'text-blue-800', border: 'border-blue-300' },
            { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300' },
            { bg: 'bg-yellow-100', text: 'text-yellow-800', border: 'border-yellow-300' },
            { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-300' },
            { bg: 'bg-purple-100', text: 'text-purple-800', border: 'border-purple-300' },
            { bg: 'bg-pink-100', text: 'text-pink-800', border: 'border-pink-300' },
            { bg: 'bg-indigo-100', text: 'text-indigo-800', border: 'border-indigo-300' },
            { bg: 'bg-orange-100', text: 'text-orange-800', border: 'border-orange-300' },
        ];

        const getTagColor = (tag) => {
            const hash = tag.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            return TAG_COLORS[hash % TAG_COLORS.length];
        };

        // Title Case formatter for consistent tag naming
        const toTitleCase = (str) => {
            return str.trim().split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
        };

        const TagManagerModal = ({ isOpen, onClose, books, onTagsUpdated }) => {
            const [allTags, setAllTags] = useState([]);
            const [selectedTags, setSelectedTags] = useState([]);
            const [searchQuery, setSearchQuery] = useState('');
            const [showDropdown, setShowDropdown] = useState(false);
            const [maxHeight, setMaxHeight] = useState(200);
            const [renameTag, setRenameTag] = useState(null);
            const [renameValue, setRenameValue] = useState('');
            const [deleteTag, setDeleteTag] = useState(null);
            const [deleteAction, setDeleteAction] = useState('remove');
            const [replaceTarget, setReplaceTarget] = useState('');
            const [showMergeModal, setShowMergeModal] = useState(false);
            const [mergeTarget, setMergeTarget] = useState('');
            const [mergeNewName, setMergeNewName] = useState('');
            const [mergeMode, setMergeMode] = useState('existing');
            const [isProcessing, setIsProcessing] = useState(false);
            const [showBrowseAll, setShowBrowseAll] = useState(false);
            const inputRef = useRef(null);

            // Calculate all tags with counts
            const refreshTags = useCallback(async () => {
                const allBooks = await db.books.toArray();
                const tagMap = new Map();
                allBooks.forEach(book => {
                    (book.tags || []).forEach(tag => {
                        if (!tagMap.has(tag)) tagMap.set(tag, { count: 0, bookIds: [] });
                        tagMap.get(tag).count++;
                        tagMap.get(tag).bookIds.push(book.id);
                    });
                });
                const tags = Array.from(tagMap.entries())
                    .map(([tag, data]) => ({ tag, ...data }))
                    .sort((a, b) => b.count - a.count);
                setAllTags(tags);
            }, []);

            useEffect(() => {
                if (isOpen) {
                    refreshTags();
                    setSearchQuery('');
                    setSelectedTags([]);
                }
            }, [isOpen, refreshTags]);

            // Keyboard-aware height calculation
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 200;
                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20;
                return Math.max(100, Math.min(viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap, 250));
            }, []);

            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());
                updateHeight();
                window.visualViewport?.addEventListener('resize', updateHeight);
                return () => window.visualViewport?.removeEventListener('resize', updateHeight);
            }, [calculateMaxHeight]);

            // Filter tags by search (search-first: show nothing if empty)
            const filteredTags = useMemo(() => {
                if (!searchQuery.trim()) return [];
                const q = searchQuery.toLowerCase();
                return allTags.filter(t => t.tag.toLowerCase().includes(q)).slice(0, 15);
            }, [allTags, searchQuery]);

            // Check if search query is a new tag (doesn't exist)
            const isNewTag = useMemo(() => {
                if (!searchQuery.trim()) return false;
                const q = searchQuery.trim().toLowerCase();
                return !allTags.some(t => t.tag.toLowerCase() === q);
            }, [allTags, searchQuery]);

            // Toggle tag selection (add as chip)
            const selectTag = (tag) => {
                if (!selectedTags.includes(tag)) {
                    setSelectedTags([...selectedTags, tag]);
                }
                setSearchQuery('');
                setShowDropdown(false);
            };

            // Remove chip
            const removeTag = (tag) => {
                setSelectedTags(selectedTags.filter(t => t !== tag));
            };

            // Create new tag and add to selection (with Title Case)
            const handleCreateTag = () => {
                const newTag = toTitleCase(searchQuery);
                if (newTag && !selectedTags.some(t => t.toLowerCase() === newTag.toLowerCase())) {
                    setSelectedTags([...selectedTags, newTag]);
                }
                setSearchQuery('');
                setShowDropdown(false);
            };

            // Rename tag
            const handleRename = async () => {
                if (!renameTag || !renameValue.trim()) return;
                setIsProcessing(true);
                try {
                    const booksWithTag = await db.books.where('tags').equals(renameTag).toArray();
                    for (const book of booksWithTag) {
                        book.tags = book.tags.map(t => t === renameTag ? renameValue.trim() : t);
                        await db.books.put(book);
                    }
                    alert(`Renamed "${renameTag}" → "${renameValue.trim()}" in ${booksWithTag.length} books`);
                    onClose();
                    if (onTagsUpdated) onTagsUpdated();
                } finally {
                    setIsProcessing(false);
                }
            };

            // Delete tag with options
            const handleDelete = async () => {
                if (!deleteTag) return;
                setIsProcessing(true);
                try {
                    const booksWithTag = await db.books.where('tags').equals(deleteTag).toArray();
                    for (const book of booksWithTag) {
                        if (deleteAction === 'remove') {
                            book.tags = book.tags.filter(t => t !== deleteTag);
                        } else if (deleteAction === 'replaceExisting' && replaceTarget) {
                            book.tags = book.tags.map(t => t === deleteTag ? replaceTarget : t);
                            book.tags = [...new Set(book.tags)];
                        } else if (deleteAction === 'replaceNew' && replaceTarget.trim()) {
                            book.tags = book.tags.map(t => t === deleteTag ? replaceTarget.trim() : t);
                        }
                        await db.books.put(book);
                    }
                    const actionText = deleteAction === 'remove' ? 'removed from' : 'replaced in';
                    alert(`"${deleteTag}" ${actionText} ${booksWithTag.length} books`);
                    onClose();
                    if (onTagsUpdated) onTagsUpdated();
                } finally {
                    setIsProcessing(false);
                }
            };

            // Merge multiple tags
            const handleMerge = async () => {
                if (selectedTags.length < 2) return;
                const targetName = mergeMode === 'existing' ? mergeTarget : mergeNewName.trim();
                if (!targetName) return;

                setIsProcessing(true);
                try {
                    let totalBooks = 0;
                    for (const sourceTag of selectedTags) {
                        if (sourceTag === targetName) continue;
                        const booksWithTag = await db.books.where('tags').equals(sourceTag).toArray();
                        for (const book of booksWithTag) {
                            book.tags = book.tags.map(t => t === sourceTag ? targetName : t);
                            book.tags = [...new Set(book.tags)];
                            await db.books.put(book);
                        }
                        totalBooks += booksWithTag.length;
                    }
                    alert(`Merged ${selectedTags.length} tags into "${targetName}" (${totalBooks} books updated)`);
                    onClose();
                    if (onTagsUpdated) onTagsUpdated();
                } finally {
                    setIsProcessing(false);
                }
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 modal-overlay" onClick={onClose}>
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg max-h-[85vh] flex flex-col" onClick={e => e.stopPropagation()}>
                        {/* Header */}
                        <div className="p-4 border-b flex justify-between items-center bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-t-xl">
                            <h2 className="font-bold text-lg flex items-center gap-2"><Icon name="Tag" size={20} /> Tag Manager</h2>
                            <button onClick={onClose} className="p-1 hover:bg-white/20 rounded"><Icon name="X" size={20} /></button>
                        </div>

                        {/* Search Input with Dropdown */}
                        <div className="p-3 border-b bg-gray-50 relative">
                            <input
                                ref={inputRef}
                                className="w-full p-3 border rounded-lg text-sm"
                                placeholder="Search tags or type new..."
                                value={searchQuery}
                                onChange={e => { setSearchQuery(e.target.value); setShowDropdown(true); }}
                                onFocus={() => setShowDropdown(true)}
                            />
                            {/* Dropdown */}
                            {showDropdown && searchQuery.trim() && (
                                <div
                                    className="absolute left-3 right-3 bg-white border rounded-lg shadow-lg z-10 overflow-y-auto"
                                    style={{ maxHeight: maxHeight, top: '100%' }}
                                >
                                    {filteredTags.map(({ tag, count }) => {
                                        const color = getTagColor(tag);
                                        const isSelected = selectedTags.includes(tag);
                                        return (
                                            <div
                                                key={tag}
                                                onClick={() => !isSelected && selectTag(tag)}
                                                className={`px-3 py-2 flex justify-between items-center cursor-pointer hover:bg-gray-100 
                                                    ${isSelected ? 'opacity-50 cursor-not-allowed' : ''}`}
                                            >
                                                <span className={`px-2 py-0.5 rounded-full text-sm ${color.bg} ${color.text}`}>
                                                    {tag}
                                                </span>
                                                <span className="text-xs text-gray-400">{count} books</span>
                                            </div>
                                        );
                                    })}
                                    {filteredTags.length === 0 && !isNewTag && (
                                        <div className="px-3 py-2 text-gray-400 text-sm italic">No matching tags</div>
                                    )}
                                    {isNewTag && (
                                        <div
                                            onClick={handleCreateTag}
                                            className="px-3 py-2 flex items-center gap-2 cursor-pointer hover:bg-green-50 text-green-700 border-t"
                                        >
                                            <Icon name="Plus" size={16} />
                                            <span>Create "<strong>{searchQuery.trim()}</strong>"</span>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Selected Tags (Chips) */}
                        <div className="p-3 border-b flex flex-wrap gap-2 min-h-[60px]">
                            {selectedTags.length === 0 ? (
                                <p className="text-gray-400 text-sm italic">Type to search and select tags...</p>
                            ) : (
                                selectedTags.map(tag => {
                                    const color = getTagColor(tag);
                                    const tagData = allTags.find(t => t.tag === tag);
                                    const isNew = !tagData;
                                    return (
                                        <span
                                            key={tag}
                                            className={`px-3 py-1.5 rounded-full text-sm font-medium flex items-center gap-2 border-2
                                                ${isNew ? 'bg-green-100 text-green-800 border-green-300' : `${color.bg} ${color.text} ${color.border}`}`}
                                        >
                                            {tag} {tagData && <span className="opacity-60">({tagData.count})</span>}
                                            {isNew && <span className="text-[10px] bg-green-500 text-white px-1 rounded">NEW</span>}
                                            <button onClick={() => removeTag(tag)} className="hover:text-red-600 ml-1">×</button>
                                        </span>
                                    );
                                })
                            )}
                        </div>

                        {/* Action Buttons */}
                        <div className="p-3 bg-gray-100 flex flex-wrap gap-2">
                            {selectedTags.length === 1 && allTags.find(t => t.tag === selectedTags[0]) && (
                                <>
                                    <button
                                        onClick={() => { setRenameTag(selectedTags[0]); setRenameValue(selectedTags[0]); }}
                                        className="flex-1 py-2 bg-blue-100 text-blue-800 rounded-lg text-sm font-bold flex items-center justify-center gap-1"
                                    >
                                        <Icon name="Edit3" size={14} /> Rename
                                    </button>
                                    <button
                                        onClick={() => setDeleteTag(selectedTags[0])}
                                        className="flex-1 py-2 bg-red-100 text-red-800 rounded-lg text-sm font-bold flex items-center justify-center gap-1"
                                    >
                                        <Icon name="Trash2" size={14} /> Delete
                                    </button>
                                </>
                            )}
                            {selectedTags.length >= 2 && (
                                <button
                                    onClick={() => setShowMergeModal(true)}
                                    className="flex-1 py-2 bg-purple-100 text-purple-800 rounded-lg text-sm font-bold flex items-center justify-center gap-1"
                                >
                                    <Icon name="Merge" size={14} /> Merge {selectedTags.length} Tags
                                </button>
                            )}
                            {selectedTags.length > 0 && (
                                <button
                                    onClick={() => setSelectedTags([])}
                                    className="py-2 px-4 bg-gray-200 rounded-lg text-sm"
                                >
                                    Clear
                                </button>
                            )}
                            {selectedTags.length === 0 && (
                                <p className="text-xs text-gray-400 italic w-full text-center">Select tags to see actions</p>
                            )}
                        </div>

                        {/* Quick Stats + Browse All */}
                        <div className="p-2 bg-gray-50 border-t flex justify-between items-center">
                            <p className="text-xs text-gray-400">{allTags.length} tags in library</p>
                            <button
                                onClick={() => setShowBrowseAll(true)}
                                className="text-xs bg-blue-100 text-blue-700 px-3 py-1 rounded-full font-bold hover:bg-blue-200"
                            >
                                Browse All
                            </button>
                        </div>

                        {/* Browse All Tags Modal */}
                        {showBrowseAll && (
                            <div className="absolute inset-0 bg-black/30 flex items-center justify-center p-4 z-20">
                                <div className="bg-white rounded-xl w-full max-w-md max-h-[70vh] flex flex-col shadow-xl">
                                    <div className="p-3 border-b flex justify-between items-center bg-blue-500 text-white rounded-t-xl">
                                        <h3 className="font-bold">📋 All Tags ({allTags.length})</h3>
                                        <button onClick={() => setShowBrowseAll(false)} className="hover:bg-white/20 p-1 rounded"><Icon name="X" size={18} /></button>
                                    </div>
                                    <div className="flex-1 overflow-y-auto p-3">
                                        <div className="flex flex-wrap gap-2">
                                            {allTags.map(({ tag, count }) => {
                                                const color = getTagColor(tag);
                                                const isSelected = selectedTags.includes(tag);
                                                return (
                                                    <button
                                                        key={tag}
                                                        onClick={() => { selectTag(tag); setShowBrowseAll(false); }}
                                                        className={`px-3 py-1.5 rounded-full text-sm font-medium border-2 transition-all
                                                            ${color.bg} ${color.text} ${color.border}
                                                            ${isSelected ? 'ring-2 ring-offset-1 ring-blue-500' : ''}
                                                            hover:shadow-md active:scale-95`}
                                                    >
                                                        {tag} <span className="opacity-60">({count})</span>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                    <div className="p-2 border-t text-center">
                                        <button onClick={() => setShowBrowseAll(false)} className="text-sm text-gray-500">Close</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Rename Modal */}
                        {renameTag && (
                            <div className="absolute inset-0 bg-black/30 flex items-center justify-center p-4 z-20">
                                <div className="bg-white rounded-xl p-4 w-full max-w-sm shadow-xl">
                                    <h3 className="font-bold text-lg mb-3">Rename "{renameTag}"</h3>
                                    <input
                                        className="w-full p-3 border rounded-lg mb-3"
                                        value={renameValue}
                                        onChange={e => setRenameValue(e.target.value)}
                                        autoFocus
                                    />
                                    <div className="flex gap-2">
                                        <button onClick={handleRename} disabled={isProcessing} className="flex-1 py-2 bg-blue-600 text-white rounded-lg font-bold">{isProcessing ? 'Renaming...' : 'Rename'}</button>
                                        <button onClick={() => setRenameTag(null)} className="flex-1 py-2 bg-gray-200 rounded-lg">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Delete Modal */}
                        {deleteTag && (
                            <div className="absolute inset-0 bg-black/30 flex items-center justify-center p-4 z-20">
                                <div className="bg-white rounded-xl p-4 w-full max-w-sm shadow-xl">
                                    <h3 className="font-bold text-lg mb-2">Delete "{deleteTag}"?</h3>
                                    <p className="text-sm text-gray-500 mb-3">This tag is used by {allTags.find(t => t.tag === deleteTag)?.count || 0} books.</p>
                                    <div className="space-y-2 mb-4">
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={deleteAction === 'remove'} onChange={() => setDeleteAction('remove')} />
                                            Remove tag from all books
                                        </label>
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={deleteAction === 'replaceExisting'} onChange={() => setDeleteAction('replaceExisting')} />
                                            Replace with existing tag:
                                        </label>
                                        {deleteAction === 'replaceExisting' && (
                                            <select className="w-full p-2 border rounded ml-6" value={replaceTarget} onChange={e => setReplaceTarget(e.target.value)}>
                                                <option value="">Select tag...</option>
                                                {allTags.filter(t => t.tag !== deleteTag).map(t => (
                                                    <option key={t.tag} value={t.tag}>{t.tag} ({t.count})</option>
                                                ))}
                                            </select>
                                        )}
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={deleteAction === 'replaceNew'} onChange={() => setDeleteAction('replaceNew')} />
                                            Replace with new tag:
                                        </label>
                                        {deleteAction === 'replaceNew' && (
                                            <input className="w-full p-2 border rounded ml-6" placeholder="New tag name..." value={replaceTarget} onChange={e => setReplaceTarget(e.target.value)} />
                                        )}
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={handleDelete} disabled={isProcessing} className="flex-1 py-2 bg-red-600 text-white rounded-lg font-bold">{isProcessing ? 'Deleting...' : 'Delete'}</button>
                                        <button onClick={() => setDeleteTag(null)} className="flex-1 py-2 bg-gray-200 rounded-lg">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Merge Modal */}
                        {showMergeModal && (
                            <div className="absolute inset-0 bg-black/30 flex items-center justify-center p-4 z-20">
                                <div className="bg-white rounded-xl p-4 w-full max-w-sm shadow-xl">
                                    <h3 className="font-bold text-lg mb-2">Merge {selectedTags.length} Tags</h3>
                                    <p className="text-sm text-gray-500 mb-3">Tags: {selectedTags.join(', ')}</p>
                                    <div className="space-y-2 mb-4">
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={mergeMode === 'existing'} onChange={() => setMergeMode('existing')} />
                                            Merge into one of these:
                                        </label>
                                        {mergeMode === 'existing' && (
                                            <select className="w-full p-2 border rounded ml-6" value={mergeTarget} onChange={e => setMergeTarget(e.target.value)}>
                                                <option value="">Select tag...</option>
                                                {selectedTags.filter(t => allTags.find(at => at.tag === t)).map(t => (
                                                    <option key={t} value={t}>{t}</option>
                                                ))}
                                            </select>
                                        )}
                                        <label className="flex items-center gap-2 text-sm">
                                            <input type="radio" checked={mergeMode === 'new'} onChange={() => setMergeMode('new')} />
                                            Merge into new tag:
                                        </label>
                                        {mergeMode === 'new' && (
                                            <input className="w-full p-2 border rounded ml-6" placeholder="New tag name..." value={mergeNewName} onChange={e => setMergeNewName(e.target.value)} />
                                        )}
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={handleMerge} disabled={isProcessing} className="flex-1 py-2 bg-purple-600 text-white rounded-lg font-bold">{isProcessing ? 'Merging...' : 'Merge'}</button>
                                        <button onClick={() => setShowMergeModal(false)} className="flex-1 py-2 bg-gray-200 rounded-lg">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // AUTOCOMPLETE INPUT (For Author, Building, Owner, Condition)
        // Supports two modes:
        // 1. allBooks + field: extracts suggestions from book data
        // 2. suggestions: direct array of suggestions (for SlicerSearch)
        const AutocompleteInput = ({ label, value = '', onChange, allBooks = [], field, placeholder = '', suggestions: directSuggestions }) => {
            const [showDropdown, setShowDropdown] = useState(false);
            const [filteredSuggestions, setFilteredSuggestions] = useState([]);
            const [selectedIndex, setSelectedIndex] = useState(-1);
            const [maxHeight, setMaxHeight] = useState(150);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Handle onChange - always pass event-style object for form field compatibility
            const handleChange = (val) => {
                if (typeof onChange === 'function') {
                    onChange({ target: { value: val } });
                }
            };

            // Calculate dropdown height based on viewport
            const calculateMaxHeight = useCallback(() => {
                if (!inputRef.current) return 150;
                const rect = inputRef.current.getBoundingClientRect();
                const viewportHeight = window.visualViewport?.height || window.innerHeight;
                const estimatedKeyboardHeight = viewportHeight * 0.4;
                const safeGap = 20;
                return Math.max(80, Math.min(viewportHeight - rect.bottom - estimatedKeyboardHeight - safeGap, 200));
            }, []);

            // Recalculate height on viewport changes
            useEffect(() => {
                const updateHeight = () => setMaxHeight(calculateMaxHeight());
                updateHeight();
                window.visualViewport?.addEventListener('resize', updateHeight);
                return () => window.visualViewport?.removeEventListener('resize', updateHeight);
            }, [calculateMaxHeight]);

            // Extract unique values for this field from all books (if not using directSuggestions)
            const allValues = useMemo(() => {
                if (directSuggestions && directSuggestions.length > 0) {
                    return directSuggestions;
                }
                const valueSet = new Set();
                allBooks.forEach(book => {
                    const fieldValue = book[field];
                    if (fieldValue && typeof fieldValue === 'string' && fieldValue.trim()) {
                        valueSet.add(fieldValue.trim());
                    }
                });
                return Array.from(valueSet).sort();
            }, [allBooks, field, directSuggestions]);

            // Filter suggestions based on input
            useEffect(() => {
                if (!value || value.length < 1) {
                    setFilteredSuggestions([]);
                    setShowDropdown(false);
                    return;
                }

                const filtered = allValues.filter(val =>
                    String(val).toLowerCase().includes(String(value).toLowerCase()) &&
                    String(val).toLowerCase() !== String(value).toLowerCase()
                );
                setFilteredSuggestions(filtered.slice(0, 8));
                setShowDropdown(filtered.length > 0);
                setSelectedIndex(-1);
            }, [value, allValues]);

            // Select suggestion
            const selectSuggestion = (suggestion) => {
                handleChange(suggestion);
                setShowDropdown(false);
                setSelectedIndex(-1);
            };

            // Keyboard navigation
            const handleKeyDown = (e) => {
                if (!showDropdown) return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setSelectedIndex(prev =>
                        prev < filteredSuggestions.length - 1 ? prev + 1 : prev
                    );
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setSelectedIndex(prev => prev > 0 ? prev - 1 : -1);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    selectSuggestion(filteredSuggestions[selectedIndex]);
                } else if (e.key === 'Escape') {
                    setShowDropdown(false);
                    setSelectedIndex(-1);
                }
            };

            // Click outside to close
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            return (
                <div className="relative flex-1" ref={dropdownRef}>
                    {label && <label className="text-xs text-gray-500 font-bold">{label}</label>}
                    <input
                        ref={inputRef}
                        type="text"
                        className="w-full p-3 border rounded-lg"
                        placeholder={placeholder}
                        value={value}
                        onChange={(e) => handleChange(e.target.value)}
                        onKeyDown={handleKeyDown}
                        onFocus={() => value && setShowDropdown(filteredSuggestions.length > 0)}
                    />

                    {/* Autocomplete Dropdown */}
                    {showDropdown && filteredSuggestions.length > 0 && (
                        <div className="absolute z-50 w-full mt-1 bg-white border rounded-lg shadow-lg overflow-y-auto"
                            style={{ maxHeight: `${maxHeight}px` }}>
                            {filteredSuggestions.map((suggestion, index) => (
                                <div
                                    key={index}
                                    className={`px-3 py-2 cursor-pointer transition ${index === selectedIndex ? 'bg-blue-100' : 'hover:bg-gray-100'
                                        }`}
                                    onClick={() => selectSuggestion(suggestion)}
                                >
                                    {suggestion}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        // BARCODE SCANNER
        // BARCODE SCANNER - Uses Capacitor MLKit (native) with Html5Qrcode fallback (web)
        const BarcodeScanner = ({ onDetected, onClose }) => {
            const [online, setOnline] = useState(navigator.onLine);
            const [scanning, setScanning] = useState(false);
            const [error, setError] = useState(null);
            const [useWebFallback, setUseWebFallback] = useState(false);

            useEffect(() => {
                window.addEventListener('online', () => setOnline(true));
                window.addEventListener('offline', () => setOnline(false));

                const startScanning = async () => {
                    try {
                        const plugins = window.Capacitor?.Plugins || {};
                        const pluginNames = Object.keys(plugins);

                        // DEBUG: Log all available Capacitor plugins to console
                        console.log('Available Capacitor Plugins:', pluginNames);

                        // Try multiple possible plugin names (MLKit barcode scanner might register differently)
                        const Scanner = plugins.BarcodeScanner || plugins.BarcodeScanning || plugins.MlkitBarcodeScanning || plugins.CapacitorMlkitBarcodeScanning;

                        // VISIBLE DEBUG: Show alert with plugin info (REMOVE AFTER DEBUGGING)
                        alert(`DEBUG - Capacitor Plugins Found:\n\n${pluginNames.join(', ') || 'NONE'}\n\nBarcode Scanner: ${Scanner ? 'FOUND ✓' : 'NOT FOUND ✗'}`);

                        console.log('Found barcode scanner plugin:', Scanner ? 'Yes' : 'No (using web fallback)');

                        if (Scanner) {
                            try {
                                // Step 1: Request permission
                                alert('DEBUG Step 1: Requesting camera permission...');
                                const permResult = await Scanner.requestPermissions();
                                alert(`DEBUG Step 2: Permission result: ${JSON.stringify(permResult)}`);
                                console.log('Permission result:', permResult);

                                if (permResult.camera !== 'granted') {
                                    alert('DEBUG: Permission denied!');
                                    setError('Camera permission denied');
                                    return;
                                }

                                // Step 3: Start scanning
                                alert('DEBUG Step 3: Starting native scanner...');
                                setScanning(true);
                                const result = await Scanner.scan({
                                    formats: ['EAN_13', 'EAN_8', 'UPC_A', 'UPC_E'],
                                });

                                alert(`DEBUG Step 4: Scan complete! Result: ${JSON.stringify(result)}`);
                                console.log('Scan result:', result);

                                setScanning(false);
                                if (result.barcodes && result.barcodes.length > 0) {
                                    onDetected(result.barcodes[0].rawValue);
                                } else {
                                    onClose();
                                }
                            } catch (innerErr) {
                                // Show exactly what error occurred inside Scanner block
                                alert(`DEBUG ERROR inside Scanner:\n\n${innerErr.message || innerErr}`);
                                console.error('Scanner inner error:', innerErr);
                                setUseWebFallback(true);
                            }
                        } else {
                            // No native plugin found - fall back to web scanner
                            console.log('Using web fallback (Html5QrcodeScanner)');
                            setUseWebFallback(true);
                        }
                    } catch (err) {
                        alert(`DEBUG OUTER ERROR:\n\n${err.message || err}`);
                        console.error('Barcode scan error:', err);
                        // On error, try web fallback
                        setUseWebFallback(true);
                    }
                };

                startScanning();

                return () => {
                    // Cleanup for Capacitor scanner if needed
                    const plugins = window.Capacitor?.Plugins || {};
                    const Scanner = plugins.BarcodeScanner || plugins.BarcodeScanning || plugins.MlkitBarcodeScanning || plugins.CapacitorMlkitBarcodeScanning;
                    if (Scanner && Scanner.stopScan) {
                        try { Scanner.stopScan(); } catch (e) { }
                    }
                };
            }, []);

            // Web fallback using Html5QrcodeScanner
            useEffect(() => {
                if (!useWebFallback) return;

                if (!window.Html5QrcodeScanner) {
                    setError('Barcode scanner not available');
                    return;
                }

                const scanner = new Html5QrcodeScanner("reader", { fps: 10, qrbox: 250 });
                scanner.render(
                    (decodedText) => { scanner.clear(); onDetected(decodedText); },
                    (err) => { /* ignore scan errors */ }
                );

                return () => { try { scanner.clear(); } catch (e) { } };
            }, [useWebFallback]);

            // Native scanning UI (minimal - camera is fullscreen)
            if (scanning && !useWebFallback) {
                return (
                    <div className="fixed inset-0 bg-black z-50 flex flex-col items-center justify-center modal-overlay">
                        <div className="text-white text-center">
                            <div className="w-12 h-12 border-4 border-white border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                            <p className="font-bold">Scanning...</p>
                            <p className="text-sm opacity-70">Point camera at barcode</p>
                        </div>
                        <button onClick={onClose} className="absolute top-4 right-4 text-white p-2">
                            <Icon name="X" size={24} />
                        </button>
                    </div>
                );
            }

            // Error UI
            if (error) {
                return (
                    <div className="fixed inset-0 bg-black z-50 flex flex-col items-center justify-center modal-overlay">
                        <div className="text-white text-center p-4">
                            <Icon name="AlertCircle" size={48} className="mx-auto mb-4 text-red-400" />
                            <p className="font-bold mb-2">Scanner Error</p>
                            <p className="text-sm opacity-70 mb-4">{error}</p>
                            <button onClick={onClose} className="bg-white text-black px-6 py-2 rounded-lg font-bold">
                                Close
                            </button>
                        </div>
                    </div>
                );
            }

            // Web fallback UI (Html5QrcodeScanner)
            return (
                <div className="fixed inset-0 bg-black z-50 flex flex-col modal-overlay">
                    <div className="p-4 flex justify-between text-white bg-black/50 absolute top-0 w-full z-10 items-center">
                        <span className="flex items-center gap-2">
                            <div className={`w-3 h-3 rounded-full ${online ? 'bg-green-500' : 'bg-red-500'}`}></div>
                            {online ? 'Online' : 'Offline'}
                            {useWebFallback && <span className="text-xs opacity-50">(Web Mode)</span>}
                        </span>
                        <button onClick={onClose}><Icon name="X" /></button>
                    </div>
                    <div id="reader" className="flex-1 bg-white"></div>
                </div>
            );
        };

        // BOOK FORM
        const BookForm = ({ book, onSave, onCancel, onBarcodeFound, globalCurrency, books = [] }) => {
            const [form, setForm] = useState(book ? { ...book, pages: book.pages || [] } : {
                title: '', phonetic: '', author_name: '', author_initials: '', owner: '', building: '', shelf: '', isbn: '',
                price: '', currency: '₹', year: '', lang: 'en', tags: [], status: 'avail', page_count: '', condition: 'Good',
                front: null, rear: null, thumb: null, pages: []
            });
            const [scanMode, setScanMode] = useState(false);
            const [listeningField, setListeningField] = useState(null);

            // Auto-fill phonetic for English books when title changes (works with barcode scanner)
            useEffect(() => {
                if (form.lang === 'en' && form.title && !form.phonetic) {
                    setForm(f => ({ ...f, phonetic: f.title }));
                }
            }, [form.title]);

            // Capture image using Capacitor Camera (replaces unreliable HTML file input)            // Capture image using Capacitor Camera
            const captureImage = async (field, sourceType = 'Prompt') => {
                try {
                    setForm(prev => ({ ...prev, [field]: 'loading' }));

                    const { Camera, CameraSource, CameraResultType } = window.Capacitor?.Plugins || {};
                    if (Camera) {
                        // Map source type to CameraSource enum or use direct value
                        const sourceValue = CameraSource ?
                            (sourceType === 'Camera' ? CameraSource.Camera :
                                sourceType === 'Photos' ? CameraSource.Photos :
                                    CameraSource.Prompt) : sourceType;

                        const resultType = CameraResultType ? CameraResultType.DataUrl : 'dataUrl';

                        // Use Capacitor Camera plugin
                        const image = await Camera.getPhoto({
                            quality: 80,
                            allowEditing: false,
                            resultType: resultType,
                            source: sourceValue,
                            width: 800,
                            height: 1200,
                            correctOrientation: true
                        });

                        // Compress using existing ImageUtils
                        const compressed = await ImageUtils.compressDataUrl(image.dataUrl);
                        setForm(prev => ({ ...prev, [field]: compressed }));
                    } else {
                        // Fallback for web: trigger file input
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = 'image/*';
                        input.onchange = async (e) => {
                            const file = e.target.files?.[0];
                            if (file) {
                                const res = await ImageUtils.process(file);
                                setForm(prev => ({ ...prev, [field]: res }));
                            }
                        };
                        input.click();
                    }
                } catch (err) {
                    setForm(prev => ({ ...prev, [field]: null }));
                    if (err.message && !err.message.includes('cancelled')) {
                        alert('Camera error: ' + err.message);
                    }
                }
            };

            // Legacy file input handler (for pages/additional images)
            const handleImg = async (e, field) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    try {
                        setForm(prev => ({ ...prev, [field]: 'loading' }));
                        const res = await ImageUtils.process(file);
                        setForm(prev => ({ ...prev, [field]: res }));
                    } catch (err) {
                        setForm(prev => ({ ...prev, [field]: null }));
                        alert("Error: " + err);
                    }
                }
                // Clear input to allow re-selecting same file
                e.target.value = '';
            };

            const handlePageAdd = async (e) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    try {
                        const res = await ImageUtils.process(file);
                        setForm(f => ({ ...f, pages: [...(f.pages || []), res] }));
                    } catch (err) { alert("Error: " + err); }
                }
            };

            // Capture page image using Capacitor Camera
            const capturePageImage = async (sourceType = 'Prompt') => {
                try {
                    const { Camera, CameraSource, CameraResultType } = window.Capacitor?.Plugins || {};
                    if (Camera) {
                        // Map source type to CameraSource enum
                        const sourceValue = CameraSource ?
                            (sourceType === 'Camera' ? CameraSource.Camera :
                                sourceType === 'Photos' ? CameraSource.Photos :
                                    CameraSource.Prompt) : sourceType;

                        const resultType = CameraResultType ? CameraResultType.DataUrl : 'dataUrl';

                        const image = await Camera.getPhoto({
                            quality: 80,
                            allowEditing: false,
                            resultType: resultType,
                            source: sourceValue,
                            width: 800,
                            height: 1200,
                            correctOrientation: true
                        });
                        const compressed = await ImageUtils.compressDataUrl(image.dataUrl);
                        setForm(f => ({ ...f, pages: [...(f.pages || []), compressed] }));
                    } else {
                        // Fallback for web
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = 'image/*';
                        input.onchange = async (e) => {
                            const file = e.target.files?.[0];
                            if (file) {
                                const res = await ImageUtils.process(file);
                                setForm(f => ({ ...f, pages: [...(f.pages || []), res] }));
                            }
                        };
                        input.click();
                    }
                } catch (err) {
                    if (err.message && !err.message.includes('cancelled')) {
                        alert('Camera error: ' + err.message);
                    }
                }
            };



            const handleBarcode = async (isbn) => {
                setScanMode(false);
                const exists = await db.books.where('isbn').equals(isbn).first();
                if (exists) {
                    // Just alert - don't call onBarcodeFound as it hides the scanner button
                    alert("This book already exists in your library!");
                    // Return to clean Add Book form with scanner button visible
                    return;
                }

                if (navigator.onLine) {
                    try {
                        const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`);
                        const data = await res.json();
                        if (data.items && data.items[0]) {
                            const info = data.items[0].volumeInfo;
                            setForm(f => ({
                                ...f, isbn: isbn, title: info.title,
                                author_name: info.authors?.[0] || '', author_initials: '',
                                publisher: info.publisher, pub_year: info.publishedDate?.substring(0, 4),
                                front: info.imageLinks?.thumbnail, page_count: info.pageCount
                            }));
                        } else { alert("Not found in API. Please enter details manually."); }
                    } catch (e) { alert("API Error. Please check internet."); }
                } else {
                    setForm(f => ({ ...f, isbn: isbn }));
                    alert("Offline Mode: ISBN Scanned. Please enter details.");
                }
            };

            let activeRecognition = null;
            let voiceTimeout = null;

            const stopVoice = () => {
                if (activeRecognition) {
                    try { activeRecognition.stop(); } catch (e) { }
                    activeRecognition = null;
                }
                if (voiceTimeout) {
                    clearTimeout(voiceTimeout);
                    voiceTimeout = null;
                }
                setListeningField(null);
            };

            const startVoice = async (field) => {
                // 0. Toggle Logic
                if (listeningField === field) {
                    stopVoice();
                    return;
                }
                stopVoice();

                if (!navigator.onLine) return alert("No Internet Connection.");

                // Determine language
                const useNative = field === 'title' && form.lang !== 'en';
                const language = useNative
                    ? (form.lang === 'ml' ? 'ml-IN' : form.lang === 'ar' ? 'ar-SA' : 'hi-IN')
                    : 'en-US';

                // Use Native Plugin if in Capacitor
                const NativeSpeech = window.Capacitor?.Plugins?.SpeechRecognition;

                if (window.Capacitor && NativeSpeech) {
                    try {
                        // Check availability
                        const { available } = await NativeSpeech.available();
                        if (!available) return alert("Speech Recognition not available on this device.");

                        // Check/Request permissions
                        const permStatus = await NativeSpeech.checkPermissions();
                        if (permStatus.speechRecognition !== 'granted') {
                            const req = await NativeSpeech.requestPermissions();
                            if (req.speechRecognition !== 'granted') return alert("Microphone permission denied.");
                        }

                        setListeningField(field);

                        // Start native recognition
                        const result = await NativeSpeech.start({
                            language: language,
                            popup: false,
                            partialResults: false
                        });

                        if (result.matches && result.matches.length > 0) {
                            const transcript = result.matches[0];
                            if (field === 'tags') {
                                const newTags = transcript.split(/[\s,]+/).filter(Boolean);
                                setForm(f => ({ ...f, tags: [...(f.tags || []), ...newTags] }));
                            } else {
                                setForm(f => ({ ...f, [field]: transcript }));
                            }
                        }
                        stopVoice();
                    } catch (e) {
                        stopVoice();
                        if (e.message && e.message.includes('cancelled')) return; // User cancelled
                        alert("Voice Error: " + (e.message || e));
                    }
                } else {
                    // Fallback to Web Speech API (for browser testing)
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SpeechRecognition) return alert("Speech not supported in browser.");

                    try {
                        const recognition = new SpeechRecognition();
                        activeRecognition = recognition;
                        recognition.lang = language;
                        recognition.continuous = false;
                        recognition.interimResults = false;

                        recognition.onstart = () => setListeningField(field);
                        recognition.onend = () => stopVoice();
                        recognition.onerror = (e) => { stopVoice(); };
                        recognition.onresult = (event) => {
                            const transcript = event.results[0][0].transcript;
                            if (field === 'tags') {
                                const newTags = transcript.split(/[\s,]+/).filter(Boolean);
                                setForm(f => ({ ...f, tags: [...(f.tags || []), ...newTags] }));
                            } else {
                                setForm(f => ({ ...f, [field]: transcript }));
                            }
                            stopVoice();
                        };
                        recognition.start();
                    } catch (e) {
                        alert("Error: " + e.message);
                    }
                }
            };


            const saveCheck = async () => {
                const exists = await db.books.where('title').equalsIgnoreCase(form.title).toArray();
                if (exists.length > 0) {
                    const isSelf = form.id && exists.length === 1 && exists[0].id === form.id;
                    if (!isSelf && !confirm(`Possible Duplicate: "${form.title}" exists. Save anyway?`)) return;
                }
                onSave(form);
            };

            const handleChange = (field, val) => setForm(prev => ({ ...prev, [field]: val }));

            return (
                <div className="bg-white min-h-screen pb-24">
                    {scanMode && <BarcodeScanner onDetected={handleBarcode} onClose={() => setScanMode(false)} />}
                    <div className="p-4 border-b flex justify-between sticky top-0 bg-white z-20 shadow-sm">
                        <button onClick={onCancel} className="text-gray-500">Cancel</button>
                        <h2 className="font-bold">{book ? 'Edit' : 'Cataloging'}</h2>
                        <button onClick={saveCheck} className="text-blue-600 font-bold">Save</button>
                    </div>

                    <div className="p-4 space-y-5">
                        {!book && <button onClick={() => setScanMode(true)} className="w-full py-4 bg-gray-800 text-white rounded-xl flex flex-col items-center justify-center font-bold mb-4"><Icon name="Barcode" size={32} /> <span>Scan Barcode</span></button>}

                        {/* GALLERY */}
                        <div className="flex gap-3 overflow-x-auto pb-2 no-scrollbar">
                            {/* FRONT COVER */}
                            <div className="flex-shrink-0 w-28 h-40 bg-gray-100 rounded-lg border-2 border-dashed border-gray-300 relative overflow-hidden group">
                                {form.front === 'loading' ? (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                                        <div className="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                                        <span className="text-[10px] mt-1">Processing...</span>
                                    </div>
                                ) : form.front ? <img src={form.front} className="w-full h-full object-cover" /> : <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400"><Icon name="Maximize" /><span className="text-[10px]">Front</span></div>}
                                <div className="absolute bottom-0 left-0 right-0 flex bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <button onClick={() => captureImage('front', 'Prompt')} className="flex-1 p-2 text-white text-center hover:bg-black/30" title="Add Photo">
                                        <Icon name="Camera" size={14} />
                                    </button>
                                </div>
                            </div>

                            {/* REAR COVER */}
                            <div className="flex-shrink-0 w-28 h-40 bg-gray-100 rounded-lg border-2 border-dashed border-gray-300 relative overflow-hidden group">
                                {form.rear === 'loading' ? (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                                        <div className="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                                        <span className="text-[10px] mt-1">Processing...</span>
                                    </div>
                                ) : form.rear ? <img src={form.rear} className="w-full h-full object-cover" /> : <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400"><Icon name="Maximize" /><span className="text-[10px]">Rear</span></div>}
                                <div className="absolute bottom-0 left-0 right-0 flex bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <button onClick={() => captureImage('rear', 'Prompt')} className="flex-1 p-2 text-white text-center hover:bg-black/30" title="Add Photo">
                                        <Icon name="Camera" size={14} />
                                    </button>
                                </div>
                            </div>
                        </div>

                        {/* PAGES */}
                        <div className="flex gap-2 overflow-x-auto pb-2">
                            {(form.pages || []).map((p, i) => (
                                <div key={i} className="flex-shrink-0 w-28 h-40 relative group">
                                    <img src={p} className="w-full h-full object-cover rounded-lg border" />
                                    <button onClick={() => setForm(f => ({ ...f, pages: f.pages.filter((_, idx) => idx !== i) }))} className="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1"><Icon name="X" size={12} /></button>
                                </div>
                            ))}
                            {/* Add Page */}
                            <button onClick={() => capturePageImage('Prompt')} className="flex-shrink-0 w-28 h-40 bg-gray-100 border-2 border-dashed border-gray-300 rounded-lg flex flex-col items-center justify-center overflow-hidden cursor-pointer hover:bg-gray-50">
                                <Icon name="Plus" className="text-gray-400" />
                                <span className="text-[10px] font-bold text-gray-400 mt-1">Add Page</span>
                            </button>
                        </div>

                        {/* META DATA */}
                        <div className="space-y-3">
                            <div className="flex gap-2 mb-2">
                                {['en', 'ml', 'hi', 'ar'].map(l => (
                                    <button key={l} onClick={() => {
                                        // Auto-fill phonetic for English books
                                        const updates = { lang: l, language: LANG_MAP[l] };
                                        if (l === 'en' && form.title) {
                                            updates.phonetic = form.title;
                                        }
                                        setForm({ ...form, ...updates });
                                    }} className={`px-3 py-1 rounded text-xs font-bold uppercase border ${form.lang === l ? 'bg-blue-600 text-white' : 'bg-white text-gray-600'}`}>{l}</button>
                                ))}
                            </div>

                            <VoiceInput label="Title (Native)" field="title" value={form.title} onChange={(e) => {
                                const newTitle = e.target.value;
                                handleChange('title', newTitle);
                                // Auto-fill phonetic if English and title changed
                                if (form.lang === 'en' && newTitle) {
                                    handleChange('phonetic', newTitle);
                                }
                            }} onVoice={() => startVoice('title')} isListening={listeningField === 'title'} lang={form.lang} />
                            <div>
                                <VoiceInput label="Phonetic (Manual)" field="phonetic" value={form.phonetic} onChange={(e) => handleChange('phonetic', e.target.value)} onVoice={() => startVoice('phonetic')} isListening={listeningField === 'phonetic'} lang="en" />
                                {form.lang === 'en' && <p className="text-xs text-gray-500 mt-1 ml-1">✓ Auto-filled for English books (editable)</p>}
                            </div>
                            <VoiceInput label="ISBN" field="isbn" value={form.isbn} onChange={(e) => handleChange('isbn', e.target.value)} onVoice={() => startVoice('isbn')} isListening={listeningField === 'isbn'} lang="en" />

                            <div className="flex gap-2 relative">
                                <div className="flex-1 relative">
                                    <AutocompleteInput label="Author Name" field="author_name" value={form.author_name} onChange={(e) => handleChange('author_name', e.target.value)} allBooks={books} placeholder="e.g., J.K. Rowling" />
                                    <button type="button" onClick={() => startVoice('author_name')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'author_name' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                                </div>
                                <div className="w-1/3">
                                    <label className="text-xs text-gray-500 font-bold">Initials</label>
                                    <input className="w-full p-3 border rounded-lg" value={form.author_initials || ''} onChange={(e) => handleChange('author_initials', e.target.value)} placeholder="A K" />
                                </div>
                            </div>

                            <div className="grid grid-cols-2 gap-4">
                                <div className="relative">
                                    <AutoSuggestInput label="Publisher" field="publisher" value={form.publisher} onChange={(e) => handleChange('publisher', e.target.value)} />
                                    <button type="button" onClick={() => startVoice('publisher')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'publisher' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                                </div>
                                <VoiceInput label="Pub Year" field="pub_year" value={form.pub_year} onChange={(e) => handleChange('pub_year', e.target.value)} onVoice={() => startVoice('pub_year')} isListening={listeningField === 'pub_year'} lang="en" type="number" />
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <VoiceInput label="Pages" field="page_count" value={form.page_count} onChange={(e) => handleChange('page_count', e.target.value)} type="number" lang="en" />
                                <AutocompleteInput label="Condition" field="condition" value={form.condition} onChange={(e) => handleChange('condition', e.target.value)} allBooks={books} placeholder="e.g., Good, New" />
                            </div>
                        </div>

                        {/* ASSET DATA */}
                        <h3 className="text-xs font-bold text-gray-400 uppercase mt-4">Asset Info</h3>
                        <div className="space-y-3">
                            <div className="relative">
                                <AutocompleteInput label="Owner" field="owner" value={form.owner} onChange={(e) => handleChange('owner', e.target.value)} allBooks={books} placeholder="e.g., Dad, Mom" />
                                <button type="button" onClick={() => startVoice('owner')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'owner' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                            </div>

                            <div className="grid grid-cols-2 gap-4">
                                <div className="flex gap-1">
                                    <div className="w-1/3">
                                        <label className="text-xs text-gray-500 font-bold">Currency</label>
                                        <input className="w-full p-3 border rounded-lg text-center font-bold" value={form.currency} onChange={e => handleChange('currency', e.target.value)} list="currencies" />
                                        <datalist id="currencies"><option value="₹" /><option value="$" /><option value="QAR" /></datalist>
                                    </div>
                                    <div className="w-2/3">
                                        <label className="text-xs text-gray-500 font-bold">Price</label>
                                        <input type="number" className="w-full p-3 border rounded-lg" value={form.price} onChange={e => handleChange('price', e.target.value)} />
                                    </div>
                                </div>
                                <VoiceInput label="Buy Year" field="buy_year" value={form.buy_year} onChange={(e) => handleChange('buy_year', e.target.value)} onVoice={() => startVoice('buy_year')} isListening={listeningField === 'buy_year'} lang="en" type="number" />
                            </div>
                        </div>

                        {/* LOCATION */}
                        <h3 className="text-xs font-bold text-gray-400 uppercase mt-4">Location</h3>
                        <div className="grid grid-cols-2 gap-4">
                            <AutocompleteInput label="Building" field="building" value={form.building} onChange={(e) => handleChange('building', e.target.value)} allBooks={books} placeholder="e.g., Main Library" />
                            <AutoSuggestInput label="Shelf" field="shelf" value={form.shelf} onChange={(e) => handleChange('shelf', e.target.value)} />
                        </div>


                        <TagTokenInput
                            label="Tags"
                            value={form.tags || []}
                            onChange={(newTags) => setForm(f => ({ ...f, tags: newTags }))}
                            allBooks={books}
                            placeholder="Add tags (e.g., Fiction, History)..."
                        />

                    </div>
                </div>
            );
        };

        // MULTI-TAG SEARCH INPUT
        const MultiTagInput = ({ options, value, onChange, placeholder }) => {
            const [input, setInput] = useState('');
            const [filteredOpts, setFilteredOpts] = useState([]);

            // Suggest logic
            useEffect(() => {
                if (!input) { setFilteredOpts([]); return; }
                const q = input.toLowerCase();
                const matches = options.filter(o => o.toLowerCase().includes(q) && !value.includes(o)).slice(0, 5);
                setFilteredOpts(matches);
            }, [input, options, value]);

            const addTag = (t) => {
                onChange([...value, t]);
                setInput('');
            };

            const removeTag = (t) => {
                onChange(value.filter(v => v !== t));
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (filteredOpts.length > 0) addTag(filteredOpts[0]);
                    else if (input) { addTag(input); }
                }
                if (e.key === 'Backspace' && !input && value.length > 0) {
                    removeTag(value[value.length - 1]);
                }
            };

            return (
                <div className="flex items-center gap-2 flex-wrap bg-gray-100 p-2 rounded-lg border focus-within:ring-2 focus-within:ring-blue-200">
                    <Icon name="Search" className="text-gray-400" size={16} />
                    {value.map(t => (
                        <span key={t} className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full flex items-center gap-1">
                            {t}
                            <button onClick={() => removeTag(t)} className="hover:text-red-500">×</button>
                        </span>
                    ))}
                    <div className="relative flex-1 min-w-[60px]">
                        <input
                            className="w-full bg-transparent text-sm focus:outline-none min-w-[100px]"
                            placeholder={value.length > 0 ? "" : placeholder}
                            value={input}
                            onChange={e => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                        />
                        {filteredOpts.length > 0 && (
                            <div className="absolute top-full left-0 bg-white border shadow-lg rounded mt-1 z-50 w-full min-w-[150px]">
                                {filteredOpts.map(o => (
                                    <div key={o} onClick={() => addTag(o)} className="p-2 text-sm hover:bg-gray-100 cursor-pointer">{o}</div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- BULK EDIT MODAL ---
        const BulkEditModal = ({ selectedIds, books, onClose, onApply }) => {
            const [field, setField] = useState('owner');
            const [value, setValue] = useState('');
            const [tagValue, setTagValue] = useState([]); // For TagTokenInput
            const [tagAction, setTagAction] = useState('add');

            // Preview: Show current values summary
            const preview = useMemo(() => {
                const selected = books.filter(b => selectedIds.includes(b.id));
                const counts = {};
                selected.forEach(b => {
                    let v;
                    if (field === 'tags') v = (b.tags || []).join(', ') || '(no tags)';
                    else v = b[field] || '(empty)';
                    counts[v] = (counts[v] || 0) + 1;
                });
                return Object.entries(counts).sort((a, b) => b[1] - a[1]);
            }, [selectedIds, books, field]);

            // Suggestions for autocomplete
            const suggestions = useMemo(() => {
                const set = new Set();
                books.forEach(b => {
                    if (field === 'owner' && b.owner) set.add(b.owner);
                    if (field === 'building' && b.building) set.add(b.building);
                    if (field === 'tags' && b.tags) b.tags.forEach(t => set.add(t));
                    if (field === 'publisher' && b.publisher) set.add(b.publisher);
                    if (field === 'author_name' && b.author_name) set.add(b.author_name);
                });
                return [...set].sort();
            }, [books, field]);

            // Reset tagValue when switching away from tags field
            useEffect(() => {
                if (field !== 'tags') {
                    setTagValue([]);
                }
            }, [field]);

            const handleApply = async () => {
                // Validate based on field type
                if (field === 'tags') {
                    if (tagValue.length === 0) return alert("Please enter at least one tag");
                } else {
                    if (!value.trim()) return alert("Please enter a value");
                }

                for (const id of selectedIds) {
                    const book = await db.books.get(id);
                    const update = {};

                    if (field === 'owner') update.owner = value.trim();
                    if (field === 'building') update.building = value.trim();
                    if (field === 'publisher') update.publisher = value.trim();
                    if (field === 'author_name') update.author_name = value.trim();
                    if (field === 'tags') {
                        // Use tagValue array directly (from TagTokenInput)
                        update.tags = tagAction === 'add'
                            ? [...new Set([...(book.tags || []), ...tagValue])]
                            : (book.tags || []).filter(t => !tagValue.includes(t));
                    }

                    await db.books.update(id, update);
                }
                alert(`Updated ${selectedIds.length} books!`);
                onApply();
            };

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 modal-overlay">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                        <div className="p-4 border-b flex justify-between items-center sticky top-0 bg-white">
                            <h3 className="font-bold text-lg">Bulk Edit ({selectedIds.length} books)</h3>
                            <button onClick={onClose} className="p-2 hover:bg-gray-100 rounded"><Icon name="X" /></button>
                        </div>
                        <div className="p-4 space-y-4">
                            <div>
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-2">Change</label>
                                <div className="flex gap-2 flex-wrap">
                                    {['owner', 'building', 'publisher', 'author_name', 'tags'].map(f => (
                                        <button key={f} onClick={() => { setField(f); setValue(''); }}
                                            className={`px-3 py-2 rounded text-sm font-bold capitalize ${field === f ? 'bg-blue-600 text-white' : 'bg-gray-100'}`}
                                        >{f.replace('_', ' ')}</button>
                                    ))}
                                </div>
                            </div>

                            {/* Tag Action Toggle */}
                            {field === 'tags' && (
                                <div className="flex gap-2">
                                    <button onClick={() => setTagAction('add')}
                                        className={`px-3 py-1 rounded text-xs font-bold ${tagAction === 'add' ? 'bg-green-600 text-white' : 'bg-gray-100'}`}
                                    >+ Add Tags</button>
                                    <button onClick={() => setTagAction('remove')}
                                        className={`px-3 py-1 rounded text-xs font-bold ${tagAction === 'remove' ? 'bg-red-600 text-white' : 'bg-gray-100'}`}
                                    >- Remove Tags</button>
                                </div>
                            )}

                            {/* Preview Current Values */}
                            <div className="bg-gray-50 p-3 rounded border">
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-2">📊 Current Values</label>
                                <div className="max-h-24 overflow-y-auto space-y-1">
                                    {preview.map(([v, count]) => (
                                        <div key={v} className="flex justify-between text-sm">
                                            <span className="truncate">{v}</span>
                                            <span className="font-bold text-gray-500">{count}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* New Value Input */}
                            <div>
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-2">
                                    {field === 'tags' ? (tagAction === 'add' ? 'Tags to Add' : 'Tags to Remove') : `New ${field}`}
                                </label>
                                {field === 'tags' ? (
                                    <TagTokenInput
                                        label=""
                                        value={tagValue}
                                        onChange={setTagValue}
                                        allBooks={books}
                                        placeholder={tagAction === 'add' ? "Add tags..." : "Remove tags..."}
                                    />
                                ) : (
                                    <>
                                        <input
                                            list="bulk-suggestions"
                                            className="w-full p-3 border rounded"
                                            placeholder={`Enter ${field}...`}
                                            value={value}
                                            onChange={e => setValue(e.target.value)}
                                        />
                                        <datalist id="bulk-suggestions">
                                            {suggestions.map(s => <option key={s} value={s} />)}
                                        </datalist>
                                    </>
                                )}
                            </div>

                            {/* Apply Button */}
                            <button
                                onClick={handleApply}
                                className="w-full py-3 bg-blue-600 text-white rounded-lg font-bold text-lg"
                            >
                                Apply to {selectedIds.length} Books
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- SLICER SEARCH ---
        const SlicerSearch = ({ books, onEdit }) => {
            const [activeFilters, setActiveFilters] = useState(() => {
                try {
                    const saved = sessionStorage.getItem('shelfLife_slicerFilters');
                    return saved ? JSON.parse(saved) : [];
                } catch { return []; }
            });
            const [pendingField, setPendingField] = useState('publisher');
            const [pendingValue, setPendingValue] = useState('');
            const [viewMode, setViewMode] = useState('grid');
            const [detailBook, setDetailBook] = useState(null);

            // Persist filters to sessionStorage
            useEffect(() => {
                sessionStorage.setItem('shelfLife_slicerFilters', JSON.stringify(activeFilters));
            }, [activeFilters]);

            const suggestions = useMemo(() => {
                const set = new Set();
                books.forEach(b => {
                    if (['publisher', 'author_name', 'owner', 'building', 'language', 'condition'].includes(pendingField)) {
                        if (b[pendingField]) set.add(b[pendingField]);
                    }
                    if (pendingField === 'tags' && b.tags) b.tags.forEach(t => set.add(t));
                    if (pendingField === 'pub_year' && b.pub_year) set.add(b.pub_year);
                });
                return [...set].sort();
            }, [books, pendingField]);

            const addFilter = () => {
                if (!pendingValue) return;
                setActiveFilters([...activeFilters, { field: pendingField, value: pendingValue }]);
                setPendingValue('');
            };

            const removeFilter = (index) => {
                const next = [...activeFilters];
                next.splice(index, 1);
                setActiveFilters(next);
            };

            const filtered = books.filter(b => {
                if (activeFilters.length === 0) return true;
                return activeFilters.every(f => {
                    if (f.field === 'tags') return b.tags && b.tags.includes(f.value);
                    return b[f.field] == f.value;
                });
            });

            return (
                <div className="pb-24 flex flex-col h-screen">
                    <div className="bg-white p-4 border-b">
                        <h2 className="text-xl font-bold mb-4">Slicer Studio</h2>

                        <div className="flex gap-2 mb-2">
                            <select className="p-2 border rounded bg-gray-50 text-sm font-bold uppercase w-1/3" value={pendingField} onChange={e => setPendingField(e.target.value)}>
                                <option value="publisher">Publisher</option><option value="author_name">Author</option><option value="owner">Owner</option><option value="tags">Tags</option><option value="language">Language</option><option value="building">Location</option><option value="pub_year">Year</option><option value="condition">Condition</option>
                            </select>
                            <AutocompleteInput
                                value={pendingValue}
                                onChange={(e) => setPendingValue(e.target.value)}
                                suggestions={suggestions}
                                placeholder="Select or type value..."
                            />
                            <button onClick={addFilter} className="bg-blue-600 text-white px-4 rounded font-bold">+</button>
                        </div>
                        <div className="flex flex-wrap gap-2 min-h-[30px]">
                            {activeFilters.length === 0 && <span className="text-xs text-gray-400 italic py-1">No active filters. Showing all books.</span>}
                            {activeFilters.map((f, i) => (
                                <span key={i} className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full flex items-center gap-1 border border-blue-200">
                                    <b>{f.field}:</b> {f.value}
                                    <button onClick={() => removeFilter(i)} className="ml-1 text-blue-500 hover:text-red-500 font-bold">×</button>
                                </span>
                            ))}
                            {activeFilters.length > 0 && (
                                <button onClick={() => setActiveFilters([])} className="text-xs bg-red-100 text-red-600 px-2 py-1 rounded-full font-bold flex items-center gap-1">
                                    <Icon name="X" size={10} /> Clear All
                                </button>
                            )}
                        </div>
                        <div className="flex justify-between items-center mt-4 pt-2 border-t">
                            <span className="text-xs font-bold text-gray-500">{filtered.length} Results</span>
                            <div className="flex gap-2 items-center">
                                <button onClick={() => setViewMode(viewMode === 'grid' ? 'list' : 'grid')} className="p-2 border rounded text-gray-500 hover:bg-gray-100"><Icon name={viewMode === 'grid' ? 'LayoutList' : 'Grid'} size={16} /></button>
                                <button onClick={() => ExportUtils.csv(filtered, 'Slicer_vew_export')} className="text-xs font-bold text-gray-500 border rounded px-2 py-1 flex gap-1 items-center hover:bg-gray-50"><Icon name="Download" size={12} /> CSV</button>
                                <button onClick={() => ExportUtils.htmlText(filtered, 'mixed', "Filtered Report")} className="text-xs font-bold text-gray-500 border rounded px-2 py-1 flex gap-1 items-center hover:bg-gray-50"><Icon name="FileText" size={12} /> HTML</button>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
                        {viewMode === 'grid' ? (
                            <div className="grid grid-cols-2 gap-4">
                                {filtered.map(b => (
                                    <div key={b.id} onClick={() => setDetailBook(b)} className="bg-white p-2 rounded shadow text-center cursor-pointer hover:shadow-md transition-shadow">
                                        {b.thumb || b.front ? <img src={b.thumb || b.front} loading="lazy" className="h-20 mx-auto object-cover mb-2 rounded" alt="" /> : <div className="h-20 bg-gray-100 flex items-center justify-center mb-2 rounded"><Icon name="Book" /></div>}
                                        <div className="font-bold text-xs truncate">{b.title}</div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-2">
                                {filtered.map(b => (
                                    <div key={b.id} onClick={() => setDetailBook(b)} className="bg-white p-3 rounded shadow flex gap-3 items-center cursor-pointer hover:bg-gray-50">
                                        {b.thumb || b.front ? <img src={b.thumb || b.front} loading="lazy" className="w-10 h-14 object-cover rounded" alt="" /> : <div className="w-10 h-14 bg-gray-200 rounded flex items-center justify-center"><Icon name="Book" size={16} /></div>}
                                        <div className="flex-1 min-w-0">
                                            <div className="font-bold text-sm truncate">{b.title}</div>
                                            <div className="text-xs text-gray-500 truncate">{b.author_name || b.author} • {b.publisher}</div>
                                        </div>
                                        <div className="text-xs font-bold text-gray-400">{b.pub_year}</div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                    {detailBook && <DetailModal book={detailBook} onClose={() => setDetailBook(null)} onEdit={(b) => { onEdit(b); setDetailBook(null) }} />}
                </div>
            );
        };

        // --- LIBRARY & DETAIL ---
        const LibraryView = ({ books, onEdit, onDeleteMulti }) => {
            const [sort, setSort] = useState({ p: 'date_added', s: 'title', dir: 'desc' });
            const [detailBook, setDetailBook] = useState(null);
            const [selectMode, setSelectMode] = useState(false);
            const [selected, setSelected] = useState([]);
            const [viewMode, setViewMode] = useState('grid');
            const [search, setSearch] = useState(() => {
                try {
                    const saved = sessionStorage.getItem('shelfLife_libraryFilters');
                    return saved ? JSON.parse(saved) : { tags: [], query: '', showDupes: false };
                } catch { return { tags: [], query: '', showDupes: false }; }
            });
            const [showBulkEdit, setShowBulkEdit] = useState(false);

            // Persist search filters to sessionStorage
            useEffect(() => {
                sessionStorage.setItem('shelfLife_libraryFilters', JSON.stringify(search));
            }, [search]);

            const suggestions = useMemo(() => {
                const s = new Set();
                books.forEach(b => {
                    if (b.title) s.add(b.title);
                    if (b.phonetic) s.add(b.phonetic);
                    if (b.author_name || b.author) s.add(b.author_name || b.author);
                    if (b.publisher) s.add(b.publisher);
                    if (b.owner) s.add(b.owner);
                    if (b.tags) b.tags.forEach(t => s.add(t));
                });
                // DynamicSearchInput handles filtering (max 20 shown)
                return [...s].sort();
            }, [books]);

            const sorted = useMemo(() => {
                const res = books.filter(b => {
                    // DUPLICATE FILTER
                    if (search.showDupes && !(b.tags || []).includes('duplicate')) return false;

                    // TEXT SEARCH
                    if (search.query) {
                        const q = search.query.toLowerCase();
                        const match = (b.title || '').toLowerCase().includes(q) ||
                            (b.phonetic || '').toLowerCase().includes(q) ||
                            (b.author || '').toLowerCase().includes(q) ||
                            (b.author_name || '').toLowerCase().includes(q) ||
                            (b.isbn || '').toLowerCase().includes(q) ||
                            (b.tags || []).some(t => t.toLowerCase().includes(q)) ||
                            (b.owner || '').toLowerCase().includes(q) ||
                            (b.building || '').toLowerCase().includes(q) ||
                            (b.shelf || '').toLowerCase().includes(q) ||
                            (b.pub_year || '').toString().includes(q) ||
                            (b.publisher || '').toLowerCase().includes(q);
                        if (!match) return false;
                    }
                    // TAG FILTER
                    if (search.tags && search.tags.length > 0) {
                        const bTags = b.tags || [];
                        if (!search.tags.every(t => bTags.includes(t))) return false;
                    }
                    return true;
                });
                return res.sort((a, b) => {
                    const vA = a[sort.p] || '', vB = b[sort.p] || '';
                    if (vA < vB) return sort.dir === 'asc' ? -1 : 1; if (vA > vB) return sort.dir === 'asc' ? 1 : -1;
                    return (a[sort.s] || '').localeCompare(b[sort.s] || '');
                });
            }, [books, sort, search]);

            const toggleSelect = (id) => {
                setSelected(prev => prev.includes(id) ? prev.filter(i => i !== id) : [...prev, id]);
            };

            const handleCardClick = (b) => {
                if (selectMode) toggleSelect(b.id); else setDetailBook(b);
            };

            const handleMultiDelete = () => { onDeleteMulti(selected); setSelected([]); setSelectMode(false); };

            return (
                <div className="pb-24">
                    <div className="bg-white p-4 sticky top-0 z-10 shadow-sm flex flex-col gap-2">
                        <div className="flex justify-between items-center flex-wrap gap-2">
                            <h2 className="text-xl font-bold">Library</h2>
                            <div className="flex gap-2 items-center flex-wrap">
                                <button onClick={() => setViewMode(viewMode === 'grid' ? 'list' : 'grid')} className="p-2 border rounded text-gray-500 hover:bg-gray-100"><Icon name={viewMode === 'grid' ? 'LayoutList' : 'Grid'} size={16} /></button>

                                {selectMode ? (
                                    <>
                                        <button onClick={() => setSelected(sorted.map(b => b.id))} className="text-xs border rounded px-2 py-1 bg-gray-50">All</button>
                                        <button onClick={() => setSelected([])} className="text-xs border rounded px-2 py-1 bg-gray-50">None</button>
                                        {selected.length > 0 && (
                                            <button onClick={() => setShowBulkEdit(true)} className="text-xs bg-blue-100 text-blue-600 px-3 py-1 rounded font-bold flex items-center gap-1">
                                                <Icon name="Edit3" size={12} /> Edit ({selected.length})
                                            </button>
                                        )}
                                        <button onClick={handleMultiDelete} className="text-xs bg-red-100 text-red-600 px-3 py-1 rounded font-bold">Delete ({selected.length})</button>
                                    </>
                                ) : (
                                    <>
                                        <button
                                            onClick={() => setSearch(s => ({ ...s, showDupes: !s.showDupes }))}
                                            className={`text-[10px] px-2 py-1 rounded border font-bold ${search.showDupes ? 'bg-red-50 text-red-600 border-red-200' : 'bg-white text-gray-500'}`}
                                        >
                                            {search.showDupes ? 'Dupes Only' : 'Show Dupes'}
                                        </button>
                                        <select className="text-xs border rounded p-1" onChange={e => setSort({ ...sort, p: e.target.value })}>
                                            <option value="date_added">Recent</option><option value="title">Title</option><option value="author">Author</option><option value="year">Year</option>
                                        </select>
                                    </>
                                )}
                                <button onClick={() => ExportUtils.csv(sorted, 'Lib_vew_export')} className="p-2 border rounded text-gray-500 hover:bg-gray-100" title="Export CSV"><Icon name="Download" size={16} /></button>
                                <button onClick={() => { setSelectMode(!selectMode); setSelected([]) }} className={`text-xs border rounded p-1 ${selectMode ? 'bg-blue-600 text-white' : 'text-gray-500'}`}>{selectMode ? 'Done' : 'Select'}</button>
                            </div>
                        </div>
                        <MultiTagInput
                            options={[...new Set(books.flatMap(b => b.tags || []))].sort()}
                            value={search.tags}
                            onChange={tags => setSearch({ ...search, tags })}
                            placeholder="Filter by tags..."
                        />
                        <div className="mt-2 text-xs flex gap-2">
                            <DynamicSearchInput
                                value={search.query}
                                onChange={e => setSearch({ ...search, query: e.target.value })}
                                suggestions={suggestions}
                                placeholder="Search Title, Author, ISBN..."
                                icon="Search"
                            />
                            {(search.query || search.tags.length > 0 || search.showDupes) && (
                                <button
                                    onClick={() => setSearch({ tags: [], query: '', showDupes: false })}
                                    className="text-xs bg-red-100 text-red-600 px-2 py-1 rounded font-bold flex items-center gap-1"
                                >
                                    <Icon name="X" size={12} /> Clear
                                </button>
                            )}
                        </div>
                    </div>

                    <div className="p-4">
                        {/* Limit results to prevent keyboard overlap while typing */}
                        {search.query && sorted.length > 6 && (
                            <div className="text-xs text-center text-gray-500 mb-2 bg-blue-50 py-1 rounded">
                                Showing 6 of {sorted.length} results. Clear search to see all.
                            </div>
                        )}
                        {viewMode === 'grid' ? (
                            <div className="grid grid-cols-2 gap-4">
                                {(search.query ? sorted.slice(0, 6) : sorted).map(b => (
                                    <div key={b.id} onClick={() => handleCardClick(b)} className={`bg-white p-3 rounded-xl shadow-sm border relative cursor-pointer ${selected.includes(b.id) ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-100'}`}>
                                        {selectMode && <div className={`absolute top-2 right-2 w-5 h-5 rounded-full border-2 ${selected.includes(b.id) ? 'bg-blue-500 border-blue-500' : 'border-gray-300'} flex items-center justify-center`}>{selected.includes(b.id) && <Icon name="CheckSquare" className="text-white" size={12} />}</div>}
                                        <div className="w-full h-40 bg-gray-100 rounded-lg overflow-hidden mb-2">
                                            {b.front ? <img src={b.front} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-300"><Icon name="Book" size={32} /></div>}
                                        </div>
                                        <h3 className="font-bold leading-tight text-sm line-clamp-2">{b.title}</h3>
                                        <p className="text-xs text-gray-500 truncate">{b.author_name || b.author}</p>
                                        <div className="absolute top-2 left-2 bg-black/50 text-white text-[10px] px-2 rounded">{b.currency || ''} {b.price}</div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-2">
                                {(search.query ? sorted.slice(0, 6) : sorted).map(b => (
                                    <div key={b.id} onClick={() => handleCardClick(b)} className={`bg-white p-3 rounded-xl shadow-sm border flex gap-3 items-center relative cursor-pointer ${selected.includes(b.id) ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-100'}`}>
                                        {selectMode && <div className={`absolute top-2 right-2 w-5 h-5 rounded-full border-2 ${selected.includes(b.id) ? 'bg-blue-500 border-blue-500' : 'border-gray-300'} flex items-center justify-center`}>{selected.includes(b.id) && <Icon name="CheckSquare" className="text-white" size={12} />}</div>}
                                        {b.front ? <img src={b.front} className="w-12 h-16 object-cover rounded" /> : <div className="w-12 h-16 bg-gray-200 rounded flex items-center justify-center"><Icon name="Book" size={16} /></div>}
                                        <div className="flex-1 min-w-0">
                                            <h3 className="font-bold text-sm truncate">{b.title}</h3>
                                            <p className="text-xs text-gray-500 truncate">{b.author_name || b.author}</p>
                                            <div className="text-[10px] text-gray-400">{b.publisher} • {b.pub_year}</div>
                                        </div>
                                        <div className="font-bold text-sm">{b.currency || ''} {b.price}</div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* DETAIL MODAL (READ ONLY + GALLERY + ZOOM) */}
                    {detailBook && (
                        <DetailModal book={detailBook} onClose={() => setDetailBook(null)} onEdit={(b) => { onEdit(b); setDetailBook(null) }} />
                    )}

                    {/* BULK EDIT MODAL */}
                    {showBulkEdit && (
                        <BulkEditModal
                            selectedIds={selected}
                            books={books}
                            onClose={() => setShowBulkEdit(false)}
                            onApply={() => { setShowBulkEdit(false); setSelected([]); setSelectMode(false); }}
                        />
                    )}
                </div>
            );
        };

        // --- DETAIL MODAL WITH ZOOM ---
        const DetailModal = ({ book, onClose, onEdit }) => {
            const [zoomImg, setZoomImg] = useState(null);
            const [scale, setScale] = useState(1);
            const [pinchDistance, setPinchDistance] = useState(null);
            const [pinchScale, setPinchScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

            // Sanitize filename helper
            const sanitizeFilename = (name) => {
                return name
                    .replace(/[/\\:*?"<>|]/g, '_')
                    .substring(0, 50)
                    .trim() || 'Untitled';
            };

            const handleSaveImage = async (imgSrc) => {
                try {
                    if (window.Capacitor) {
                        const { Filesystem } = window.Capacitor.Plugins;
                        const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                        const targetDir = Directory[baseStr] || Directory.Documents;
                        const base64Data = imgSrc.split(',')[1] || imgSrc;

                        // Save to ShelfLife/IMAGES
                        const imagesPath = 'ShelfLife/IMAGES';
                        try {
                            await Filesystem.mkdir({
                                path: imagesPath,
                                directory: targetDir,
                                recursive: true
                            });
                        } catch (mkdirErr) {
                            // Folder might already exist, ignore error
                        }

                        // Generate filename: BookTitle_Date.jpg
                        const date = new Date().toISOString().slice(0, 10);
                        const safeName = sanitizeFilename(book.title);
                        const fname = `${safeName}_${date}.jpg`;

                        try {
                            await Filesystem.writeFile({
                                path: `${imagesPath}/${fname}`,
                                data: base64Data,
                                directory: targetDir
                            });
                            alert(`✅ Saved to Images/${fname}`);
                        } catch (saveErr) {
                            // Fallback: save to root folder
                            const fallbackName = `BookImage_${Date.now()}.jpg`;
                            await Filesystem.writeFile({
                                path: `ShelfLife/${fallbackName}`,
                                data: base64Data,
                                directory: targetDir
                            });
                            alert(`⚠️ Saved to root as ${fallbackName}`);
                        }
                    } else {
                        // Web fallback: download link
                        const a = document.createElement('a');
                        a.href = imgSrc;
                        const safeName = sanitizeFilename(book.title);
                        a.download = `${safeName}_${Date.now()}.jpg`;
                        a.click();
                    }
                } catch (e) {
                    alert("❌ Save failed: " + e.message);
                }
            };

            // Pinch zoom handlers with pan support
            const handleTouchStart = (e) => {
                // Prevent pull-to-refresh when zoomed
                if (scale > 1) {
                    e.preventDefault();
                }

                if (e.touches.length === 1 && scale > 1) {
                    // Single finger drag (only when zoomed)
                    setIsDragging(true);
                    setDragStart({
                        x: e.touches[0].pageX - position.x,
                        y: e.touches[0].pageY - position.y
                    });
                } else if (e.touches.length === 2) {
                    // Pinch zoom - always prevent default
                    e.preventDefault();
                    setIsDragging(false);
                    const distance = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    setPinchDistance(distance);
                    setPinchScale(scale);
                }
            };

            const handleTouchMove = (e) => {
                if (isDragging && e.touches.length === 1) {
                    // Pan/drag image
                    e.preventDefault();
                    setPosition({
                        x: e.touches[0].pageX - dragStart.x,
                        y: e.touches[0].pageY - dragStart.y
                    });
                } else if (e.touches.length === 2 && pinchDistance) {
                    // Pinch zoom
                    e.preventDefault();
                    const distance = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    const ratio = distance / pinchDistance;
                    const newScale = Math.min(Math.max(pinchScale * ratio, 0.5), 4);
                    setScale(newScale);
                }
            };

            const handleTouchEnd = () => {
                setIsDragging(false);
                setPinchDistance(null);
            };

            // Reset scale and position when image changes
            useEffect(() => {
                if (zoomImg) {
                    setScale(1);
                    setPosition({ x: 0, y: 0 });
                    setPinchDistance(null);
                }
            }, [zoomImg]);

            // Copy book details to clipboard
            const copyBookDetails = () => {
                const text = `📚 ${book.title}${book.phonetic && book.phonetic !== book.title ? ` (${book.phonetic})` : ''}
                                ✍️ ${book.author_name || book.author || 'Unknown'}${book.author_initials ? ` (${book.author_initials})` : ''}
                                📖 ISBN: ${book.isbn || 'N/A'}
                                📅 Published: ${book.pub_year || '?'} by ${book.publisher || 'Unknown'}
                                🌐 Language: ${book.language || book.lang || 'EN'}
                                📄 Pages: ${book.page_count || 'N/A'}
                                📍 Location: ${book.building || '?'} / ${book.shelf || '?'}
                                👤 Owner: ${book.owner || 'N/A'}
                                📋 Condition: ${book.condition || 'Good'} | ${book.status === 'avail' ? 'Available' : 'Lent'}
                                💰 Value: ${book.currency || ''} ${book.price || 'N/A'}
                                🏷️ Tags: ${(book.tags || []).join(', ') || 'None'}

                                Exported from ShelfLife`;
                navigator.clipboard.writeText(text).then(() => {
                    alert('✅ Copied to clipboard!');
                }).catch(() => {
                    alert('❌ Copy failed');
                });
            };

            return (
                <div className="fixed inset-0 bg-black/80 z-50 flex items-end sm:items-center justify-center p-4 modal-overlay">
                    {zoomImg && (
                        <div className="fixed inset-0 z-[60] bg-black flex flex-col items-center justify-center modal-overlay" style={{ overscrollBehavior: 'none' }}>
                            <div
                                className="flex-1 w-full overflow-hidden flex items-center justify-center"
                                style={{ touchAction: 'none', overscrollBehavior: 'none' }}
                                onTouchStart={handleTouchStart}
                                onTouchMove={handleTouchMove}
                                onTouchEnd={handleTouchEnd}
                            >
                                <img
                                    src={zoomImg}
                                    className="max-w-none object-contain"
                                    style={{
                                        transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,
                                        transformOrigin: 'center',
                                        maxHeight: '85vh'
                                    }}
                                    onDoubleClick={() => { setScale(s => s > 1 ? 1 : 2); setPosition({ x: 0, y: 0 }); }}
                                />
                            </div>
                            <div className="absolute bottom-6 flex gap-4">
                                <button onClick={() => setScale(s => Math.min(s + 0.5, 4))} className="text-white p-3 bg-white/20 rounded-full">
                                    <Icon name="Plus" size={24} />
                                </button>
                                <button onClick={() => setScale(s => Math.max(s - 0.5, 0.5))} className="text-white p-3 bg-white/20 rounded-full">
                                    <Icon name="Minus" size={24} />
                                </button>
                                <button onClick={() => handleSaveImage(zoomImg)} className="text-white p-3 bg-green-600 rounded-full">
                                    <Icon name="Download" size={24} />
                                </button>
                            </div>
                            <button onClick={() => { setZoomImg(null); setScale(1); setPosition({ x: 0, y: 0 }); }} className="absolute top-4 right-4 text-white p-2 bg-black/50 rounded-full">
                                <Icon name="X" size={32} />
                            </button>
                        </div>
                    )}

                    <div className="bg-white w-full max-w-md rounded-2xl overflow-hidden max-h-[90vh] overflow-y-auto modal-content">
                        <div className="relative h-64 bg-gray-100 overflow-x-auto whitespace-nowrap flex">
                            {/* Gallery View */}
                            {book.front && <img src={book.front} onClick={() => setZoomImg(book.front)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />}
                            {book.rear && <img src={book.rear} onClick={() => setZoomImg(book.rear)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />}
                            {(book.pages || []).map((p, i) => <img key={i} src={p} onClick={() => setZoomImg(p)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />)}
                            <button onClick={onClose} className="absolute top-4 right-4 bg-white/50 p-2 rounded-full"><Icon name="X" /></button>
                        </div>
                        <div className="p-4">
                            {/* Header with title and copy button */}
                            <div className="flex justify-between items-start mb-4">
                                <div className="flex-1">
                                    <h1 className="text-xl font-bold">{book.title}</h1>
                                    {book.phonetic && book.phonetic !== book.title && <p className="text-gray-500 text-sm italic">{book.phonetic}</p>}
                                    <p className="text-gray-600">{book.author_name || book.author} {book.author_initials && `(${book.author_initials})`}</p>
                                </div>
                                <button onClick={copyBookDetails} className="p-2 bg-blue-100 rounded-lg hover:bg-blue-200" title="Copy details">
                                    <Icon name="Copy" size={18} />
                                </button>
                            </div>

                            {/* Compact table with ALL fields */}
                            <div className="grid grid-cols-[auto_1fr] gap-x-3 gap-y-2 text-sm mb-4 bg-gray-50 p-3 rounded-lg">
                                <span className="text-gray-500">ISBN:</span>
                                <span className="font-medium">{book.isbn || '-'}</span>

                                <span className="text-gray-500">Publisher:</span>
                                <span className="font-medium">{book.publisher || '-'}</span>

                                <span className="text-gray-500">Year:</span>
                                <span className="font-medium">{book.pub_year || '-'}</span>

                                <span className="text-gray-500">Language:</span>
                                <span className="font-medium">{book.language || book.lang?.toUpperCase() || 'EN'}</span>

                                <span className="text-gray-500">Pages:</span>
                                <span className="font-medium">{book.page_count || '-'}</span>

                                <span className="text-gray-500">Building:</span>
                                <span className="font-medium">{book.building || '-'}</span>

                                <span className="text-gray-500">Shelf:</span>
                                <span className="font-medium">{book.shelf || '-'}</span>

                                <span className="text-gray-500">Owner:</span>
                                <span className="font-medium">{book.owner || '-'}</span>

                                <span className="text-gray-500">Condition:</span>
                                <span className="font-medium">{book.condition || 'Good'}</span>

                                <span className="text-gray-500">Status:</span>
                                <span className={`font-medium ${book.status === 'avail' ? 'text-green-600' : 'text-orange-600'}`}>
                                    {book.status === 'avail' ? '✓ Available' : '◈ Lent Out'}
                                </span>

                                <span className="text-gray-500">Price:</span>
                                <span className="font-medium">{book.currency || ''} {book.price || '-'}</span>
                            </div>

                            {/* Tags section */}
                            {(book.tags || []).length > 0 && (
                                <div className="mb-4">
                                    <span className="text-gray-500 text-xs uppercase font-bold block mb-1">Tags</span>
                                    <div className="flex flex-wrap gap-1">
                                        {book.tags.map((tag, i) => (
                                            <span key={i} className="px-2 py-0.5 bg-blue-100 text-blue-800 rounded text-xs">{tag}</span>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <button onClick={() => onEdit(book)} className="w-full py-3 bg-blue-600 text-white font-bold rounded-xl flex items-center justify-center gap-2">
                                <Icon name="Edit3" /> Edit / Update
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD ---
        const Dashboard = ({ books, onNavigateToSlicer }) => {
            const total = books.length;
            // Group by currency
            const assetBreakdown = useMemo(() => {
                const groups = {};
                books.forEach(b => {
                    const curr = b.currency || '?';
                    groups[curr] = (groups[curr] || 0) + (Number(b.price) || 0);
                });
                return groups;
            }, [books]);

            const pubStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.publisher || 'Unknown'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);
            }, [books]);

            // NEW: Lang/Loc Stats for Dash
            const langStats = useMemo(() => {
                const c = {}; books.forEach(b => { c[b.lang || 'en'] = (c[b.lang || 'en'] || 0) + 1 });
                const total = books.length || 1; let current = 0;
                const colors = { en: '#3b82f6', ml: '#10b981', ar: '#f59e0b', hi: '#ef4444' };
                return Object.entries(c).map(([l, v]) => {
                    const pct = (v / total) * 100; const str = `${colors[l] || '#ccc'} ${current}% ${current + pct}%`; current += pct; return str;
                }).join(', ');
            }, [books]);

            const locStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.building || 'Unknown'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);
            }, [books]);

            const tagStats = useMemo(() => {
                const c = {}; books.forEach(b => { if (b.tags) b.tags.forEach(t => c[t] = (c[t] || 0) + 1) });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);
            }, [books]);

            const condStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.condition || 'Good'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]);
            }, [books]);

            const ownerStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.owner || 'Unassigned'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);
            }, [books]);

            const repairList = books.filter(b => b.condition === 'Torn' || b.condition === 'Loose' || (b.tags && b.tags.includes('repair')));

            return (
                <div className="p-4 space-y-6 pb-24">
                    <h2 className="text-2xl font-bold">Analytics</h2>
                    <div className="grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow border border-blue-100"><p className="text-xs text-gray-500 font-bold uppercase">Total Books</p><p className="text-3xl font-bold text-blue-600">{total}</p></div>
                        <div className="bg-white p-4 rounded-xl shadow border border-green-100"><p className="text-xs text-gray-500 font-bold uppercase">Asset Value</p>
                            {Object.entries(assetBreakdown).map(([curr, val]) => (
                                <div key={curr} className="text-lg font-bold text-green-600">{curr} {val.toLocaleString()}</div>
                            ))}
                            {Object.keys(assetBreakdown).length === 0 && <p className="text-xl font-bold text-gray-400">0</p>}
                        </div>
                    </div>

                    {repairList.length > 0 && <div className="bg-red-50 p-4 rounded-xl border border-red-200 text-red-800 font-bold flex items-center gap-2"><Icon name="AlertCircle" /> {repairList.length} Books Need Repair</div>}

                    <div className="bg-white p-4 rounded-xl shadow border flex gap-4">
                        <div className="pie-chart flex-shrink-0" style={{ '--pie-gradient': langStats }}></div>
                        <div><h3 className="font-bold mb-2">Language Mix</h3><div className="text-xs text-gray-500">Visual breakdown of your library languages.</div></div>
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Top Publishers</h3>
                        {pubStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('publisher', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-purple-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Locations</h3>
                        {locStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('building', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-blue-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Top Tags</h3>
                        {tagStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('tags', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-green-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">By Owner</h3>
                        {ownerStats.length === 0 && <p className="text-gray-400 text-sm">No owners assigned</p>}
                        {ownerStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('owner', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-orange-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Condition</h3>
                        {condStats.map(([k, v]) => (
                            <div key={k} onClick={() => onNavigateToSlicer && onNavigateToSlicer('condition', k)} className="mb-2 cursor-pointer hover:bg-gray-50 rounded -mx-2 px-2 py-1"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-red-400" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- TOOLS ---
        const Tools = ({ books }) => {
            const [lastRestore, setLastRestore] = useState(null);
            const [showWhatsNew, setShowWhatsNew] = useState(false);
            const [showReports, setShowReports] = useState(false);
            const [showTagManager, setShowTagManager] = useState(false);
            const [showHelp, setShowHelp] = useState(false);
            const [imageExportStatus, setImageExportStatus] = useState({ exporting: false, current: 0, total: 0, message: '' });
            const APP_VERSION = '2.5.0';
            const BUILD_DATE = '2025-12-29 18:10';
            const COMMIT_HASH = 'd12d6f2';

            useEffect(() => {
                try {
                    const stored = localStorage.getItem('shelfLife_restore_meta');
                    if (stored) setLastRestore(JSON.parse(stored));
                } catch (e) {
                    console.error("Failed to parse restore meta:", e);
                    setLastRestore(null);
                }
            }, []);

            // Consolidated Chunked Backup Helper
            const performChunkedBackup = async (textOnly = false) => {
                if (!window.Capacitor) { alert("Backup requires Android App (Native Filesystem)."); return; }
                try {
                    const { Filesystem, Device } = window.Capacitor.Plugins;
                    const allBooks = await db.books.toArray();
                    const now = new Date();
                    const ts = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0') + '_' + String(now.getHours()).padStart(2, '0') + '-' + String(now.getMinutes()).padStart(2, '0') + '-' + String(now.getSeconds()).padStart(2, '0');

                    // NEW FOLDER: ShelfLife/Backups
                    const folder = 'ShelfLife/Backups';
                    const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                    const targetDir = Directory[baseStr] || Directory.Documents;

                    // Ensure Folders
                    try { await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true }); } catch (e) { }

                    const TARGET_SIZE = 9 * 1024 * 1024; // 9MB safe limit for chunks
                    let part = 1;
                    let currentChunk = [];
                    let currentSize = 0;
                    const typePrefix = textOnly ? 'TXT_BK' : 'FULL_BK';
                    const deviceName = localStorage.getItem('shelfLife_deviceName') || 'MYPHONE';

                    // Get device info for signature
                    let deviceInfo = { model: 'Unknown', platform: 'unknown' };
                    try {
                        if (Device) {
                            const info = await Device.getInfo();
                            deviceInfo = { model: info.model || 'Unknown', platform: info.platform || 'unknown', manufacturer: info.manufacturer || '' };
                        }
                    } catch (e) { }

                    // Create signature object to include in first chunk
                    const signature = {
                        __shelflife_signature__: {
                            version: '2.0',
                            created: now.toISOString(),
                            device_nickname: deviceName,
                            device_model: deviceInfo.model,
                            device_manufacturer: deviceInfo.manufacturer,
                            device_platform: deviceInfo.platform,
                            type: typePrefix,
                            book_count: allBooks.length
                        }
                    };

                    // Always include signature in first chunk
                    currentChunk.push(signature);
                    currentSize += JSON.stringify(signature).length;

                    for (const rawBook of allBooks) {
                        const book = textOnly ? { ...rawBook, front: null, rear: null, thumb: null, pages: [] } : rawBook;
                        const s = JSON.stringify(book);
                        if (currentSize + s.length > TARGET_SIZE && currentChunk.length > 0) {
                            const fname = `SL_${typePrefix}_${deviceName}_Part${part}_${ts}.json`;
                            await Filesystem.writeFile({
                                path: `${folder}/${fname}`,
                                data: JSON.stringify(currentChunk),
                                directory: targetDir,
                                encoding: Encoding.UTF8
                            });
                            part++;
                            currentChunk = [];
                            currentSize = 0;
                        }
                        currentChunk.push(book);
                        currentSize += s.length;
                    }

                    if (currentChunk.length > 0) {
                        const fname = `SL_${typePrefix}_${deviceName}_Part${part}_${ts}.json`;
                        await Filesystem.writeFile({
                            path: `${folder}/${fname}`,
                            data: JSON.stringify(currentChunk),
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                    }

                    alert(`Backup (${textOnly ? 'Text Only' : 'Full'}) Complete!\nSaved ${part} file(s) to:\n${baseStr}/${folder}/\n\nDevice: ${deviceName}\nModel: ${deviceInfo.model}`);

                    // Track backup for reminder system
                    localStorage.setItem('shelfLife_lastBackupDate', new Date().toISOString());
                    localStorage.setItem('shelfLife_entriesSinceBackup', '0');
                } catch (e) {
                    alert("Backup Error: " + e.message);
                }
            };

            // Native Restore Helper (REVERTED TO MANUAL SCAN to prevent FilePicker Crashes)
            const performNativeRestore = async () => {
                if (!window.Capacitor) { alert("Restore requires Android App (Native Filesystem)."); return; }
                try {
                    const { Filesystem } = window.Capacitor.Plugins;

                    // Force Manual/Default Folder Logic (Safer)
                    const folder = localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups';
                    const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                    const targetDir = Directory[baseStr] || Directory.Documents;

                    let folderInput = folder;
                    // Optional: Ask user to confirm folder if they want to change it
                    // folderInput = prompt("Confirm Backup Folder to Scan:", folder);
                    if (!folderInput) return;

                    // Read the folder
                    const ret = await Filesystem.readdir({
                        path: folderInput,
                        directory: targetDir
                    }).catch(e => {
                        // If default fails, maybe try the root Documents?
                        // But for now, just return empty to show "No backups"
                        return { files: [] };
                    });

                    // Parse Backup Files
                    const groups = {};
                    (ret.files || []).forEach(f => {
                        // ... (rest of parsing logic remains same)
                        const name = f.name;
                        let ts = null;
                        // NEW format: SL_FULL_BK_DEVICE_Part1_TIMESTAMP.json or SL_TXT_BK_...
                        const mNew2 = name.match(/SL_(?:FULL_BK|TXT_BK)_(.+)_Part\d+_(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}(?:-\d{2})?)\.json/);
                        // OLD format: SL_BK_DEVICE_Part1_TIMESTAMP.json
                        const mNew = name.match(/SL_BK_(.+)_Part\d+(?:_TextOnly)?_(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})\.json/);
                        if (mNew2) {
                            ts = `${mNew2[1]} (${mNew2[2]})`;
                        } else if (mNew) {
                            ts = `${mNew[1]} (${mNew[2]})`;
                        } else {
                            const mold = name.match(/ShelfLife_Part\d+(?:_TextOnly)?_(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})\.json/);
                            if (mold) ts = `UnknownDevice (${mold[1]})`;
                        }

                        if (ts) {
                            if (!groups[ts]) groups[ts] = 0;
                            groups[ts]++;
                        }
                    });

                    const choices = Object.keys(groups).sort().reverse();
                    if (choices.length === 0) {
                        // DEBUG: Show what files were actually found
                        const fileList = (ret.files || []).map(f => f.name).slice(0, 10);
                        const debugInfo = fileList.length > 0
                            ? `\n\nFiles found (first 10):\n${fileList.join('\n')}`
                            : '\n\n(Folder appears empty or unreadable)';
                        alert(`No backups found in ${baseStr}/${folderInput}.${debugInfo}\n\nExpected format:\nSL_BK_DEVICE_Part1_YYYY-MM-DD_HH-MM-SS.json`);
                        return;
                    }

                    // ... (Rest of selection and restore logic)
                    const selection = prompt(`Found ${choices.length} Backup Sets:\n` + choices.map((c, i) => `${i + 1}. ${c} \n   [${groups[c]} files]`).join('\n') + "\n\nEnter number to restore:");
                    if (!selection) return;
                    const index = parseInt(selection) - 1;
                    if (isNaN(index) || index < 0 || index >= choices.length) return;

                    const targetSet = choices[index];

                    const modeInput = prompt(`Selected: ${targetSet}\n\nChoose Restore Mode:\n[1] REPLACE (Wipe & Import)\n[2] APPEND (Add New, Skip Duplicates)\n[3] MERGE (Add All, Mark Duplicates)\n\nEnter 1, 2, or 3:`, "1");

                    if (!modeInput || !['1', '2', '3'].includes(modeInput)) return;
                    const modeMap = { '1': 'Replace', '2': 'Append', '3': 'Merge' };
                    const mode = modeMap[modeInput];

                    if (mode === 'Replace' && !confirm("WARNING: REPLACE mode will PERMANENTLY DELETE your current library.\nAre you sure?")) return;

                    if (mode === 'Replace') await db.books.clear();
                    const existingBooks = (mode !== 'Replace') ? await db.books.toArray() : [];

                    const isDuplicate = (newB, existB) => {
                        return existB.some(b =>
                            (b.title || '').toLowerCase().trim() === (newB.title || '').toLowerCase().trim() &&
                            (b.author_name || b.author || '').toLowerCase().trim() === (newB.author_name || newB.author || '').toLowerCase().trim() &&
                            (b.language || 'en') === (newB.language || 'en') &&
                            (b.building || '').toLowerCase().trim() === (newB.building || '').toLowerCase().trim()
                        );
                    };

                    const isLegacy = targetSet.startsWith("UnknownDevice");
                    // Match timestamp with or without seconds
                    const datePart = targetSet.match(/\d{4}-\d{2}-\d{2}_\d{2}-\d{2}(?:-\d{2})?/)[0];
                    const fileList = (ret.files || []).filter(f => f.name.includes(datePart)).sort();

                    let stats = { total: 0, added: 0, duplicates: 0, skipped: 0 };

                    for (const f of fileList) {
                        const c = await Filesystem.readFile({
                            path: `${folderInput}/${f.name}`,
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        const chunkData = JSON.parse(c.data);
                        stats.total += chunkData.length;

                        const toAdd = [];
                        for (let book of chunkData) {
                            if (book.author && !book.author_name) {
                                const parts = book.author.trim().split(' ');
                                let name = parts.pop() || '';
                                let initials = parts.join(' ') || '';
                                if (!initials && !name) name = book.author;
                                book.author_name = name;
                                book.author_initials = initials;
                                delete book.author;
                            }

                            if (mode === 'Replace') {
                                toAdd.push(book);
                                stats.added++;
                            } else {
                                const dup = isDuplicate(book, existingBooks);
                                if (dup) {
                                    stats.duplicates++;
                                    if (mode === 'Merge') {
                                        book.tags = [...(book.tags || []), 'duplicate'];
                                        toAdd.push(book);
                                        stats.added++;
                                    } else {
                                        stats.skipped++;
                                    }
                                } else {
                                    toAdd.push(book);
                                    stats.added++;
                                }
                            }
                        }

                        if (toAdd.length > 0) {
                            await db.books.bulkAdd(toAdd);
                            if (mode !== 'Replace') existingBooks.push(...toAdd);
                        }
                    }

                    const logEntry = {
                        id: 'log_' + Date.now(),
                        timestamp: new Date().toISOString(),
                        source: targetSet,
                        mode: mode,
                        total: stats.total,
                        added: stats.added,
                        duplicates: stats.duplicates,
                        skipped: stats.skipped,
                        status: 'Success'
                    };
                    const logs = JSON.parse(localStorage.getItem('shelfLife_restoreLogs') || '[]');
                    logs.unshift(logEntry);
                    localStorage.setItem('shelfLife_restoreLogs', JSON.stringify(logs.slice(0, 50)));
                    localStorage.setItem('shelfLife_restore_meta', JSON.stringify({ name: targetSet, date: new Date().toLocaleString() }));

                    alert(`Restore Complete (${mode})\n\nScanned: ${stats.total}\nAdded: ${stats.added}\nDuplicates: ${stats.duplicates}\nSkipped: ${stats.skipped}`);
                    window.location.reload();

                } catch (e) {
                    alert("Restore Error: " + e.message);
                }
            };

            // Legacy/Single File Import
            const handleLegacyImport = (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (evt) => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        if (!Array.isArray(data)) throw new Error("Invalid JSON Format");
                        if (!confirm(`Restore ${data.length} books from file "${file.name}"?\nWarning: This will REPLACE your library.`)) return;

                        await db.books.clear();
                        await db.books.bulkAdd(data);
                        alert("Legacy Restore Complete!");
                        window.location.reload();
                    } catch (err) {
                        alert("Import Failed: " + err.message);
                    }
                };
                reader.readAsText(file);
            };

            // Smart Restore: Pick one file, app handles all chunks
            const handleSmartRestore = async (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                // Allow multi-select for all parts
                const allFiles = Array.from(files).filter(f => f.name.endsWith('.json'));
                if (allFiles.length === 0) { alert("No JSON files selected"); return; }

                // Sort by filename to ensure Part1, Part2... order
                allFiles.sort((a, b) => a.name.localeCompare(b.name));

                // Parse first file to get signature info
                const firstFileContent = await readFileAsText(allFiles[0]);
                const firstData = JSON.parse(firstFileContent);
                const signature = firstData.find(b => b.__shelflife_signature__)?.__shelflife_signature__;

                const signatureInfo = signature
                    ? `Device: ${signature.device_nickname || 'Unknown'}\nModel: ${signature.device_model || 'Unknown'}\nBooks: ${signature.book_count || '?'}`
                    : 'Legacy backup (no signature)';

                const modeInput = prompt(`Restoring ${allFiles.length} file(s):\n${allFiles.map(f => f.name).join('\n')}\n\n${signatureInfo}\n\nChoose Restore Mode:\n[1] REPLACE (Wipe & Import)\n[2] APPEND (Add New, Skip Duplicates)\n[3] MERGE (Add All, Mark Duplicates)\n\nEnter 1, 2, or 3:`, "1");

                if (!modeInput || !['1', '2', '3'].includes(modeInput)) return;
                const modeMap = { '1': 'Replace', '2': 'Append', '3': 'Merge' };
                const mode = modeMap[modeInput];

                if (mode === 'Replace' && !confirm("WARNING: REPLACE mode will PERMANENTLY DELETE your current library.\nAre you sure?")) return;

                if (mode === 'Replace') await db.books.clear();
                const existingBooks = (mode !== 'Replace') ? await db.books.toArray() : [];

                const isDuplicate = (newB, existB) => {
                    return existB.some(b =>
                        (b.title || '').toLowerCase().trim() === (newB.title || '').toLowerCase().trim() &&
                        (b.author_name || b.author || '').toLowerCase().trim() === (newB.author_name || newB.author || '').toLowerCase().trim() &&
                        (b.language || 'en') === (newB.language || 'en') &&
                        (b.building || '').toLowerCase().trim() === (newB.building || '').toLowerCase().trim()
                    );
                };

                let stats = { total: 0, added: 0, duplicates: 0, skipped: 0 };

                for (const file of allFiles) {
                    try {
                        const content = await readFileAsText(file);
                        const chunkData = JSON.parse(content);

                        const toAdd = [];
                        for (let book of chunkData) {
                            // Skip signature objects
                            if (book.__shelflife_signature__) continue;

                            stats.total++;

                            // Author migration
                            if (book.author && !book.author_name) {
                                const parts = book.author.trim().split(' ');
                                let name = parts.pop() || '';
                                let initials = parts.join(' ') || '';
                                if (!initials && !name) name = book.author;
                                book.author_name = name;
                                book.author_initials = initials;
                                delete book.author;
                            }

                            if (mode === 'Replace') {
                                toAdd.push(book);
                                stats.added++;
                            } else {
                                const dup = isDuplicate(book, existingBooks);
                                if (dup) {
                                    stats.duplicates++;
                                    if (mode === 'Merge') {
                                        book.tags = [...(book.tags || []), 'duplicate'];
                                        toAdd.push(book);
                                        stats.added++;
                                    } else {
                                        stats.skipped++;
                                    }
                                } else {
                                    toAdd.push(book);
                                    stats.added++;
                                }
                            }
                        }

                        if (toAdd.length > 0) {
                            await db.books.bulkAdd(toAdd);
                            if (mode !== 'Replace') existingBooks.push(...toAdd);
                        }
                    } catch (err) {
                        console.error(`Error processing ${file.name}:`, err);
                    }
                }
                // Generate automatic restore logs (TXT and CSV)
                const now = new Date();
                const ts = now.toISOString().replace(/[:.]/g, '-').slice(0, 16);
                const logFolder = 'ShelfLife/Restore';
                const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';

                const txtLog = `========================================
                                ShelfLife Restore Log
========================================
Date: ${now.toLocaleString()}
Mode: ${mode.toUpperCase()}
----------------------------------------
SOURCE FILES:
${allFiles.map((f, i) => `${i + 1}. ${f.name}`).join('\n')}
${signature ? `\nBackup Device: ${signature.device_nickname || 'Unknown'}\nBackup Model: ${signature.device_model || 'Unknown'}` : '\nLegacy backup (no signature)'}
----------------------------------------
RESULT:
Total Scanned: ${stats.total}
Added: ${stats.added}
Duplicates Found: ${stats.duplicates}
Skipped: ${stats.skipped}
========================================`;

                const csvLog = `Date,Mode,Files,Scanned,Added,Duplicates,Skipped\n"${now.toISOString()}","${mode}","${allFiles.map(f => f.name).join('; ')}",${stats.total},${stats.added},${stats.duplicates},${stats.skipped}`;

                // Save logs if on Capacitor
                if (window.Capacitor) {
                    try {
                        const { Filesystem } = window.Capacitor.Plugins;
                        const targetDir = Directory[baseStr] || Directory.Documents;

                        await Filesystem.writeFile({
                            path: `${logFolder}/restore_log_${ts}.txt`,
                            directory: targetDir,
                            data: txtLog,
                            encoding: Encoding.UTF8
                        });

                        await Filesystem.writeFile({
                            path: `${logFolder}/restore_log_${ts}.csv`,
                            directory: targetDir,
                            data: csvLog,
                            encoding: Encoding.UTF8
                        });
                    } catch (logErr) {
                        console.error('Failed to save restore logs:', logErr);
                    }
                }

                alert(`Restore Complete (${mode})\n\nScanned: ${stats.total}\nAdded: ${stats.added}\nDuplicates: ${stats.duplicates}\nSkipped: ${stats.skipped}\n\n📝 Logs saved to ${logFolder}/`);
                window.location.reload();
            };

            // Helper to read file as text
            const readFileAsText = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsText(file);
                });
            };
            const verifyFolder = async () => {
                if (!window.Capacitor) return alert("This feature requires the Android app.");
                try {
                    const { Filesystem } = window.Capacitor.Plugins;
                    const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                    const targetDir = Directory[baseStr] || Directory.Documents;

                    // NEW FOLDER STRUCTURE (v2.2+)
                    const root = 'ShelfLife';
                    const folders = [
                        root,
                        `${root}/Backups`,
                        `${root}/IMAGES`,
                        `${root}/Restore`,
                        `${root}/Exports`,
                        `${root}/to_merge`
                    ];

                    // Create all folders
                    for (const f of folders) {
                        try {
                            await Filesystem.mkdir({ path: f, directory: targetDir, recursive: true });
                        } catch (e) {
                            // Ignore if exists
                        }
                    }

                    await Filesystem.writeFile({
                        path: `${root}/Backups/Test_Write.txt`,
                        data: "Access Verified " + new Date().toISOString(),
                        directory: targetDir,
                        encoding: Encoding.UTF8
                    });

                    alert(`Storage Verified! ✅\n\nCreated/Verified:\n📂 ${root}/\n  ├─ Backups/\n  ├─ IMAGES/\n  ├─ Restore/\n  ├─ Exports/\n  └─ to_merge/`);
                } catch (err) {
                    alert(`Storage Error: ${err.message}\nCheck app permissions.`);
                }
            };

            // Sync to folder for recovery (enhanced: delete old, show comparison)
            const syncToFolder = async () => {
                try {
                    const { Filesystem } = window.Capacitor.Plugins;
                    // Use global Directory and Encoding constants (defined at top of file)
                    const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                    const targetDir = Directory[baseStr] || Directory.Documents;
                    const folder = 'ShelfLife/sync_root_folder';

                    // Create folder (ignore error if already exists)
                    try {
                        await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true });
                    } catch (mkdirErr) {
                        // Ignore "directory exists" errors - this is expected
                        if (!mkdirErr.message?.includes('exist')) {
                            throw mkdirErr;
                        }
                    }

                    // Read existing sync files for comparison
                    let previousCount = 0;
                    let oldFiles = [];
                    try {
                        const dirContents = await Filesystem.readdir({ path: folder, directory: targetDir });
                        oldFiles = dirContents.files.filter(f => f.name && f.name.startsWith('shelflife_sync_') && f.name.endsWith('.json'));

                        // Read the most recent sync file to get previous count
                        if (oldFiles.length > 0) {
                            const latestFile = oldFiles.sort((a, b) => (b.name || '').localeCompare(a.name || ''))[0];
                            try {
                                const prevData = await Filesystem.readFile({
                                    path: `${folder}/${latestFile.name}`,
                                    directory: targetDir,
                                    encoding: Encoding.UTF8
                                });
                                const parsed = JSON.parse(prevData.data);
                                previousCount = parsed.count || 0;
                            } catch (e) { /* ignore read errors */ }
                        }
                    } catch (e) { /* folder may not exist yet */ }

                    const allBooks = await db.books.toArray();
                    const deviceName = localStorage.getItem('shelfLife_deviceName') || 'Unknown';
                    const syncData = {
                        _shelflife_sync: true,
                        timestamp: new Date().toISOString(),
                        version: APP_VERSION,
                        device: deviceName,
                        count: allBooks.length,
                        books: allBooks
                    };

                    const filename = `shelflife_sync_${deviceName}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                    await Filesystem.writeFile({
                        path: `${folder}/${filename}`,
                        data: JSON.stringify(syncData),
                        directory: targetDir,
                        encoding: Encoding.UTF8
                    });

                    // Delete old sync files
                    for (const oldFile of oldFiles) {
                        try {
                            await Filesystem.deleteFile({ path: `${folder}/${oldFile.name}`, directory: targetDir });
                        } catch (e) { /* ignore delete errors */ }
                    }

                    // Show comparison
                    const diff = allBooks.length - previousCount;
                    const diffText = previousCount === 0 ? 'First sync!' :
                        (diff > 0 ? `+${diff} new books since last sync` :
                            diff < 0 ? `${diff} books (some deleted)` : 'No change in book count');

                    alert(`✅ Sync Complete!\n\n📚 ${allBooks.length} books\n📊 ${diffText}\n📱 Device: ${deviceName}\n📂 ${folder}/${filename}\n\n${oldFiles.length > 0 ? `🗑️ Deleted ${oldFiles.length} old sync file(s)` : ''}`);
                } catch (err) {
                    alert(`Sync Error: ${err.message}\nCheck app permissions.`);
                }
            };

            // --- SETTINGS COMPONENT FIX ---
            const [tempDeviceName, setTempDeviceName] = useState(localStorage.getItem('shelfLife_deviceName') || 'MYPHONE');

            return (
                <div className="p-4 space-y-4 pb-24">
                    <h2 className="text-2xl font-bold">Tools</h2>

                    {/* ABOUT SECTION */}
                    <div className="bg-gradient-to-br from-blue-500 to-blue-700 p-4 rounded-xl shadow-lg text-white">
                        <h3 className="font-bold text-xl mb-2">📚 ShelfLife</h3>
                        <div className="space-y-1 text-sm">
                            <p><span className="font-bold">Version:</span> {APP_VERSION}</p>
                            <p><span className="font-bold">Build:</span> {BUILD_DATE}</p>
                            <p><span className="font-bold">Commit:</span> {COMMIT_HASH}</p>
                        </div>
                        <div className="mt-3 pt-3 border-t border-white/30">
                            <button
                                onClick={() => setShowWhatsNew(!showWhatsNew)}
                                className="text-xs font-bold mb-1 flex items-center gap-1 hover:underline w-full"
                            >
                                ✨ What's New in v2.5 {showWhatsNew ? '▼' : '▶'}
                            </button>
                            {showWhatsNew && (
                                <ul className="text-xs space-y-0.5 list-disc list-inside mt-2">
                                    <li>📷 Improved camera (Capacitor plugin)</li>
                                    <li>🏷️ Tag Manager: Browse All, Title Case</li>
                                    <li>📁 Merge Studio: Multi-folder picker</li>
                                    <li>💾 Sync to Folder with comparison</li>
                                    <li>🔍 Slicer: Keyboard-aware search</li>
                                    <li>📚 Help Guide (in Tools section)</li>
                                </ul>
                            )}
                        </div>
                    </div>

                    {/* REPORTS SECTION - COLLAPSIBLE */}
                    <div className="bg-white p-4 rounded-xl shadow border border-blue-100">
                        <button
                            onClick={() => setShowReports(!showReports)}
                            className="w-full font-bold text-blue-800 flex justify-between items-center"
                        >
                            <span className="flex items-center gap-2"><Icon name="BarChart2" size={18} /> Reports & Exports</span>
                            <Icon name={showReports ? 'ChevronUp' : 'ChevronDown'} size={18} />
                        </button>

                        {showReports && (
                            <div className="mt-3 pt-3 border-t">
                                <p className="text-[10px] text-gray-400 mb-2 italic">Reports saved to ShelfLife/Exports</p>
                                <div className="space-y-2">
                                    <button onClick={() => ExportUtils.htmlText(books, 'Mix', 'Library Inventory')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="List" /> HTML Text Report</button>
                                    <button onClick={() => ExportUtils.htmlVisual(books, 'Mix', 'Visual Catalogue')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="Image" /> HTML Visual Catalogue</button>
                                    <button onClick={() => ExportUtils.csv(books, 'Library_Export')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="Download" /> Export CSV</button>

                                    {/* Export Images to ZIP */}
                                    <button
                                        onClick={async () => {
                                            if (imageExportStatus.exporting) return;
                                            setImageExportStatus({ exporting: true, current: 0, total: 0, message: 'Preparing...' });
                                            const result = await ExportUtils.imagesZip(books, (current, total, message) => {
                                                setImageExportStatus({ exporting: true, current, total, message });
                                            });
                                            setImageExportStatus({ exporting: false, current: 0, total: 0, message: '' });
                                            if (result.success) {
                                                const fileList = result.files.map(f => `• ${f.filename} (${f.imageCount} images, ~${f.sizeMB}MB)`).join('\n');
                                                alert(`✅ Exported ${result.totalImages} images!\n\n${result.totalParts} ZIP file(s):\n${fileList}\n\nSaved to: ${result.folder}`);
                                            } else if (result.error && result.error !== 'User cancelled') {
                                                const partialMsg = result.partialFiles?.length ? `\n(Partial: ${result.partialFiles.length} files saved before error)` : '';
                                                alert(`❌ Export failed: ${result.error}${partialMsg}`);
                                            }
                                        }}
                                        disabled={imageExportStatus.exporting}
                                        className={`w-full py-3 rounded-lg flex items-center justify-center gap-2 text-sm transition ${imageExportStatus.exporting ? 'bg-green-100 text-green-700' : 'bg-green-50 hover:bg-green-100 text-green-700'}`}
                                    >
                                        {imageExportStatus.exporting ? (
                                            <>
                                                <span className="animate-pulse">📦</span>
                                                <span className="text-xs">{imageExportStatus.message} ({imageExportStatus.current}/{imageExportStatus.total})</span>
                                            </>
                                        ) : (
                                            <><Icon name="Image" /> Export Images (ZIP)</>
                                        )}
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* TAG MANAGER SECTION */}
                    <div className="bg-white p-4 rounded-xl shadow border border-purple-100">
                        <h3 className="font-bold mb-3 text-purple-800 flex items-center gap-2"><Icon name="Tag" size={18} /> Tag Manager</h3>
                        <p className="text-xs text-gray-500 mb-3">Manage all your tags in one place - rename, delete, merge duplicates.</p>
                        <button
                            onClick={() => setShowTagManager(true)}
                            className="w-full py-3 bg-purple-50 text-purple-700 rounded-lg flex items-center justify-center gap-2 text-sm font-bold hover:bg-purple-100 transition"
                        >
                            <Icon name="Tag" size={18} /> Open Tag Manager
                        </button>
                    </div>

                    {/* BACKUP & RESTORE SECTION */}
                    <div className="bg-white p-4 rounded-xl shadow border border-orange-100">
                        <h3 className="font-bold mb-3 text-orange-800">Backup & Restore</h3>
                        {lastRestore && <div className="text-xs text-gray-500 mb-3 bg-gray-50 p-2 rounded border">Last Restored: <b>{lastRestore.name}</b><br />{lastRestore.date}</div>}

                        {/* DATA SYNC SETTINGS */}
                        <div className="bg-white p-4 rounded-xl shadow border border-blue-100 mt-4">
                            <h3 className="font-bold mb-3 text-blue-800">Sync & Device</h3>
                            <div className="mb-4">
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-1">This Device Name</label>
                                <div className="flex gap-2">
                                    <input
                                        className="flex-1 p-2 border rounded text-sm uppercase font-bold tracking-widest"
                                        maxLength={10}
                                        value={tempDeviceName}
                                        onChange={(e) => setTempDeviceName(e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, ''))}
                                    />
                                    <button
                                        onClick={() => {
                                            if (!tempDeviceName) return alert("Name cannot be empty");
                                            localStorage.setItem('shelfLife_deviceName', tempDeviceName);
                                            alert("Device Name Saved: " + tempDeviceName);
                                        }}
                                        className="px-3 py-2 bg-blue-600 text-white rounded font-bold text-xs"
                                    >
                                        SAVE
                                    </button>
                                </div>
                                <p className="text-[10px] text-gray-400 mt-1">Used in backups (A-Z, 0-9 Only). Example: SL_BK_MYPHONE_...</p>
                            </div>

                            <h4 className="text-xs font-bold text-gray-500 uppercase mb-2">History</h4>
                            <div className="max-h-32 overflow-y-auto bg-gray-50 p-2 rounded border text-xs space-y-2">
                                {(() => {
                                    let logs = [];
                                    try { logs = JSON.parse(localStorage.getItem('shelfLife_restoreLogs') || '[]'); } catch (e) { logs = []; }
                                    if (!Array.isArray(logs)) logs = [];

                                    if (logs.length === 0) return <div className="text-gray-400 text-center italic py-2">No restore history</div>;

                                    return logs.map((log, i) => (
                                        <div key={i} className="border-b pb-1 last:border-0">
                                            <div className="flex justify-between font-bold text-gray-700">
                                                <span>{new Date(log.timestamp).toLocaleDateString()}</span>
                                                <span className={`uppercase text-[10px] px-1 rounded ${log.status === 'Success' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>{log.mode}</span>
                                            </div>
                                            <div className="truncate text-gray-500">{log.source}</div>
                                            <div className="flex gap-2 mt-1 text-[10px] text-gray-400">
                                                <span>+{log.added} New</span>
                                                <span>{log.duplicates} Dupe</span>
                                                {log.skipped > 0 && <span>{log.skipped} Skip</span>}
                                            </div>
                                        </div>
                                    ));
                                })()}
                            </div>
                            <p className="text-xs text-gray-400 mt-2 text-center">📝 Restore logs are automatically saved to your backup folder</p>
                        </div>


                        <h4 className="font-bold text-xs uppercase text-yellow-800 mb-2">Backups</h4>
                        <div className="grid grid-cols-2 gap-2 mb-4">
                            <button onClick={() => performChunkedBackup(false)} className="py-2 bg-yellow-600 text-white rounded text-xs font-bold flex flex-col items-center gap-1"><Icon name="Save" size={16} /> Full Backup<span className="text-[9px] opacity-80">(Images)</span></button>
                            <button onClick={() => performChunkedBackup(true)} className="py-2 bg-yellow-700 text-white rounded text-xs font-bold flex flex-col items-center gap-1"><Icon name="FileText" size={16} /> Text-Only<span className="text-[9px] opacity-80">(No Images)</span></button>
                        </div>

                        <h4 className="font-bold text-xs uppercase text-yellow-800 mb-2">Restore</h4>
                        <div className="space-y-2">
                            <label className="w-full py-3 bg-green-600 text-white rounded text-sm font-bold flex items-center justify-center gap-2 cursor-pointer hover:bg-green-700">
                                <Icon name="RefreshCcw" /> Restore Backup
                                <input type="file" onChange={handleSmartRestore} accept=".json" multiple className="hidden" />
                            </label>
                            <p className="text-[9px] text-gray-500 text-center">Supports all formats: chunked backups, legacy files, single/multiple files</p>
                        </div>

                        <h4 className="font-bold text-xs uppercase text-blue-800 mb-2 mt-4">Sync</h4>
                        <div className="space-y-2 mb-4">
                            <button onClick={syncToFolder} className="w-full py-3 bg-blue-600 text-white rounded text-sm font-bold flex items-center justify-center gap-2 hover:bg-blue-700">
                                <Icon name="RefreshCw" /> Sync to Folder
                            </button>
                            <p className="text-[9px] text-gray-500 text-center">Exports full database to ShelfLife/sync_root_folder/.<br />💡 <em>Tip: Use "Restore Backup" to recover from sync files.</em></p>
                        </div>

                    </div>

                    {/* Tag Manager Modal */}
                    <TagManagerModal
                        isOpen={showTagManager}
                        onClose={() => setShowTagManager(false)}
                        books={books}
                        onTagsUpdated={() => {
                            // Slight delay to ensure UI updates before reload
                            setTimeout(() => window.location.reload(), 100);
                        }}
                    />

                    {/* DATA HANDLING HUB (MERGE STUDIO) */}
                    <div className="bg-white p-4 rounded-xl shadow border border-purple-200">
                        <h3 className="font-bold mb-3 text-purple-800 flex items-center gap-2"><Icon name="Merge" size={18} /> Merge Studio</h3>
                        <p className="text-xs text-gray-500 mb-3">Merge backup files from multiple devices into a unified master file.</p>
                        <DataHandlingHub />
                    </div>

                    {/* HELP & TIPS SECTION */}
                    <div className="bg-white p-4 rounded-xl shadow border border-green-200">
                        <button
                            onClick={() => setShowHelp(!showHelp)}
                            className="w-full font-bold text-green-800 flex justify-between items-center"
                        >
                            <span className="flex items-center gap-2"><Icon name="HelpCircle" size={18} /> Help & Tips</span>
                            <Icon name={showHelp ? 'ChevronUp' : 'ChevronDown'} size={18} />
                        </button>

                        {showHelp && (
                            <div className="mt-3 pt-3 border-t max-h-[400px] overflow-y-auto space-y-4 text-sm">
                                {/* Quick Start */}
                                <div>
                                    <h4 className="font-bold text-green-700 mb-1">🚀 Quick Start</h4>
                                    <ol className="list-decimal list-inside text-xs text-gray-600 space-y-1">
                                        <li><b>Add your first book</b> – Tap + → Scan barcode OR take photo</li>
                                        <li><b>Organize with tags</b> – Add tags like "Fiction", "To Read"</li>
                                        <li><b>Set up backups</b> – Go to Tools → Verify Folder</li>
                                    </ol>
                                </div>

                                {/* Features */}
                                <div>
                                    <h4 className="font-bold text-green-700 mb-1">📖 Features Guide</h4>
                                    <div className="text-xs text-gray-600 space-y-2">
                                        <p><b>📷 Adding Books:</b> Scan ISBN for auto-fill, take cover photos, voice input (tap mic icon), multiple languages supported.</p>
                                        <p><b>📚 Library View:</b> Tap book for details, long-press for quick actions. Multi-select: Long-press → select more → bulk edit/delete.</p>
                                        <p><b>🔍 Slicer Search:</b> Stack multiple filters (Publisher + Tag + Year). Export filtered results to CSV/HTML.</p>
                                        <p><b>🏷️ Tag Manager:</b> Search or browse all tags. Select 1 tag → Rename. Select 2+ tags → Merge. All new tags auto-capitalize (Title Case).</p>
                                        <p><b>💾 Backups:</b> Full Backup (with images, larger). Text-Only (no images, smaller). Sync to Folder (quick snapshot).</p>
                                    </div>
                                </div>

                                {/* Tips */}
                                <div>
                                    <h4 className="font-bold text-green-700 mb-1">💡 Tips & Tricks</h4>
                                    <ul className="text-xs text-gray-600 space-y-1 list-disc list-inside">
                                        <li>🎤 Voice input works best with short phrases</li>
                                        <li>📱 Device name appears in backup filenames</li>
                                        <li>🔄 Data auto-refreshes every second</li>
                                        <li>📂 Sync files can be restored using "Restore Backup"</li>
                                    </ul>
                                </div>

                                {/* Troubleshooting */}
                                <div>
                                    <h4 className="font-bold text-green-700 mb-1">🔧 Troubleshooting</h4>
                                    <ul className="text-xs text-gray-600 space-y-1 list-disc list-inside">
                                        <li><b>App won't load?</b> Clear app cache, reinstall</li>
                                        <li><b>Camera not working?</b> Check app permissions in Settings</li>
                                        <li><b>Backup failing?</b> Verify storage permissions</li>
                                    </ul>
                                </div>
                            </div>
                        )}
                    </div>
                </div >
            );
        };

        // --- DATA HANDLING HUB (MERGE STUDIO) ---
        const DataHandlingHub = () => {
            const [files, setFiles] = useState([]);
            const [selectedFiles, setSelectedFiles] = useState([]);
            const [mergeMode, setMergeMode] = useState('merge'); // merge or append
            const [loading, setLoading] = useState(false);
            const [step, setStep] = useState('scan'); // scan, preview, processing, complete

            const folder = localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups';
            const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';

            // Pick files for merge (replaces folder scan for Android 11+ compatibility)
            const handleFilePick = async (e) => {
                const pickedFiles = e.target.files;
                if (!pickedFiles || pickedFiles.length === 0) return;

                setLoading(true);
                try {
                    const scannedFiles = [];

                    for (const file of Array.from(pickedFiles)) {
                        if (!file.name.endsWith('.json')) continue;

                        try {
                            const content = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = (evt) => resolve(evt.target.result);
                                reader.onerror = reject;
                                reader.readAsText(file);
                            });

                            const data = JSON.parse(content);
                            const books = Array.isArray(data) ? data : [data];
                            const signature = books.find(b => b.__shelflife_signature__)?.__shelflife_signature__ || null;
                            const actualBooks = books.filter(b => !b.__shelflife_signature__);

                            scannedFiles.push({
                                name: file.name,
                                books: actualBooks,
                                count: actualBooks.length,
                                signature: signature,
                                hasImages: actualBooks.some(b => b.front || b.rear),
                                size: content.length
                            });
                        } catch (err) {
                            console.error(`Failed to parse ${file.name}:`, err);
                        }
                    }

                    // Append to existing files (allows multi-instance picking from different folders)
                    const existingNames = new Set(files.map(f => f.name));
                    const newFiles = scannedFiles.filter(f => !existingNames.has(f.name)); // Skip duplicates by name

                    if (newFiles.length === 0 && scannedFiles.length > 0) {
                        alert('These files are already added.');
                    } else {
                        setFiles(prev => [...prev, ...newFiles]);
                        // Select all including new files
                        setSelectedFiles(prev => [...prev, ...newFiles.map((_, i) => files.length + i)]);
                        if (files.length + newFiles.length > 0) setStep('preview');
                    }
                    if (scannedFiles.length === 0) alert('No valid JSON files found in selection.');
                } catch (err) {
                    alert('File Pick Error: ' + err.message);
                } finally {
                    setLoading(false);
                    e.target.value = ''; // Allow re-selecting same files
                }
            };

            // Calculate totals
            const totalBooks = useMemo(() => {
                return selectedFiles.reduce((sum, i) => sum + files[i]?.count || 0, 0);
            }, [selectedFiles, files]);

            // Execute merge
            const executeMerge = async () => {
                if (selectedFiles.length === 0) { alert("Select at least one file"); return; }
                setLoading(true);
                setStep('processing');

                try {
                    const { Filesystem } = window.Capacitor.Plugins;
                    const targetDir = Directory[baseStr] || Directory.Documents;
                    const now = new Date();
                    const ts = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0') + '_' + String(now.getHours()).padStart(2, '0') + '-' + String(now.getMinutes()).padStart(2, '0');
                    const sessionFolder = `ShelfLife/merge_${ts}`;
                    const workFolder = `${sessionFolder}/work_files`;
                    const mergePath = `${folder}/to_merge`;
                    const deviceName = localStorage.getItem('shelfLife_deviceName') || 'MYPHONE';

                    // Create session folders
                    await Filesystem.mkdir({ path: sessionFolder, directory: targetDir, recursive: true });
                    await Filesystem.mkdir({ path: workFolder, directory: targetDir, recursive: true });

                    // Collect all books
                    const masterMap = new Map();
                    const duplicates = [];
                    const sourceInfo = [];
                    let hasAnyImages = false;

                    for (const idx of selectedFiles) {
                        const file = files[idx];
                        sourceInfo.push({ name: file.name, count: file.count, type: file.signature?.type || 'UNKNOWN' });
                        if (file.hasImages) hasAnyImages = true;

                        for (const book of file.books) {
                            const key = `${book.title}|${book.isbn || ''}`.toLowerCase();
                            if (masterMap.has(key)) {
                                duplicates.push({ existing: masterMap.get(key), incoming: book });
                                if (mergeMode === 'merge') {
                                    book.tags = [...new Set([...(book.tags || []), 'duplicate'])];
                                    masterMap.set(`dup_${Date.now()}_${Math.random()}`, book);
                                }
                                // In append mode, skip duplicate
                            } else {
                                masterMap.set(key, book);
                            }
                        }
                        // Note: Files picked via browser file picker cannot be moved/deleted 
                        // as they're not accessible via Capacitor Filesystem API
                    }

                    const allBooks = [...masterMap.values()];
                    const typePrefix = hasAnyImages ? 'FULL' : 'TXT';

                    // Create signature
                    const signature = {
                        __shelflife_signature__: {
                            version: '2.0',
                            created: now.toISOString(),
                            device: deviceName,
                            type: `MASTER_${typePrefix}`,
                            book_count: allBooks.length,
                            sources: sourceInfo
                        }
                    };

                    // Write master file
                    const masterName = `SL_MASTER_${typePrefix}_${deviceName}_${ts}.json`;
                    await Filesystem.writeFile({
                        path: `${sessionFolder}/${masterName}`,
                        directory: targetDir,
                        data: JSON.stringify([signature, ...allBooks]),
                        encoding: Encoding.UTF8
                    });

                    // Write TXT log
                    const txtLog = `========================================
ShelfLife Merge Log
========================================
Date: ${now.toLocaleString()}
Device: ${deviceName}
Mode: ${mergeMode.toUpperCase()}
----------------------------------------
SOURCE FILES:
${sourceInfo.map((s, i) => `${i + 1}. ${s.name} - ${s.count} books`).join('\n')}
----------------------------------------
RESULT:
Total Unique: ${allBooks.length}
Duplicates Found: ${duplicates.length}
Mode Action: ${mergeMode === 'merge' ? 'Tagged as duplicate' : 'Skipped'}
----------------------------------------
OUTPUT: ${masterName}
========================================`;

                    await Filesystem.writeFile({
                        path: `${sessionFolder}/merge_log.txt`,
                        directory: targetDir,
                        data: txtLog,
                        encoding: Encoding.UTF8
                    });

                    // Write CSV log
                    const csvHeader = 'File,Date,Mode,Books,Output\n';
                    const csvRow = `"${sourceInfo.map(s => s.name).join('; ')}",${now.toISOString()},${mergeMode},${allBooks.length},"${masterName}"`;
                    await Filesystem.writeFile({
                        path: `${sessionFolder}/merge_report.csv`,
                        directory: targetDir,
                        data: csvHeader + csvRow,
                        encoding: Encoding.UTF8
                    });

                    setStep('complete');
                    alert(`✅ Merge Complete!\n\nMaster: ${masterName}\nBooks: ${allBooks.length}\nDuplicates: ${duplicates.length}\n\nSaved to: ${sessionFolder}`);

                    // Reset
                    setFiles([]);
                    setSelectedFiles([]);
                    setStep('scan');

                } catch (e) {
                    alert("Merge Error: " + e.message);
                    setStep('preview');
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="space-y-3">
                    {step === 'scan' && (
                        <div className="text-center py-4">
                            <p className="text-sm text-gray-500 mb-3">
                                Select backup JSON files to merge
                            </p>
                            <label className="px-6 py-3 bg-purple-600 text-white rounded-lg font-bold flex items-center gap-2 mx-auto cursor-pointer hover:bg-purple-700 w-fit">
                                <Icon name="FolderOpen" size={18} />
                                {loading ? 'Loading...' : 'Merge backup files'}
                                <input
                                    type="file"
                                    accept=".json"
                                    multiple
                                    onChange={handleFilePick}
                                    disabled={loading}
                                    className="hidden"
                                />
                            </label>
                            <p className="text-xs text-gray-400 mt-2">Select one or more .json backup files</p>
                        </div>
                    )}

                    {step === 'preview' && (
                        <>
                            <div className="text-xs font-bold text-gray-500 uppercase mb-2">
                                {files.length} Files Found • {totalBooks} Total Books
                            </div>

                            <div className="max-h-48 overflow-y-auto space-y-2 border rounded p-2 bg-gray-50">
                                {files.map((f, i) => (
                                    <label key={i} className="flex items-center gap-2 p-2 bg-white rounded border cursor-pointer hover:bg-blue-50">
                                        <input
                                            type="checkbox"
                                            checked={selectedFiles.includes(i)}
                                            onChange={(e) => {
                                                if (e.target.checked) setSelectedFiles([...selectedFiles, i]);
                                                else setSelectedFiles(selectedFiles.filter(x => x !== i));
                                            }}
                                        />
                                        <div className="flex-1 min-w-0">
                                            <div className="font-bold text-sm truncate">{f.name}</div>
                                            {f.signature && (
                                                <div className="text-xs text-blue-600">
                                                    📱 {f.signature.device_nickname || 'Unknown'} • {f.signature.device_model || ''} {f.signature.device_manufacturer ? `(${f.signature.device_manufacturer})` : ''}
                                                </div>
                                            )}
                                            <div className="text-xs text-gray-500">
                                                {f.count} books • {f.hasImages ? '📷 With Images' : '📝 Text Only'}
                                            </div>
                                        </div>
                                    </label>
                                ))}
                            </div>

                            <div className="flex gap-2 flex-wrap">
                                <button
                                    onClick={() => setSelectedFiles(files.map((_, i) => i))}
                                    className="text-xs px-2 py-1 border rounded"
                                >All</button>
                                <button
                                    onClick={() => setSelectedFiles([])}
                                    className="text-xs px-2 py-1 border rounded"
                                >None</button>
                                <label className="text-xs px-2 py-1 border rounded bg-purple-50 text-purple-700 cursor-pointer hover:bg-purple-100">
                                    + Add More
                                    <input type="file" accept=".json" multiple onChange={handleFilePick} className="hidden" />
                                </label>
                                <button
                                    onClick={() => { setFiles([]); setSelectedFiles([]); setStep('scan'); }}
                                    className="text-xs px-2 py-1 border rounded bg-red-50 text-red-600 hover:bg-red-100"
                                >Clear All</button>
                            </div>

                            <div className="flex gap-2 mt-2">
                                <button
                                    onClick={() => setMergeMode('merge')}
                                    className={`flex-1 py-2 rounded text-sm font-bold ${mergeMode === 'merge' ? 'bg-purple-600 text-white' : 'bg-gray-100'}`}
                                >MERGE (Tag Dupes)</button>
                                <button
                                    onClick={() => setMergeMode('append')}
                                    className={`flex-1 py-2 rounded text-sm font-bold ${mergeMode === 'append' ? 'bg-purple-600 text-white' : 'bg-gray-100'}`}
                                >APPEND (Skip Dupes)</button>
                            </div>

                            <div className="flex gap-2 mt-3">
                                <button
                                    onClick={() => { setStep('scan'); setFiles([]); }}
                                    className="flex-1 py-2 border rounded font-bold text-gray-600"
                                >Cancel</button>
                                <button
                                    onClick={executeMerge}
                                    disabled={loading || selectedFiles.length === 0}
                                    className="flex-1 py-2 bg-green-600 text-white rounded font-bold disabled:opacity-50"
                                >
                                    {loading ? 'Processing...' : `Merge ${selectedFiles.length} Files`}
                                </button>
                            </div>
                        </>
                    )}

                    {step === 'processing' && (
                        <div className="text-center py-8">
                            <div className="w-10 h-10 border-4 border-purple-500 border-t-transparent rounded-full animate-spin mx-auto mb-3"></div>
                            <p className="text-sm text-gray-500">Processing merge...</p>
                        </div>
                    )}
                </div>
            );
        };

        // --- TAG MANAGER ---
        const TagManager = ({ books, onClose }) => {
            const tags = useMemo(() => { const t = {}; books.forEach(b => { if (b.tags) b.tags.forEach(x => t[x] = (t[x] || 0) + 1) }); return Object.entries(t).sort((a, b) => b[1] - a[1]); }, [books]);

            const handleRename = async (oldTag) => {
                const newTag = prompt(`Rename ${oldTag} to:`);
                if (!newTag || newTag === oldTag) return;
                const affected = books.filter(b => b.tags && b.tags.includes(oldTag));
                for (const b of affected) {
                    const newTags = b.tags.filter(t => t !== oldTag);
                    if (!newTags.includes(newTag)) newTags.push(newTag);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert("Tag Renamed!");
            };

            const handleMerge = async (oldTag) => {
                const target = prompt(`Merge #${oldTag} into existing tag (Books will move to new tag):`);
                if (!target || target === oldTag) return;
                const affected = books.filter(b => b.tags && b.tags.includes(oldTag));
                for (const b of affected) {
                    let newTags = b.tags.filter(t => t !== oldTag);
                    if (!newTags.includes(target)) newTags.push(target);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert(`Merged #${oldTag} -> #${target}`);
            };

            const handleDelete = async (tag) => {
                if (!confirm(`Delete tag "${tag}" from ${tags.find(t => t[0] === tag)[1]} books?`)) return;
                const affected = books.filter(b => b.tags && b.tags.includes(tag));
                for (const b of affected) {
                    let newTags = b.tags.filter(t => t !== tag);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert("Tag Deleted");
            };

            return (
                <div className="h-64 overflow-y-auto border rounded p-2">
                    {tags.length === 0 && <p className="text-sm text-gray-400">No tags used.</p>}
                    {tags.map(([t, c]) => (
                        <div key={t} className="flex justify-between p-2 border-b text-sm items-center">
                            <span><b>{t}</b> ({c})</span>
                            <div className="flex gap-2">
                                <button onClick={() => handleRename(t)} title="Rename" className="text-blue-500"><Icon name="Edit3" size={14} /></button>
                                <button onClick={() => handleMerge(t)} title="Merge" className="text-purple-500"><Icon name="Merge" size={14} /></button>
                                <button onClick={() => handleDelete(t)} title="Delete" className="text-red-500"><Icon name="Trash2" size={14} /></button>
                            </div>
                        </div>
                    ))}
                </div>
            );
        };

        // --- APP HEADER ---
        const AppHeader = ({ title = "ShelfLife" }) => (
            <div className="bg-blue-900 text-white p-4 shadow-md sticky top-0 z-50 flex items-center justify-between no-print">
                <div className="flex items-center gap-3">
                    <div className="bg-white/10 p-2 rounded-lg"><Icon name="Library" size={20} /></div>
                    <div>
                        <h1 className="font-bold text-lg leading-none">{title}</h1>
                        <p className="text-[10px] text-blue-200 opacity-80">Personal Library Manager</p>
                    </div>
                </div>
            </div>
        );

        // --- SETUP MODAL ---
        const SetupModal = ({ onComplete }) => {
            const [folder, setFolder] = useState('ShelfLife_Backups');
            const [base, setBase] = useState('DOCUMENTS');
            const [status, setStatus] = useState('');
            const [devName, setDevName] = useState(localStorage.getItem('shelfLife_deviceName') || '');
            const [detectedName, setDetectedName] = useState('');

            // Auto-detect device name from existing backups or hardware model
            useEffect(() => {
                const detectDeviceName = async () => {
                    if (!window.Capacitor) return;
                    try {
                        const { Filesystem, Device } = window.Capacitor.Plugins;
                        const targetDir = Directory.Documents;

                        // Try to read existing backups
                        try {
                            const ret = await Filesystem.readdir({ path: 'ShelfLife_Backups', directory: targetDir });
                            const backupFile = (ret.files || []).find(f => f.name.match(/SL_(?:BK|FULL_BK|TXT_BK)_([A-Z0-9]+)_Part/));
                            if (backupFile) {
                                const match = backupFile.name.match(/SL_(?:BK|FULL_BK|TXT_BK)_([A-Z0-9]+)_Part/);
                                if (match) {
                                    setDetectedName(match[1]);
                                    if (!devName) setDevName(match[1]);
                                    return;
                                }
                            }
                        } catch (e) { /* No existing backups */ }

                        // Fallback: Use hardware model
                        if (Device) {
                            try {
                                const info = await Device.getInfo();
                                const hwName = (info.model || info.name || 'MYPHONE').toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 10);
                                setDetectedName(hwName);
                                if (!devName) setDevName(hwName);
                            } catch (e) {
                                if (!devName) setDevName('MYPHONE');
                            }
                        } else {
                            if (!devName) setDevName('MYPHONE');
                        }
                    } catch (e) {
                        if (!devName) setDevName('MYPHONE');
                    }
                };
                detectDeviceName();
            }, []);

            const requestPerms = async () => {
                if (!window.Capacitor) return;
                try {
                    const { Filesystem, Camera } = window.Capacitor.Plugins;
                    setStatus('Requesting permissions...');
                    try { await Filesystem.requestPermissions(); } catch (e) { }
                    try { await Camera.requestPermissions(); } catch (e) { }

                    // Save Prefs
                    localStorage.setItem('shelfLife_backupFolder', folder);
                    localStorage.setItem('shelfLife_backupBase', base);
                    localStorage.setItem('shelfLife_deviceName', devName || 'MYPHONE');

                    // Test Create with Force Write
                    const targetDir = Directory[base] || Directory.Documents;
                    try {
                        // Create main folder (ignore if exists)
                        try {
                            await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true });
                        } catch (mkdirErr) {
                            // Folder exists is OK, continue
                            console.log('Main folder mkdir:', mkdirErr.message);
                        }

                        // Create to_merge subfolder (ignore if exists)
                        try {
                            await Filesystem.mkdir({ path: `${folder}/to_merge`, directory: targetDir, recursive: true });
                        } catch (mkdirErr) {
                            console.log('to_merge folder mkdir:', mkdirErr.message);
                        }

                        // Create a test file to REALLY verify write access
                        await Filesystem.writeFile({
                            path: `${folder}/.test_marker`,
                            data: 'Setup Complete ' + new Date().toISOString(),
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        // Clean up
                        try { await Filesystem.deleteFile({ path: `${folder}/.test_marker`, directory: targetDir }); } catch (e) { }

                        setStatus('Permissions Granted & Folder Verified!');
                    } catch (e) {
                        setStatus('Error: ' + e.message);
                        alert("Folder Creation Failed.\nTry changing 'Storage Location' to External, or use a different folder name.");
                    }
                } catch (e) {
                    setStatus('Setup Error: ' + e.message);
                }
            };

            return (
                <div className="fixed inset-0 bg-black/80 z-[100] flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl p-6 w-full max-w-sm shadow-2xl animate-[fadeIn_0.3s_ease-out]">
                        <div className="text-center mb-6">
                            <div className="inline-block p-4 bg-blue-100 rounded-full text-blue-600 mb-3"><Icon name="Library" size={32} /></div>
                            <h2 className="text-xl font-bold text-gray-800">Welcome to ShelfLife</h2>
                            <p className="text-sm text-gray-500 mt-1">Let's set up your secure storage.</p>
                        </div>

                        <div className="space-y-4">
                            <div className="border-b pb-4 mb-4">
                                <label className="block text-xs font-bold text-gray-700 uppercase mb-1">Device Nickname</label>
                                <input
                                    className="w-full p-3 border rounded-lg bg-gray-50 focus:ring-2 focus:ring-blue-500 outline-none transition-all uppercase"
                                    maxLength={10}
                                    placeholder="MYPHONE"
                                    value={devName}
                                    onChange={(e) => {
                                        const val = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                                        setDevName(val);
                                    }}
                                />
                                {detectedName && <p className="text-[10px] text-blue-500 mt-1">Auto-detected from existing backups: {detectedName}</p>}
                                <p className="text-[10px] text-gray-400 mt-1">Backup filename: SL_BK_{devName || 'MYPHONE'}_Part1_...</p>
                            </div>

                            <div>
                                <label className="block text-xs font-bold text-gray-700 uppercase mb-1">Storage Location</label>
                                <div className="flex gap-2">
                                    <select className="p-3 border rounded-lg bg-gray-50 text-xs font-bold" value={base} onChange={e => setBase(e.target.value)}>
                                        <option value="DOCUMENTS">Documents/</option>
                                        <option value="EXTERNAL_STORAGE">External/</option>
                                    </select>
                                    <input
                                        className="flex-1 p-3 border rounded-lg bg-gray-50 focus:ring-2 focus:ring-blue-500 outline-none transition-all"
                                        value={folder}
                                        onChange={e => setFolder(e.target.value)}
                                        placeholder="FolderName"
                                    />
                                </div>
                                <p className="text-[10px] text-gray-400 mt-1">Files will be saved to: {base}/{folder}/</p>
                            </div>

                            <button onClick={requestPerms} className="w-full py-2 bg-gray-100 hover:bg-gray-200 text-gray-800 font-bold rounded-lg border border-gray-300 text-xs">
                                🔓 Grant Storage Permissions & Test
                            </button>
                            {status && <div className={`text-center text-[10px] font-bold p-1 rounded ${status.includes('Error') ? 'text-red-600 bg-red-50' : 'text-green-600 bg-green-50'}`}>{status}</div>}

                            <button onClick={onComplete} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-lg transform transition active:scale-95">
                                Start Using App
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- APP ROOT ---
        const App = () => {
            const [view, setView] = useState('library');
            const [books, setBooks] = useState([]);
            const [editBook, setEditBook] = useState(null);
            const [currency, setCurrency] = useState(() => localStorage.getItem('shelfLife_currency') || '₹');
            const [showSetup, setShowSetup] = useState(false);

            useEffect(() => {
                // Startup Check for Folder
                if (!localStorage.getItem('shelfLife_backupFolder')) {
                    setShowSetup(true);
                }

                const l = async () => {
                    await migrateAuthors();
                    await migrateLanguage();
                    setBooks(await db.books.toArray());
                };
                l();
                setInterval(async () => setBooks(await db.books.toArray()), 1000);

                // Android Back Button & Permissions Logic
                try {
                    if (window.Capacitor) {
                        const { App } = window.Capacitor.Plugins;
                        // Handle Back Button
                        App.addListener('backButton', ({ canGoBack }) => {
                            if (canGoBack) {
                                window.history.back();
                            } else {
                                if (confirm('Do you want to exit ShelfLife?')) {
                                    App.exitApp();
                                }
                            }
                        });

                        // Request Permissions
                        (async () => {
                            try {
                                const { Filesystem } = window.Capacitor.Plugins;
                                await Filesystem.readdir({ path: 'Documents', directory: Directory.External }).catch(() => { });
                            } catch (e) { console.log("Perms check silent fail", e); }
                        })();

                        console.log("Native listeners active");

                        // Exit confirmation on back button
                        const CapApp = window.Capacitor.Plugins.App;
                        if (CapApp && CapApp.addListener) {
                            CapApp.addListener('backButton', ({ canGoBack }) => {
                                if (!canGoBack) {
                                    if (confirm("Do you want to exit ShelfLife?")) {
                                        CapApp.exitApp();
                                    }
                                } else {
                                    window.history.back();
                                }
                            });
                        }
                    }
                } catch (e) { console.error("Native setup error", e); }

            }, []);

            // Pull-to-refresh REMOVED in v2.5 - redundant with 1-second auto-refresh and disruptive full-page reload

            useEffect(() => {
                localStorage.setItem('shelfLife_currency', currency);
            }, [currency]);

            // Save Logic
            const save = async (d) => {
                try {
                    if (d.id) await db.books.put(d);
                    else {
                        await db.books.add({ ...d, date_added: Date.now() });

                        // Track entries since backup for reminder
                        const count = parseInt(localStorage.getItem('shelfLife_entriesSinceBackup') || '0') + 1;
                        localStorage.setItem('shelfLife_entriesSinceBackup', count.toString());
                    }
                    setEditBook(null);
                    setView('library');

                    // Check if backup reminder needed
                    const lastBackup = localStorage.getItem('shelfLife_lastBackupDate');
                    const entriesSince = parseInt(localStorage.getItem('shelfLife_entriesSinceBackup') || '0');
                    const daysSince = lastBackup ? Math.floor((Date.now() - new Date(lastBackup).getTime()) / 86400000) : 999;

                    if ((daysSince >= 7 || entriesSince >= 10) && !sessionStorage.getItem('backupReminderShown')) {
                        sessionStorage.setItem('backupReminderShown', 'true');
                        setTimeout(() => {
                            if (confirm(`Backup Reminder:\n${entriesSince} new entries since last backup.\nWould you like to backup now?`)) {
                                setView('settings');
                            }
                        }, 1000);
                    }
                } catch (err) {
                    alert("Database Error: " + err.message + "\nCheck storage space?");
                }
            };

            const deleteMulti = async (ids) => { if (confirm(`Delete ${ids.length} books?`)) { await db.books.bulkDelete(ids); } };

            if (editBook || view === 'add') return (
                <div className="max-w-md mx-auto min-h-screen bg-gray-50">
                    <AppHeader />
                    <BookForm book={editBook} onSave={save} onCancel={() => { setEditBook(null); setView('library') }} onBarcodeFound={(b) => { setEditBook(b); setView('add') }} globalCurrency={currency} books={books} />
                </div>
            );

            return (
                <div className="max-w-md mx-auto min-h-screen bg-gray-50 shadow-2xl relative overflow-hidden">
                    {showSetup && <SetupModal onComplete={() => setShowSetup(false)} />}

                    <AppHeader />

                    <main className="p-4 pb-24 safe-area-top">
                        {view === 'library' && <LibraryView books={books} onEdit={(b) => { setEditBook(b); }} onDeleteMulti={deleteMulti} />}
                        {view === 'search' && <SlicerSearch books={books} onEdit={(b) => { setEditBook(b); setView('add') }} />}
                        {view === 'reports' && <Dashboard books={books} onNavigateToSlicer={(field, value) => {
                            // Set the slicer filter in sessionStorage and navigate
                            sessionStorage.setItem('shelfLife_slicerFilters', JSON.stringify([{ field, value }]));
                            setView('search');
                        }} />}
                        {view === 'settings' && <Tools books={books} currency={currency} setCurrency={setCurrency} />}
                    </main>

                    <nav className="fixed bottom-0 w-full max-w-md bg-white border-t flex justify-around py-3 pb-safe z-30 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                        <button onClick={() => setView('library')} className={view === 'library' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Library" /><span className="block text-[10px]">Lib</span></button>
                        <button onClick={() => setView('search')} className={view === 'search' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Search" /><span className="block text-[10px]">Search</span></button>
                        <button onClick={() => setView('add')} className={view === 'add' ? 'text-blue-600' : 'text-gray-400'}><Icon name="PlusSquare" /><span className="block text-[10px]">Add</span></button>
                        <button onClick={() => setView('reports')} className={view === 'reports' ? 'text-blue-600' : 'text-gray-400'}><Icon name="BarChart2" /><span className="block text-[10px]">Stats</span></button>
                        <button onClick={() => setView('settings')} className={view === 'settings' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Settings" /><span className="block text-[10px]">Tools</span></button>
                    </nav>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>

</html>