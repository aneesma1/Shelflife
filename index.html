<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Home Library by Anees</title>

    <!-- PWA MANIFEST (Embedded) -->
    <link rel="manifest"
        href="data:application/manifest+json;base64,ewogICAgIm5hbWUiOiAiU2hlbGZMaWZlIFVsdGltYXRlIiwKICAgICJzaG9ydF9uYW1lIjogIlNoZWxZTGlmZSIsCiAgICAic3RhcnRfdXJsIjogIi4iLAogICAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgICAiYmFja2dyb3VuZF9jb2xvciI6ICIjZjNmNGY2IiwKICAgICJ0aGVtZV9jb2xvciI6ICIjMjU2M2ViIiwKICAgICJpY29ucyI6IFtdCn0=">

    <!-- OFFLINE LIBRARIES (Downloaded via Cloud Build) -->
    <script src="libs/react.js"></script>
    <script src="libs/react-dom.js"></script>
    <script src="libs/babel.min.js"></script>
    <script src="libs/tailwindcss.js"></script>
    <script src="libs/dexie.js"></script>
    <script src="libs/html5-qrcode.min.js"></script>

    <!-- FONTS -->
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&family=Noto+Sans+Malayalam&family=Noto+Sans+Arabic&family=Noto+Sans+Devanagari&display=swap"
        rel="stylesheet">

    <style>
        body {
            font-family: 'Noto Sans', sans-serif;
            background-color: #f3f4f6;
            overscroll-behavior: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .font-ml {
            font-family: 'Noto Sans Malayalam', sans-serif;
        }

        .font-ar {
            font-family: 'Noto Sans Arabic', sans-serif;
        }

        .font-hi {
            font-family: 'Noto Sans Devanagari', sans-serif;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .pie-chart {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: conic-gradient(var(--pie-gradient));
        }

        /* Pull to Refresh Spinner */
        #ptr-spinner {
            position: fixed;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: top 0.3s ease;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="ptr-spinner">
        <div className="spinner"></div>
    </div>
    <div id="root"></div>

    <script>
        // --- SERVICE WORKER REGISTRATION (Robust for PWA) ---
        if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || window.location.hostname === 'localhost')) {
            const swCode = `
        const CACHE_NAME = 'shelflife-v2';
        const FILES_TO_CACHE = [
            './',
            'https://unpkg.com/react@18/umd/react.development.js',
            'https://unpkg.com/react-dom@18/umd/react-dom.development.js',
            'https://unpkg.com/@babel/standalone/babel.min.js',
            'https://cdn.tailwindcss.com',
            'https://unpkg.com/dexie@3.2.4/dist/dexie.js',
            'https://unpkg.com/html5-qrcode',
            'https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&family=Noto+Sans+Malayalam&family=Noto+Sans+Arabic&family=Noto+Sans+Devanagari&display=swap'
        ];
        
        self.addEventListener('install', (evt) => {
            evt.waitUntil(
                caches.open(CACHE_NAME).then((cache) => {
                    return cache.addAll(FILES_TO_CACHE).catch(err => console.log('Cache error:', err));
                })
            );
            self.skipWaiting();
        });

        self.addEventListener('activate', (evt) => {
            evt.waitUntil(self.clients.claim());
        });

        self.addEventListener('fetch', (evt) => {
            evt.respondWith(
                caches.match(evt.request).then((resp) => {
                    return resp || fetch(evt.request).catch(() => new Response("Offline"));
                })
            );
        });
    `;

            // Create blob URL for SW
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);

            navigator.serviceWorker.register(swUrl)
                .then((reg) => console.log('SW Registered'))
                .catch((err) => console.log('SW Failed:', err));
        }
    </script>

    <script type="text/babel">

        // ==========================================
        // 1. UTILITIES
        // ==========================================

        const ImageUtils = {
            process: (file, width = 600, quality = 0.70) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let w = img.width, h = img.height;
                        if (w > width) { h *= width / w; w = width; }
                        canvas.width = w; canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, w, h);
                        resolve(canvas.toDataURL('image/webp', quality));
                    };
                    img.onerror = reject;
                };
                reader.onerror = reject;
            })
        };

        // Initialize Capacitor Enums globally for script usage
        const Directory = {
            Documents: 'DOCUMENTS',
            Data: 'DATA',
            Cache: 'CACHE',
            External: 'EXTERNAL', // often maps to generic external storage
            ExternalStorage: 'EXTERNAL_STORAGE' // Android specific
        };

        const Encoding = {
            UTF8: 'utf8',
            ASCII: 'ascii',
            UTF16: 'utf16'
        };

        const ExportUtils = {
            getTimestamp: () => {
                const now = new Date();
                return now.toISOString().replace(/[:.]/g, '-').slice(0, 16);
            },
            download: async (content, name, mimeType, specificFolder = null, specificBase = null) => {
                if (window.Capacitor) {
                    try {
                        const { Filesystem } = window.Capacitor.Plugins;
                        // Use specific folder if provided, else backup preference, else default
                        const folder = specificFolder || localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups';
                        const baseStr = specificBase || localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';

                        // Map string to Directory Constant
                        // Note: We use global Directory object defined above
                        const targetDir = Directory[baseStr] || Directory.Documents;

                        // Ensure folder exists
                        try {
                            await Filesystem.mkdir({
                                path: folder, // Write relative to Base (e.g. Documents/ShelfLife)
                                directory: targetDir,
                                recursive: true
                            });
                        } catch (e) { }

                        const cleanPath = folder ? `${folder}/${name}` : name;

                        await Filesystem.writeFile({
                            path: cleanPath,
                            data: content,
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        alert(`Saved to: ${baseStr}/${cleanPath}`);
                    } catch (e) {
                        console.error(e);
                        alert("Save failed. " + e.message);
                    }
                } else {
                    // Browser Download
                    try {
                        let dataUri = '';
                        if (mimeType === 'application/json' || mimeType.includes('text')) {
                            // Use UTF-8 BOM only for CSV to assist Excel opening
                            const prefix = mimeType.includes('csv') ? "\uFEFF" : "";
                            const base64 = btoa(unescape(encodeURIComponent(prefix + content)));
                            dataUri = `data:${mimeType};base64,${base64}`;
                        } else {
                            dataUri = content;
                        }
                        const a = document.createElement('a');
                        a.href = dataUri;
                        a.download = name;
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => document.body.removeChild(a), 100);
                    } catch (e) {
                        alert("Export failed: " + e.message);
                    }
                }
            },
            csv: (books, filenamePrefix = "ShelfLife_Export", specificFolder = null, specificBase = null) => {
                const maxTags = books.reduce((max, b) => Math.max(max, (b.tags || []).length), 0);
                let header = "Title,Author,Publisher,Year,Pages,Condition,Price,Currency,Owner,Location,ISBN,Status";
                for (let i = 1; i <= maxTags; i++) header += `,Tag_${i}`;
                header += "\n";
                const rows = books.map(b => {
                    const core = `"${(b.title || '').replace(/"/g, '""')}","${(b.author || '').replace(/"/g, '""')}","${(b.publisher || '').replace(/"/g, '""')}","${b.pub_year || ''}","${b.page_count || ''}","${b.condition || ''}","${b.price || ''}","${b.currency || ''}","${b.owner || ''}","${b.building || ''} ${b.shelf || ''}","${b.isbn || ''}","${b.status || ''}"`;
                    const tags = (b.tags || []);
                    const tagCells = Array.from({ length: maxTags }, (_, i) => `"${(tags[i] || '').replace(/"/g, '""')}"`).join(',');
                    return `${core},${tagCells}`;
                }).join('\n');

                // Sanitize filename
                const safePrefix = filenamePrefix.replace(/[^a-z0-9_]/gi, '_');
                const timestamp = ExportUtils.getTimestamp().replace(/[-:]/g, ''); // Compact timestamp
                ExportUtils.download("\uFEFF" + header + rows, `${safePrefix}_${timestamp}.csv`, "text/csv;charset=utf-8", specificFolder, specificBase);
            },
            htmlText: (books, type, title = "Library Inventory", specificFolder = null, specificBase = null) => {
                let html = `<html><head><meta charset="UTF-8"><style>body{font-family:sans-serif;padding:20px;} table{width:100%;border-collapse:collapse;} th,td{border:1px solid #ddd;padding:8px;} th{background:#f3f3f3;} tr:nth-child(even){background:#f9f9f9;}</style></head><body><h1>${title}</h1><table><tr><th>Title</th><th>Author</th><th>Publisher</th><th>Year</th><th>Loc</th><th>Cond</th><th>Price</th></tr>${books.map(b => `<tr><td>${b.title}</td><td>${b.author}</td><td>${b.publisher}</td><td>${b.pub_year}</td><td>${b.building} ${b.shelf}</td><td>${b.condition}</td><td>${b.currency || ''} ${b.price}</td></tr>`).join('')}</table></body></html>`;
                ExportUtils.download(html, `ShelfLife_List_${ExportUtils.getTimestamp()}.html`, "text/html;charset=utf-8", specificFolder, specificBase);
            },
            htmlVisual: (books, type, title = "Visual Catalogue", specificFolder = null, specificBase = null) => {
                let html = `<html><head><meta charset="UTF-8"><style>body{font-family:sans-serif;padding:20px;} .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:20px;} .card{border:1px solid #ddd;padding:10px;text-align:center;border-radius:8px;} img{width:100%;height:150px;object-fit:cover;margin-bottom:10px;border-radius:4px;} .meta{font-size:12px;color:#666;}</style></head><body><h1>${title}</h1><div class="grid">${books.map(b => `<div class="card">${b.front ? `<img src="${b.front}"/>` : ''}<b>${b.title}</b><br><small>${b.author}</small><br><span class="meta">${b.publisher} • ${b.pub_year}</span></div>`).join('')}</div></body></html>`;
                ExportUtils.download(html, `ShelfLife_Visual_${ExportUtils.getTimestamp()}.html`, "text/html;charset=utf-8", specificFolder, specificBase);
            }
        };

        const ICONS = {
            Library: `<path d="m16 6 4 14"/><path d="M12 6v14"/><path d="M8 8v12"/><path d="M4 4v16"/>`,
            PlusSquare: `<rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/><path d="M12 8v8"/>`,
            BarChart2: `<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>`,
            Settings: `<path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/>`,
            Search: `<circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/>`,
            Edit3: `<path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/>`,
            Book: `<path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>`,
            Camera: `<path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/>`,
            FileText: `<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/>`,
            List: `<line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/>`,
            Image: `<rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>`,
            Download: `<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/>`,
            X: `<path d="M18 6 6 18"/><path d="m6 6 12 12"/>`,
            MapPin: `<path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/>`,
            AlertCircle: `<circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/>`,
            Trash2: `<path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/>`,
            Eye: `<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>`,
            Plus: `<path d="M5 12h14"/><path d="M12 5v14"/>`,
            Upload: `<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/>`,
            Filter: `<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>`,
            Barcode: `<path d="M3 5v14"/><path d="M8 5v14"/><path d="M12 5v14"/><path d="M17 5v14"/><path d="M21 5v14"/>`,
            CheckSquare: `<polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>`,
            Mic: `<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="23"/><line x1="8" x2="16" y1="23" y2="23"/>`,
            Grid: `<rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/>`,
            LayoutList: `<rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/><path d="M14 4h7"/><path d="M14 9h7"/><path d="M14 15h7"/><path d="M14 20h7"/>`,
            Merge: `<path d="m8 6 4-4 4 4"/><path d="M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22"/><path d="m20 22-5-5"/>`
        };

        const Icon = ({ name, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={`lucide lucide-${name} ${className}`} dangerouslySetInnerHTML={{ __html: ICONS[name] || ICONS['Book'] }} />
        );

        // --- TRANSLITERATION ---
        const TRANSLITERATE_MAP = {
            'അ': 'a', 'आ': 'aa', 'ഇ': 'i', 'ഈ': 'ee', 'ഉ': 'u', 'ഊ': 'oo', 'എ': 'e', 'ഏ': 'ea', 'ഐ': 'ai', 'ഒ': 'o', 'ഓ': 'oa', 'ഔ': 'au', 'ം': 'm', 'ക': 'ka', 'ഖ': 'kha', 'ഗ': 'ga', 'ഘ': 'gha', 'ങ': 'nga', 'ച': 'cha', 'ഛ': 'chha', 'ജ': 'ja', 'ഝ': 'jha', 'ഞ': 'nja', 'ട': 'ta', 'ഠ': 'ttha', 'ഡ': 'da', 'ഢ': 'ddha', 'ണ': 'na', 'ത': 'tha', 'ഥ': 'thha', 'ദ': 'da', 'ധ': 'dha', 'ന': 'na', 'പ': 'pa', 'ഫ': 'pha', 'ബ': 'ba', 'ഭ': 'bha', 'മ': 'ma', 'യ': 'ya', 'ര': 'ra', 'ല': 'la', 'വ': 'va', 'ശ': 'sha', 'ഷ': 'sha', 'സ': 'sa', 'ഹ': 'ha', 'ള': 'la', 'ഴ': 'zha', 'റ': 'ra', 'अ': 'a', 'आ': 'aa', 'इ': 'i', 'ई': 'ee', 'उ': 'u', 'ऊ': 'oo', 'ए': 'e', 'ऐ': 'ai', 'ओ': 'o', 'औ': 'au', 'ं': 'n', 'क': 'ka', 'ख': 'kha', 'ग': 'ga', 'घ': 'gha', 'च': 'cha', 'छ': 'chha', 'ज': 'ja', 'झ': 'jha', 'ट': 'ta', 'ठ': 'ttha', 'ड': 'da', 'ढ': 'ddha', 'ण': 'na', 'त': 'tha', 'थ': 'thha', 'द': 'da', 'ध': 'dha', 'न': 'na', 'प': 'pa', 'फ': 'pha', 'ब': 'ba', 'भ': 'bha', 'म': 'ma', 'य': 'ya', 'र': 'ra', 'ल': 'la', 'व': 'va', 'श': 'sha', 'ष': 'sha', 'स': 'sa', 'ह': 'ha'
        };
        const transliterate = (text) => text.split('').map(char => TRANSLITERATE_MAP[char] || char).join('');

        // ==========================================
        // 2. DATABASE
        // ==========================================
        const db = new Dexie("ShelfLife_Final_v40");
        db.version(1).stores({ books: "++id, title, phonetic, author, owner, publisher, language, building, shelf, status, date_added, isbn, page_count, condition, currency" });

        const { useState, useEffect, useMemo, useRef } = React;

        // --- 3. COMPONENTS ---

        // AUTO-SUGGEST INPUT
        const AutoSuggestInput = ({ label, value, onChange, field, placeholder }) => {
            const [suggestions, setSuggestions] = useState([]);

            useEffect(() => {
                db.books.toArray().then(all => {
                    const set = new Set(all.map(b => b[field]).filter(Boolean));
                    setSuggestions([...set].sort());
                });
            }, [field]);

            return (
                <div className="relative">
                    <label className="text-xs text-gray-500 font-bold">{label}</label>
                    <input
                        list={`list-${field}`}
                        className="w-full p-3 border rounded-lg"
                        value={value}
                        onChange={onChange}
                        placeholder={placeholder}
                    />
                    <datalist id={`list-${field}`}>
                        {suggestions.map((s, i) => <option key={i} value={s} />)}
                    </datalist>
                </div>
            );
        };

        // VOICE INPUT (Wrapped)
        const VoiceInput = ({ label, value, onChange, onVoice, isListening, lang, type = "text", placeholder }) => {
            return (
                <div className="relative">
                    <label className="text-xs text-gray-500 font-bold">{label}</label>
                    <div className="relative">
                        <input
                            type={type}
                            className="w-full p-3 border rounded-lg pr-10"
                            placeholder={placeholder}
                            value={value}
                            onChange={onChange}
                            lang={lang}
                        />
                        <button
                            type="button"
                            onClick={onVoice}
                            className={`absolute right-2 top-2 p-1 rounded-full ${isListening ? 'bg-red-500 text-white animate-pulse' : 'text-gray-400'}`}
                        >
                            <Icon name="Mic" size={20} />
                        </button>
                    </div>
                </div>
            );
        };

        // BARCODE SCANNER
        const BarcodeScanner = ({ onDetected, onClose }) => {
            const [online, setOnline] = useState(navigator.onLine);

            useEffect(() => {
                window.addEventListener('online', () => setOnline(true));
                window.addEventListener('offline', () => setOnline(false));

                if (!window.Html5QrcodeScanner) return onClose();
                const scanner = new Html5QrcodeScanner("reader", { fps: 10, qrbox: 250 });
                scanner.render((t) => { scanner.clear(); onDetected(t); }, (e) => { });
                return () => { try { scanner.clear(); } catch (e) { } };
            }, []);

            return (
                <div className="fixed inset-0 bg-black z-50 flex flex-col">
                    <div className="p-4 flex justify-between text-white bg-black/50 absolute top-0 w-full z-10 items-center">
                        <span className="flex items-center gap-2">
                            <div className={`w-3 h-3 rounded-full ${online ? 'bg-green-500' : 'bg-red-500'}`}></div>
                            {online ? 'Online' : 'Offline'}
                        </span>
                        <button onClick={onClose}><Icon name="X" /></button>
                    </div>
                    <div id="reader" className="flex-1 bg-white"></div>
                </div>
            );
        };

        // BOOK FORM
        const BookForm = ({ book, onSave, onCancel, onBarcodeFound, globalCurrency }) => {
            const [form, setForm] = useState(book ? { ...book, pages: book.pages || [] } : {
                title: '', phonetic: '', author: '', owner: '', building: '', shelf: '', isbn: '',
                price: '', currency: '₹', year: '', lang: 'en', tags: [], status: 'avail', page_count: '', condition: 'Good',
                front: null, rear: null, thumb: null, pages: []
            });
            const [scanMode, setScanMode] = useState(false);
            const [listeningField, setListeningField] = useState(null);

            const handleImg = async (e, field) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    try {
                        const res = await ImageUtils.process(file);
                        setForm(prev => ({ ...prev, [field]: res }));
                    } catch (err) { alert("Error: " + err); }
                }
            };

            const handlePageAdd = async (e) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    try {
                        const res = await ImageUtils.process(file);
                        setForm(f => ({ ...f, pages: [...(f.pages || []), res] }));
                    } catch (err) { alert("Error: " + err); }
                }
            };



            const handleBarcode = async (isbn) => {
                setScanMode(false);
                const exists = await db.books.where('isbn').equals(isbn).first();
                if (exists) {
                    alert("This book already exists in your library!");
                    if (onBarcodeFound) onBarcodeFound(exists);
                    return;
                }

                if (navigator.onLine) {
                    try {
                        const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`);
                        const data = await res.json();
                        if (data.items && data.items[0]) {
                            const info = data.items[0].volumeInfo;
                            setForm(f => ({
                                ...f, isbn: isbn, title: info.title, author: info.authors?.[0],
                                publisher: info.publisher, pub_year: info.publishedDate?.substring(0, 4),
                                front: info.imageLinks?.thumbnail, page_count: info.pageCount
                            }));
                        } else { alert("Not found in API. Please enter details manually."); }
                    } catch (e) { alert("API Error. Please check internet."); }
                } else {
                    setForm(f => ({ ...f, isbn: isbn }));
                    alert("Offline Mode: ISBN Scanned. Please enter details.");
                }
            };

            let activeRecognition = null;
            let voiceTimeout = null;

            const stopVoice = () => {
                if (activeRecognition) {
                    try { activeRecognition.stop(); } catch (e) { }
                    activeRecognition = null;
                }
                if (voiceTimeout) {
                    clearTimeout(voiceTimeout);
                    voiceTimeout = null;
                }
                setListeningField(null);
            };

            const startVoice = async (field) => {
                // 0. Toggle Logic
                if (listeningField === field) {
                    stopVoice();
                    return;
                }
                stopVoice();

                if (!navigator.onLine) return alert("No Internet Connection.");

                // Determine language
                const useNative = field === 'title' && form.lang !== 'en';
                const language = useNative
                    ? (form.lang === 'ml' ? 'ml-IN' : form.lang === 'ar' ? 'ar-SA' : 'hi-IN')
                    : 'en-US';

                // Use Native Plugin if in Capacitor
                const NativeSpeech = window.Capacitor?.Plugins?.SpeechRecognition;

                if (window.Capacitor && NativeSpeech) {
                    try {
                        // Check availability
                        const { available } = await NativeSpeech.available();
                        if (!available) return alert("Speech Recognition not available on this device.");

                        // Check/Request permissions
                        const permStatus = await NativeSpeech.checkPermissions();
                        if (permStatus.speechRecognition !== 'granted') {
                            const req = await NativeSpeech.requestPermissions();
                            if (req.speechRecognition !== 'granted') return alert("Microphone permission denied.");
                        }

                        setListeningField(field);

                        // Start native recognition
                        const result = await NativeSpeech.start({
                            language: language,
                            popup: false,
                            partialResults: false
                        });

                        if (result.matches && result.matches.length > 0) {
                            const transcript = result.matches[0];
                            if (field === 'tags') {
                                const newTags = transcript.split(/[\s,]+/).filter(Boolean);
                                setForm(f => ({ ...f, tags: [...(f.tags || []), ...newTags] }));
                            } else {
                                setForm(f => ({ ...f, [field]: transcript }));
                            }
                        }
                        stopVoice();
                    } catch (e) {
                        stopVoice();
                        if (e.message && e.message.includes('cancelled')) return; // User cancelled
                        alert("Voice Error: " + (e.message || e));
                    }
                } else {
                    // Fallback to Web Speech API (for browser testing)
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SpeechRecognition) return alert("Speech not supported in browser.");

                    try {
                        const recognition = new SpeechRecognition();
                        activeRecognition = recognition;
                        recognition.lang = language;
                        recognition.continuous = false;
                        recognition.interimResults = false;

                        recognition.onstart = () => setListeningField(field);
                        recognition.onend = () => stopVoice();
                        recognition.onerror = (e) => { stopVoice(); };
                        recognition.onresult = (event) => {
                            const transcript = event.results[0][0].transcript;
                            if (field === 'tags') {
                                const newTags = transcript.split(/[\s,]+/).filter(Boolean);
                                setForm(f => ({ ...f, tags: [...(f.tags || []), ...newTags] }));
                            } else {
                                setForm(f => ({ ...f, [field]: transcript }));
                            }
                            stopVoice();
                        };
                        recognition.start();
                    } catch (e) {
                        alert("Error: " + e.message);
                    }
                }
            };


            const saveCheck = async () => {
                const exists = await db.books.where('title').equalsIgnoreCase(form.title).toArray();
                if (exists.length > 0) {
                    const isSelf = form.id && exists.length === 1 && exists[0].id === form.id;
                    if (!isSelf && !confirm(`Possible Duplicate: "${form.title}" exists. Save anyway?`)) return;
                }
                onSave(form);
            };

            const handleChange = (field, val) => setForm(prev => ({ ...prev, [field]: val }));

            return (
                <div className="bg-white min-h-screen pb-24">
                    {scanMode && <BarcodeScanner onDetected={handleBarcode} onClose={() => setScanMode(false)} />}
                    <div className="p-4 border-b flex justify-between sticky top-0 bg-white z-20 shadow-sm">
                        <button onClick={onCancel} className="text-gray-500">Cancel</button>
                        <h2 className="font-bold">{book ? 'Edit' : 'Cataloging'}</h2>
                        <button onClick={saveCheck} className="text-blue-600 font-bold">Save</button>
                    </div>

                    <div className="p-4 space-y-5">
                        {!book && <button onClick={() => setScanMode(true)} className="w-full py-4 bg-gray-800 text-white rounded-xl flex flex-col items-center justify-center font-bold mb-4"><Icon name="Barcode" size={32} /> <span>Scan Barcode</span></button>}

                        {/* GALLERY */}
                        <div className="flex gap-3 overflow-x-auto pb-2 no-scrollbar">
                            {/* FRONT COVER */}
                            <div className="flex-shrink-0 w-28 h-40 bg-gray-100 rounded-lg border-2 border-dashed border-gray-300 relative overflow-hidden group">
                                {form.front ? <img src={form.front} className="w-full h-full object-cover" /> : <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400"><Icon name="Maximize" /><span className="text-[10px]">Front</span></div>}
                                <label className="absolute inset-0 cursor-pointer flex items-center justify-center bg-transparent group-hover:bg-black/10 transition-colors">
                                    <input type="file" className="hidden" onChange={e => handleImg(e, 'front')} capture="environment" accept="image/*" />
                                </label>
                            </div>

                            {/* REAR COVER */}
                            <div className="flex-shrink-0 w-28 h-40 bg-gray-100 rounded-lg border-2 border-dashed border-gray-300 relative overflow-hidden group">
                                {form.rear ? <img src={form.rear} className="w-full h-full object-cover" /> : <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400"><Icon name="Maximize" /><span className="text-[10px]">Rear</span></div>}
                                <label className="absolute inset-0 cursor-pointer flex items-center justify-center bg-transparent group-hover:bg-black/10 transition-colors">
                                    <input type="file" className="hidden" onChange={e => handleImg(e, 'rear')} capture="environment" accept="image/*" />
                                </label>
                            </div>
                        </div>

                        {/* PAGES */}
                        <div className="flex gap-2 overflow-x-auto pb-2">
                            {(form.pages || []).map((p, i) => (
                                <div key={i} className="flex-shrink-0 w-28 h-40 relative group">
                                    <img src={p} className="w-full h-full object-cover rounded-lg border" />
                                    <button onClick={() => setForm(f => ({ ...f, pages: f.pages.filter((_, idx) => idx !== i) }))} className="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1"><Icon name="X" size={12} /></button>
                                </div>
                            ))}
                            {/* Manual Add Page */}
                            <label className="flex-shrink-0 w-28 h-40 bg-gray-100 border-2 border-dashed border-gray-300 rounded-lg flex flex-col items-center justify-center overflow-hidden relative cursor-pointer hover:bg-gray-50">
                                <Icon name="PlusSquare" className="text-gray-400" />
                                <span className="text-[10px] font-bold text-gray-400 mt-1">Add Page</span>
                                <input type="file" className="hidden" onChange={handlePageAdd} capture="environment" accept="image/*" />
                            </label>
                        </div>

                        {/* META DATA */}
                        <div className="space-y-3">
                            <div className="flex gap-2 mb-2">
                                {['en', 'ml', 'hi', 'ar'].map(l => (
                                    <button key={l} onClick={() => setForm({ ...form, lang: l })} className={`px-3 py-1 rounded text-xs font-bold uppercase border ${form.lang === l ? 'bg-blue-600 text-white' : 'bg-white text-gray-600'}`}>{l}</button>
                                ))}
                            </div>

                            <VoiceInput label="Title (Native)" field="title" value={form.title} onChange={(e) => handleChange('title', e.target.value)} onVoice={() => startVoice('title')} isListening={listeningField === 'title'} lang={form.lang} />
                            <VoiceInput label="Phonetic (Manual)" field="phonetic" value={form.phonetic} onChange={(e) => handleChange('phonetic', e.target.value)} onVoice={() => startVoice('phonetic')} isListening={listeningField === 'phonetic'} lang="en" />
                            <VoiceInput label="ISBN" field="isbn" value={form.isbn} onChange={(e) => handleChange('isbn', e.target.value)} onVoice={() => startVoice('isbn')} isListening={listeningField === 'isbn'} lang="en" />

                            <div className="relative">
                                <AutoSuggestInput label="Author" field="author" value={form.author} onChange={(e) => handleChange('author', e.target.value)} />
                                <button type="button" onClick={() => startVoice('author')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'author' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                            </div>

                            <div className="grid grid-cols-2 gap-4">
                                <div className="relative">
                                    <AutoSuggestInput label="Publisher" field="publisher" value={form.publisher} onChange={(e) => handleChange('publisher', e.target.value)} />
                                    <button type="button" onClick={() => startVoice('publisher')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'publisher' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                                </div>
                                <VoiceInput label="Pub Year" field="pub_year" value={form.pub_year} onChange={(e) => handleChange('pub_year', e.target.value)} onVoice={() => startVoice('pub_year')} isListening={listeningField === 'pub_year'} lang="en" type="number" />
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <VoiceInput label="Pages" field="page_count" value={form.page_count} onChange={(e) => handleChange('page_count', e.target.value)} type="number" lang="en" />
                                <div>
                                    <label className="text-xs text-gray-500 font-bold">Condition</label>
                                    <select className="w-full p-3 border rounded-lg bg-white" value={form.condition} onChange={e => handleChange('condition', e.target.value)}>
                                        <option>Good</option><option>New</option><option>Old</option><option>Torn</option><option>Loose</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        {/* ASSET DATA */}
                        <h3 className="text-xs font-bold text-gray-400 uppercase mt-4">Asset Info</h3>
                        <div className="space-y-3">
                            <div className="relative">
                                <AutoSuggestInput label="Owner" field="owner" value={form.owner} onChange={(e) => handleChange('owner', e.target.value)} placeholder="e.g. Dad" />
                                <button type="button" onClick={() => startVoice('owner')} className={`absolute right-2 bottom-3 p-1 rounded-full z-10 ${listeningField === 'owner' ? 'bg-red-500 text-white' : 'text-gray-400'}`}><Icon name="Mic" size={20} /></button>
                            </div>

                            <div className="grid grid-cols-2 gap-4">
                                <div className="flex gap-1">
                                    <div className="w-1/3">
                                        <label className="text-xs text-gray-500 font-bold">Currency</label>
                                        <input className="w-full p-3 border rounded-lg text-center font-bold" value={form.currency} onChange={e => handleChange('currency', e.target.value)} list="currencies" />
                                        <datalist id="currencies"><option value="₹" /><option value="$" /><option value="€" /><option value="£" /><option value="QAR" /><option value="DH" /></datalist>
                                    </div>
                                    <div className="w-2/3">
                                        <label className="text-xs text-gray-500 font-bold">Price</label>
                                        <input type="number" className="w-full p-3 border rounded-lg" value={form.price} onChange={e => handleChange('price', e.target.value)} />
                                    </div>
                                </div>
                                <VoiceInput label="Buy Year" field="buy_year" value={form.buy_year} onChange={(e) => handleChange('buy_year', e.target.value)} onVoice={() => startVoice('buy_year')} isListening={listeningField === 'buy_year'} lang="en" type="number" />
                            </div>
                        </div>

                        {/* LOCATION */}
                        <h3 className="text-xs font-bold text-gray-400 uppercase mt-4">Location</h3>
                        <div className="grid grid-cols-2 gap-4">
                            <AutoSuggestInput label="Building" field="building" value={form.building} onChange={(e) => handleChange('building', e.target.value)} />
                            <AutoSuggestInput label="Shelf" field="shelf" value={form.shelf} onChange={(e) => handleChange('shelf', e.target.value)} />
                        </div>

                        <VoiceInput label="Tags" field="tags" value={(form.tags || []).join(',')} onChange={(e) => setForm(f => ({ ...f, tags: e.target.value.split(',') }))} onVoice={() => startVoice('tags')} isListening={listeningField === 'tags'} lang="en" placeholder="e.g. history, torn" />
                    </div>
                </div>
            );
        };

        // MULTI-TAG SEARCH INPUT
        const MultiTagInput = ({ options, value, onChange, placeholder }) => {
            const [input, setInput] = useState('');
            const [filteredOpts, setFilteredOpts] = useState([]);

            // Suggest logic
            useEffect(() => {
                if (!input) { setFilteredOpts([]); return; }
                const q = input.toLowerCase();
                const matches = options.filter(o => o.toLowerCase().includes(q) && !value.includes(o)).slice(0, 5);
                setFilteredOpts(matches);
            }, [input, options, value]);

            const addTag = (t) => {
                onChange([...value, t]);
                setInput('');
            };

            const removeTag = (t) => {
                onChange(value.filter(v => v !== t));
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (filteredOpts.length > 0) addTag(filteredOpts[0]);
                    else if (input) { addTag(input); }
                }
                if (e.key === 'Backspace' && !input && value.length > 0) {
                    removeTag(value[value.length - 1]);
                }
            };

            return (
                <div className="flex items-center gap-2 flex-wrap bg-gray-100 p-2 rounded-lg border focus-within:ring-2 focus-within:ring-blue-200">
                    <Icon name="Search" className="text-gray-400" size={16} />
                    {value.map(t => (
                        <span key={t} className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full flex items-center gap-1">
                            {t}
                            <button onClick={() => removeTag(t)} className="hover:text-red-500">×</button>
                        </span>
                    ))}
                    <div className="relative flex-1 min-w-[60px]">
                        <input
                            className="w-full bg-transparent text-sm focus:outline-none min-w-[100px]"
                            placeholder={value.length > 0 ? "" : placeholder}
                            value={input}
                            onChange={e => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                        />
                        {filteredOpts.length > 0 && (
                            <div className="absolute top-full left-0 bg-white border shadow-lg rounded mt-1 z-50 w-full min-w-[150px]">
                                {filteredOpts.map(o => (
                                    <div key={o} onClick={() => addTag(o)} className="p-2 text-sm hover:bg-gray-100 cursor-pointer">{o}</div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- SLICER SEARCH ---
        const SlicerSearch = ({ books, onEdit }) => {
            const [activeFilters, setActiveFilters] = useState([]);
            const [pendingField, setPendingField] = useState('publisher');
            const [pendingValue, setPendingValue] = useState('');
            const [viewMode, setViewMode] = useState('grid');
            const [detailBook, setDetailBook] = useState(null);

            const suggestions = useMemo(() => {
                const set = new Set();
                books.forEach(b => {
                    if (['publisher', 'author', 'owner', 'building', 'lang', 'condition'].includes(pendingField)) {
                        if (b[pendingField]) set.add(b[pendingField]);
                    }
                    if (pendingField === 'tags' && b.tags) b.tags.forEach(t => set.add(t));
                    if (pendingField === 'pub_year' && b.pub_year) set.add(b.pub_year);
                });
                return [...set].sort();
            }, [books, pendingField]);

            const addFilter = () => {
                if (!pendingValue) return;
                setActiveFilters([...activeFilters, { field: pendingField, value: pendingValue }]);
                setPendingValue('');
            };

            const removeFilter = (index) => {
                const next = [...activeFilters];
                next.splice(index, 1);
                setActiveFilters(next);
            };

            const filtered = books.filter(b => {
                if (activeFilters.length === 0) return true;
                return activeFilters.every(f => {
                    if (f.field === 'tags') return b.tags && b.tags.includes(f.value);
                    return b[f.field] == f.value;
                });
            });

            return (
                <div className="pb-24 flex flex-col h-screen">
                    <div className="bg-white p-4 border-b">
                        <h2 className="text-xl font-bold mb-4">Slicer Studio</h2>

                        <div className="flex gap-2 mb-2">
                            <select className="p-2 border rounded bg-gray-50 text-sm font-bold uppercase w-1/3" value={pendingField} onChange={e => setPendingField(e.target.value)}>
                                <option value="publisher">Publisher</option><option value="author">Author</option><option value="owner">Owner</option><option value="tags">Tags</option><option value="lang">Language</option><option value="building">Location</option><option value="pub_year">Year</option><option value="condition">Condition</option>
                            </select>
                            <input list="slicer-suggestions" className="flex-1 p-2 border rounded" placeholder="Select value..." value={pendingValue} onChange={e => setPendingValue(e.target.value)} />
                            <datalist id="slicer-suggestions">{suggestions.map(s => <option key={s} value={s} />)}</datalist>
                            <button onClick={addFilter} className="bg-blue-600 text-white px-4 rounded font-bold">+</button>
                        </div>
                        <div className="flex flex-wrap gap-2 min-h-[30px]">
                            {activeFilters.length === 0 && <span className="text-xs text-gray-400 italic py-1">No active filters. Showing all books.</span>}
                            {activeFilters.map((f, i) => (
                                <span key={i} className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full flex items-center gap-1 border border-blue-200">
                                    <b>{f.field}:</b> {f.value}
                                    <button onClick={() => removeFilter(i)} className="ml-1 text-blue-500 hover:text-red-500 font-bold">×</button>
                                </span>
                            ))}
                        </div>
                        <div className="flex justify-between items-center mt-4 pt-2 border-t">
                            <span className="text-xs font-bold text-gray-500">{filtered.length} Results</span>
                            <div className="flex gap-2 items-center">
                                <button onClick={() => setViewMode(viewMode === 'grid' ? 'list' : 'grid')} className="p-2 border rounded text-gray-500 hover:bg-gray-100"><Icon name={viewMode === 'grid' ? 'LayoutList' : 'Grid'} size={16} /></button>
                                <button onClick={() => ExportUtils.csv(filtered, 'Slicer_vew_export')} className="text-xs font-bold text-gray-500 border rounded px-2 py-1 flex gap-1 items-center hover:bg-gray-50"><Icon name="Download" size={12} /> CSV</button>
                                <button onClick={() => ExportUtils.htmlText(filtered, 'mixed', "Filtered Report")} className="text-xs font-bold text-gray-500 border rounded px-2 py-1 flex gap-1 items-center hover:bg-gray-50"><Icon name="FileText" size={12} /> HTML</button>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
                        {viewMode === 'grid' ? (
                            <div className="grid grid-cols-2 gap-4">
                                {filtered.map(b => (
                                    <div key={b.id} onClick={() => setDetailBook(b)} className="bg-white p-2 rounded shadow text-center cursor-pointer hover:shadow-md transition-shadow">
                                        {b.front ? <img src={b.front} className="h-24 mx-auto object-cover mb-2 rounded" /> : <div className="h-24 bg-gray-100 flex items-center justify-center mb-2 rounded"><Icon name="Book" /></div>}
                                        <div className="font-bold text-sm truncate">{b.title}</div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-2">
                                {filtered.map(b => (
                                    <div key={b.id} onClick={() => setDetailBook(b)} className="bg-white p-3 rounded shadow flex gap-3 items-center cursor-pointer hover:bg-gray-50">
                                        {b.front ? <img src={b.front} className="w-10 h-14 object-cover rounded" /> : <div className="w-10 h-14 bg-gray-200 rounded flex items-center justify-center"><Icon name="Book" size={16} /></div>}
                                        <div className="flex-1 min-w-0">
                                            <div className="font-bold text-sm truncate">{b.title}</div>
                                            <div className="text-xs text-gray-500 truncate">{b.author} • {b.publisher}</div>
                                        </div>
                                        <div className="text-xs font-bold text-gray-400">{b.pub_year}</div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                    {detailBook && <DetailModal book={detailBook} onClose={() => setDetailBook(null)} onEdit={(b) => { onEdit(b); setDetailBook(null) }} />}
                </div>
            );
        };

        // --- LIBRARY & DETAIL ---
        const LibraryView = ({ books, onEdit, onDeleteMulti }) => {
            const [sort, setSort] = useState({ p: 'date_added', s: 'title', dir: 'desc' });
            const [detailBook, setDetailBook] = useState(null);
            const [selectMode, setSelectMode] = useState(false);
            const [selected, setSelected] = useState([]);
            const [viewMode, setViewMode] = useState('grid');
            const [search, setSearch] = useState({ tags: [], query: '' });

            const suggestions = useMemo(() => {
                const s = new Set();
                books.forEach(b => {
                    if (b.title) s.add(b.title);
                    if (b.author) s.add(b.author);
                    if (b.publisher) s.add(b.publisher);
                    if (b.owner) s.add(b.owner);
                    if (b.tags) b.tags.forEach(t => s.add(t));
                });
                return [...s].sort();
            }, [books]);

            const sorted = useMemo(() => {
                const res = books.filter(b => {
                    // TEXT SEARCH
                    if (search.query) {
                        const q = search.query.toLowerCase();
                        const match = (b.title || '').toLowerCase().includes(q) ||
                            (b.author || '').toLowerCase().includes(q) ||
                            (b.isbn || '').includes(q) ||
                            (b.tags || []).some(t => t.toLowerCase().includes(q)) ||
                            (b.owner || '').toLowerCase().includes(q) ||
                            (b.building || '').toLowerCase().includes(q) ||
                            (b.shelf || '').toLowerCase().includes(q) ||
                            (b.phonetic || '').toLowerCase().includes(q) ||
                            (b.pub_year || '').includes(q) ||
                            (b.publisher || '').toLowerCase().includes(q);
                        if (!match) return false;
                    }
                    // TAG FILTER
                    if (search.tags && search.tags.length > 0) {
                        const bTags = b.tags || [];
                        if (!search.tags.every(t => bTags.includes(t))) return false;
                    }
                    return true;
                });
                return res.sort((a, b) => {
                    const vA = a[sort.p] || '', vB = b[sort.p] || '';
                    if (vA < vB) return sort.dir === 'asc' ? -1 : 1; if (vA > vB) return sort.dir === 'asc' ? 1 : -1;
                    return (a[sort.s] || '').localeCompare(b[sort.s] || '');
                });
            }, [books, sort, search]);

            const toggleSelect = (id) => {
                setSelected(prev => prev.includes(id) ? prev.filter(i => i !== id) : [...prev, id]);
            };

            const handleCardClick = (b) => {
                if (selectMode) toggleSelect(b.id); else setDetailBook(b);
            };

            const handleMultiDelete = () => { onDeleteMulti(selected); setSelected([]); setSelectMode(false); };

            return (
                <div className="pb-24">
                    <div className="bg-white p-4 sticky top-0 z-10 shadow-sm flex flex-col gap-2">
                        <div className="flex justify-between items-center">
                            <h2 className="text-xl font-bold">Library</h2>
                            <div className="flex gap-2">
                                <button onClick={() => setViewMode(viewMode === 'grid' ? 'list' : 'grid')} className="p-2 border rounded text-gray-500 hover:bg-gray-100"><Icon name={viewMode === 'grid' ? 'LayoutList' : 'Grid'} size={16} /></button>
                                {selectMode ?
                                    <button onClick={handleMultiDelete} className="text-xs bg-red-100 text-red-600 px-3 py-1 rounded font-bold">Delete ({selected.length})</button>
                                    :
                                    <select className="text-xs border rounded p-1" onChange={e => setSort({ ...sort, p: e.target.value })}>
                                        <option value="date_added">Recent</option><option value="title">Title</option><option value="author">Author</option><option value="year">Year</option>
                                    </select>
                                }
                                <button onClick={() => ExportUtils.csv(sorted, 'Lib_vew_export')} className="p-2 border rounded text-gray-500 hover:bg-gray-100" title="Export CSV"><Icon name="Download" size={16} /></button>
                                <button onClick={() => { setSelectMode(!selectMode); setSelected([]) }} className={`text-xs border rounded p-1 ${selectMode ? 'bg-blue-600 text-white' : 'text-gray-500'}`}>{selectMode ? 'Done' : 'Select'}</button>
                            </div>
                        </div>
                        <MultiTagInput
                            options={[...new Set(books.flatMap(b => b.tags || []))].sort()}
                            value={search.tags}
                            onChange={tags => setSearch({ ...search, tags })}
                            placeholder="Filter by tags..."
                        />
                        <div className="mt-2 text-xs flex gap-2">
                            <div className="relative flex-1">
                                <Icon name="Search" className="absolute left-2 top-2 text-gray-400" size={14} />
                                <input
                                    className="w-full p-2 pl-8 border rounded"
                                    placeholder="Search Title, Author, ISBN..."
                                    value={search.query}
                                    list="lib-suggestions"
                                    onChange={e => setSearch({ ...search, query: e.target.value })}
                                />
                                <datalist id="lib-suggestions">
                                    {suggestions.map((s, i) => <option key={i} value={s} />)}
                                </datalist>
                            </div>
                        </div>
                    </div>

                    <div className="p-4">
                        {viewMode === 'grid' ? (
                            <div className="grid grid-cols-2 gap-4">
                                {sorted.map(b => (
                                    <div key={b.id} onClick={() => handleCardClick(b)} className={`bg-white p-3 rounded-xl shadow-sm border relative cursor-pointer ${selected.includes(b.id) ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-100'}`}>
                                        {selectMode && <div className={`absolute top-2 right-2 w-5 h-5 rounded-full border-2 ${selected.includes(b.id) ? 'bg-blue-500 border-blue-500' : 'border-gray-300'} flex items-center justify-center`}>{selected.includes(b.id) && <Icon name="CheckSquare" className="text-white" size={12} />}</div>}
                                        <div className="w-full h-40 bg-gray-100 rounded-lg overflow-hidden mb-2">
                                            {b.front ? <img src={b.front} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-300"><Icon name="Book" size={32} /></div>}
                                        </div>
                                        <h3 className="font-bold leading-tight text-sm line-clamp-2">{b.title}</h3>
                                        <p className="text-xs text-gray-500 truncate">{b.author}</p>
                                        <div className="absolute top-2 left-2 bg-black/50 text-white text-[10px] px-2 rounded">{b.currency || ''} {b.price}</div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-2">
                                {sorted.map(b => (
                                    <div key={b.id} onClick={() => handleCardClick(b)} className={`bg-white p-3 rounded-xl shadow-sm border flex gap-3 items-center relative cursor-pointer ${selected.includes(b.id) ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-100'}`}>
                                        {selectMode && <div className={`absolute top-2 right-2 w-5 h-5 rounded-full border-2 ${selected.includes(b.id) ? 'bg-blue-500 border-blue-500' : 'border-gray-300'} flex items-center justify-center`}>{selected.includes(b.id) && <Icon name="CheckSquare" className="text-white" size={12} />}</div>}
                                        {b.front ? <img src={b.front} className="w-12 h-16 object-cover rounded" /> : <div className="w-12 h-16 bg-gray-200 rounded flex items-center justify-center"><Icon name="Book" size={16} /></div>}
                                        <div className="flex-1 min-w-0">
                                            <h3 className="font-bold text-sm truncate">{b.title}</h3>
                                            <p className="text-xs text-gray-500 truncate">{b.author}</p>
                                            <div className="text-[10px] text-gray-400">{b.publisher} • {b.pub_year}</div>
                                        </div>
                                        <div className="font-bold text-sm">{b.currency || ''} {b.price}</div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* DETAIL MODAL (READ ONLY + GALLERY + ZOOM) */}
                    {detailBook && (
                        <DetailModal book={detailBook} onClose={() => setDetailBook(null)} onEdit={(b) => { onEdit(b); setDetailBook(null) }} />
                    )}
                </div>
            );
        };

        // --- DETAIL MODAL WITH ZOOM ---
        const DetailModal = ({ book, onClose, onEdit }) => {
            const [zoomImg, setZoomImg] = useState(null);

            return (
                <div className="fixed inset-0 bg-black/80 z-50 flex items-end sm:items-center justify-center p-4">
                    {zoomImg && (
                        <div className="fixed inset-0 z-[60] bg-black flex items-center justify-center" onClick={() => setZoomImg(null)}>
                            <img src={zoomImg} className="max-w-full max-h-full object-contain" />
                            <button className="absolute top-4 right-4 text-white p-2 bg-black/50 rounded-full"><Icon name="X" size={32} /></button>
                        </div>
                    )}

                    <div className="bg-white w-full max-w-md rounded-2xl overflow-hidden max-h-[90vh] overflow-y-auto">
                        <div className="relative h-64 bg-gray-100 overflow-x-auto whitespace-nowrap flex">
                            {/* Gallery View */}
                            {book.front && <img src={book.front} onClick={() => setZoomImg(book.front)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />}
                            {book.rear && <img src={book.rear} onClick={() => setZoomImg(book.rear)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />}
                            {(book.pages || []).map((p, i) => <img key={i} src={p} onClick={() => setZoomImg(p)} className="h-full w-auto object-contain flex-shrink-0 mr-1 bg-black/5 cursor-zoom-in" />)}
                            <button onClick={onClose} className="absolute top-4 right-4 bg-white/50 p-2 rounded-full"><Icon name="X" /></button>
                        </div>
                        <div className="p-6">
                            <h1 className="text-2xl font-bold mb-1">{book.title}</h1>
                            <p className="text-gray-600 mb-4">{book.author}</p>

                            <div className="grid grid-cols-2 gap-4 text-sm mb-6">
                                <div className="bg-gray-50 p-3 rounded"><span className="block text-gray-400 text-xs uppercase">Publisher</span><b>{book.publisher || '-'}</b></div>
                                <div className="bg-gray-50 p-3 rounded"><span className="block text-gray-400 text-xs uppercase">Year</span><b>{book.pub_year || '-'}</b></div>
                                <div className="bg-gray-50 p-3 rounded"><span className="block text-gray-400 text-xs uppercase">Location</span><b>{book.building} {book.shelf}</b></div>
                                <div className="bg-gray-50 p-3 rounded"><span className="block text-gray-400 text-xs uppercase">Pages</span><b>{book.page_count || '-'}</b></div>
                                <div className="bg-gray-50 p-3 rounded"><span className="block text-gray-400 text-xs uppercase">Condition</span><b>{book.condition || '-'}</b></div>
                                <div className="bg-gray-50 p-3 rounded"><span className="block text-gray-400 text-xs uppercase">Owner</span><b>{book.owner || '-'}</b></div>
                                <div className="bg-gray-50 p-3 rounded"><span className="block text-gray-400 text-xs uppercase">ISBN</span><b>{book.isbn || '-'}</b></div>
                                <div className="bg-gray-50 p-3 rounded"><span className="block text-gray-400 text-xs uppercase">Value</span><b>{book.currency || ''} {book.price}</b></div>
                            </div>
                            <button onClick={() => onEdit(book)} className="w-full py-4 bg-blue-600 text-white font-bold rounded-xl flex items-center justify-center gap-2"><Icon name="Edit3" /> Edit / Update</button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD ---
        const Dashboard = ({ books }) => {
            const total = books.length;
            // Group by currency
            const assetBreakdown = useMemo(() => {
                const groups = {};
                books.forEach(b => {
                    const curr = b.currency || '?';
                    groups[curr] = (groups[curr] || 0) + (Number(b.price) || 0);
                });
                return groups;
            }, [books]);

            const pubStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.publisher || 'Unknown'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);
            }, [books]);

            // NEW: Lang/Loc Stats for Dash
            const langStats = useMemo(() => {
                const c = {}; books.forEach(b => { c[b.lang || 'en'] = (c[b.lang || 'en'] || 0) + 1 });
                const total = books.length || 1; let current = 0;
                const colors = { en: '#3b82f6', ml: '#10b981', ar: '#f59e0b', hi: '#ef4444' };
                return Object.entries(c).map(([l, v]) => {
                    const pct = (v / total) * 100; const str = `${colors[l] || '#ccc'} ${current}% ${current + pct}%`; current += pct; return str;
                }).join(', ');
            }, [books]);

            const locStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.building || 'Unknown'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);
            }, [books]);

            const tagStats = useMemo(() => {
                const c = {}; books.forEach(b => { if (b.tags) b.tags.forEach(t => c[t] = (c[t] || 0) + 1) });
                return Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);
            }, [books]);

            const condStats = useMemo(() => {
                const c = {}; books.forEach(b => { const k = b.condition || 'Good'; c[k] = (c[k] || 0) + 1; });
                return Object.entries(c).sort((a, b) => b[1] - a[1]);
            }, [books]);

            const repairList = books.filter(b => b.condition === 'Torn' || b.condition === 'Loose' || (b.tags && b.tags.includes('repair')));

            return (
                <div className="p-4 space-y-6 pb-24">
                    <h2 className="text-2xl font-bold">Analytics</h2>
                    <div className="grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow border border-blue-100"><p className="text-xs text-gray-500 font-bold uppercase">Total Books</p><p className="text-3xl font-bold text-blue-600">{total}</p></div>
                        <div className="bg-white p-4 rounded-xl shadow border border-green-100"><p className="text-xs text-gray-500 font-bold uppercase">Asset Value</p>
                            {Object.entries(assetBreakdown).map(([curr, val]) => (
                                <div key={curr} className="text-lg font-bold text-green-600">{curr} {val.toLocaleString()}</div>
                            ))}
                            {Object.keys(assetBreakdown).length === 0 && <p className="text-xl font-bold text-gray-400">0</p>}
                        </div>
                    </div>

                    {repairList.length > 0 && <div className="bg-red-50 p-4 rounded-xl border border-red-200 text-red-800 font-bold flex items-center gap-2"><Icon name="AlertCircle" /> {repairList.length} Books Need Repair</div>}

                    <div className="bg-white p-4 rounded-xl shadow border flex gap-4">
                        <div className="pie-chart flex-shrink-0" style={{ '--pie-gradient': langStats }}></div>
                        <div><h3 className="font-bold mb-2">Language Mix</h3><div className="text-xs text-gray-500">Visual breakdown of your library languages.</div></div>
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Top Publishers</h3>
                        {pubStats.map(([k, v]) => (
                            <div key={k} className="mb-2"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-purple-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Locations</h3>
                        {locStats.map(([k, v]) => (
                            <div key={k} className="mb-2"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-blue-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-4">Top Tags</h3>
                        {tagStats.map(([k, v]) => (
                            <div key={k} className="mb-2"><div className="flex justify-between text-xs mb-1"><span>{k}</span><b>{v}</b></div><div className="bar-bg"><div className="bar-fill bg-green-500" style={{ width: `${(v / total) * 100}%` }}></div></div></div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- TOOLS ---
        const Tools = ({ books }) => {
            const [lastRestore, setLastRestore] = useState(null);
            useEffect(() => {
                const stored = localStorage.getItem('shelfLife_restore_meta');
                if (stored) setLastRestore(JSON.parse(stored));
            }, []);

            // Consolidated Chunked Backup Helper
            const performChunkedBackup = async (textOnly = false) => {
                if (!window.Capacitor) { alert("Backup requires Android App (Native Filesystem)."); return; }
                try {
                    const { Filesystem } = window.Capacitor.Plugins;
                    const allBooks = await db.books.toArray();
                    const now = new Date();
                    const ts = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0') + '_' + String(now.getHours()).padStart(2, '0') + '-' + String(now.getMinutes()).padStart(2, '0') + '-' + String(now.getSeconds()).padStart(2, '0');

                    const folder = localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups';
                    const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                    const targetDir = Directory[baseStr] || Directory.Documents;

                    // Ensure Folder
                    try { await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true }); } catch (e) { }

                    const TARGET_SIZE = 9 * 1024 * 1024; // 9MB safe limit for chunks
                    let part = 1;
                    let currentChunk = [];
                    let currentSize = 0;
                    const suffix = textOnly ? '_TextOnly' : '';

                    for (const rawBook of allBooks) {
                        const book = textOnly ? { ...rawBook, front: null, rear: null, thumb: null, pages: [] } : rawBook;
                        const s = JSON.stringify(book);
                        if (currentSize + s.length > TARGET_SIZE && currentChunk.length > 0) {
                            const fname = `ShelfLife_Part${part}${suffix}_${ts}.json`;
                            await Filesystem.writeFile({
                                path: `${folder}/${fname}`,
                                data: JSON.stringify(currentChunk),
                                directory: targetDir,
                                encoding: Encoding.UTF8
                            });
                            part++;
                            currentChunk = [];
                            currentSize = 0;
                        }
                        currentChunk.push(book);
                        currentSize += s.length;
                    }

                    if (currentChunk.length > 0) {
                        const fname = `ShelfLife_Part${part}${suffix}_${ts}.json`;
                        await Filesystem.writeFile({
                            path: `${folder}/${fname}`,
                            data: JSON.stringify(currentChunk),
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                    }

                    alert(`Backup (${textOnly ? 'Text Only' : 'Full'}) Complete!\nSaved ${part} file(s) to:\n${baseStr}/${folder}/`);

                    // Track backup for reminder system
                    localStorage.setItem('shelfLife_lastBackupDate', new Date().toISOString());
                    localStorage.setItem('shelfLife_entriesSinceBackup', '0');
                } catch (e) {
                    alert("Backup Error: " + e.message);
                }
            };

            // Native Restore Helper with Folder Picker
            const performNativeRestore = async () => {
                if (!window.Capacitor) { alert("Restore requires Android App (Native Filesystem)."); return; }
                try {
                    const { Filesystem } = window.Capacitor.Plugins;
                    const FilePicker = window.Capacitor.Plugins.FilePicker;

                    let folderPath;
                    let targetDir;

                    // Try visual folder picker first
                    if (FilePicker && FilePicker.pickDirectory) {
                        try {
                            const picked = await FilePicker.pickDirectory();
                            if (picked && picked.path) {
                                folderPath = picked.path;
                                targetDir = null; // Use absolute path
                            }
                        } catch (pickerError) {
                            // User cancelled or picker failed - fall back to manual
                            console.log("Picker cancelled or unavailable:", pickerError);
                        }
                    }

                    // Fallback to manual entry if picker didn't work
                    if (!folderPath) {
                        const folder = localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups';
                        const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                        targetDir = Directory[baseStr] || Directory.Documents;

                        const folderInput = prompt("Select folder manually (or Cancel and try again):", folder);
                        if (!folderInput) return;
                        folderPath = folderInput;
                        if (folderInput !== folder) localStorage.setItem('shelfLife_backupFolder', folderInput);
                    }

                    // Read the selected folder
                    const ret = await Filesystem.readdir({
                        path: folderPath,
                        directory: targetDir // null for absolute paths from picker
                    }).catch(e => ({ files: [] }));

                    const groups = {};
                    (ret.files || []).forEach(f => {
                        const name = f.name;
                        // Match standard format AND TextOnly format
                        const m = name.match(/ShelfLife_Part\d+(?:_TextOnly)?_(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})\.json/);
                        if (m) {
                            const ts = m[1];
                            if (!groups[ts]) groups[ts] = 0;
                            groups[ts]++;
                        }
                    });

                    const choices = Object.keys(groups).sort().reverse();
                    if (choices.length === 0) { alert(`No backups found in ${baseStr}/${folderInput}`); return; }

                    const selection = prompt(`Found ${choices.length} Backup Sets in ${folderInput}:\n` + choices.map((c, i) => `${i + 1}. ${c} (${groups[c]} parts)`).join('\n') + "\n\nEnter number to restore:");
                    if (!selection) return;
                    const index = parseInt(selection) - 1;
                    if (isNaN(index) || index < 0 || index >= choices.length) return;

                    const targetTs = choices[index];
                    if (!confirm(`Restore ${targetTs}?\nWARNING: This will WIPE and REPLACE your current library.`)) return;

                    await db.books.clear();

                    const fileList = (ret.files || []).filter(f => f.name.includes(targetTs)).sort();

                    let count = 0;
                    for (const f of fileList) {
                        const c = await Filesystem.readFile({
                            path: `${folderInput}/${f.name}`,
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        const chunkData = JSON.parse(c.data);
                        await db.books.bulkAdd(chunkData);
                        count += chunkData.length;
                    }

                    // UPDATE METADATA
                    localStorage.setItem('shelfLife_restore_meta', JSON.stringify({ name: targetTs, date: new Date().toLocaleString() }));

                    alert(`Restored ${count} books from ${targetTs}.`);
                    window.location.reload();

                } catch (e) {
                    alert("Restore Error: " + e.message);
                }
            };

            // Legacy/Single File Import
            const handleLegacyImport = (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (evt) => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        if (!Array.isArray(data)) throw new Error("Invalid JSON Format");
                        if (!confirm(`Restore ${data.length} books from file "${file.name}"?\nWarning: This will REPLACE your library.`)) return;

                        await db.books.clear();
                        await db.books.bulkAdd(data);
                        alert("Legacy Restore Complete!");
                        window.location.reload();
                    } catch (err) {
                        alert("Import Failed: " + err.message);
                    }
                };
                reader.readAsText(file);
            };

            // Test Folder Creation
            const verifyFolder = async () => {
                if (!window.Capacitor) return;
                try {
                    const { Filesystem } = window.Capacitor.Plugins;
                    const folder = localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups';
                    const baseStr = localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS';
                    const targetDir = Directory[baseStr] || Directory.Documents;

                    await Filesystem.mkdir({ path: folder, directory: targetDir, recursive: true });
                    await Filesystem.writeFile({
                        path: `${folder}/Test_Write.txt`,
                        data: "Access Verified " + new Date().toISOString(),
                        directory: targetDir,
                        encoding: Encoding.UTF8
                    });
                    alert(`Success!\nFolder "${folder}" is writable in ${baseStr}.`);
                } catch (e) {
                    alert("Folder Access Failed: " + e.message);
                }
            };

            return (
                <div className="p-4 space-y-4 pb-24">
                    <h2 className="text-2xl font-bold">Tools</h2>

                    <div className="bg-white p-4 rounded-xl shadow border border-blue-100">
                        <h3 className="font-bold mb-3 text-blue-800">Reports</h3>

                        {/* EXPORT SETTINGS */}
                        <div className="mb-3 bg-blue-50 p-2 rounded">
                            <label className="text-[10px] font-bold text-blue-800 uppercase block mb-1">Export Location</label>
                            <div className="flex gap-2">
                                <select
                                    className="p-1 text-xs border rounded bg-white"
                                    defaultValue={localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS'}
                                    onChange={(e) => localStorage.setItem('shelfLife_exportBase', e.target.value)}
                                >
                                    <option value="DOCUMENTS">Documents/</option>
                                    <option value="EXTERNAL_STORAGE">External/</option>
                                </select>
                                <input
                                    className="flex-1 p-1 text-xs border rounded"
                                    placeholder="ShelfLife_Exports"
                                    defaultValue={localStorage.getItem('shelfLife_exportFolder') || 'ShelfLife_Exports'}
                                    onBlur={(e) => localStorage.setItem('shelfLife_exportFolder', e.target.value || 'ShelfLife_Exports')}
                                />
                            </div>
                        </div>

                        <div className="space-y-2">
                            <button onClick={() => ExportUtils.htmlText(books, 'Mix', 'Library Inventory', localStorage.getItem('shelfLife_exportFolder') || 'ShelfLife_Exports', localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="List" /> HTML Text Report</button>
                            <button onClick={() => ExportUtils.htmlVisual(books, 'Mix', 'Visual Catalogue', localStorage.getItem('shelfLife_exportFolder') || 'ShelfLife_Exports', localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="Image" /> HTML Visual Catalogue</button>
                            <button onClick={() => ExportUtils.csv(books, 'Mix', localStorage.getItem('shelfLife_exportFolder') || 'ShelfLife_Exports', localStorage.getItem('shelfLife_exportBase') || 'DOCUMENTS')} className="w-full py-3 bg-gray-50 rounded-lg flex items-center justify-center gap-2 text-sm"><Icon name="Download" /> Export CSV</button>
                        </div>
                    </div>

                    <div className="bg-white p-4 rounded-xl shadow border border-orange-100">
                        <h3 className="font-bold mb-3 text-orange-800">Backup & Restore</h3>
                        {lastRestore && <div className="text-xs text-gray-500 mb-3 bg-gray-50 p-2 rounded border">Last Restored: <b>{lastRestore.name}</b><br />{lastRestore.date}</div>}

                        {/* DATA SYNC SETTINGS */}
                        <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                            <h4 className="font-bold text-xs uppercase text-yellow-800 mb-2">Storage Settings</h4>
                            <div className="flex gap-2 mb-2 items-center">
                                <select
                                    className="p-1 text-xs border rounded bg-white text-yellow-900"
                                    defaultValue={localStorage.getItem('shelfLife_backupBase') || 'DOCUMENTS'}
                                    onChange={(e) => localStorage.setItem('shelfLife_backupBase', e.target.value)}
                                >
                                    <option value="DOCUMENTS">Documents/</option>
                                    <option value="EXTERNAL_STORAGE">External/</option>
                                </select>
                                <input
                                    className="flex-1 p-1 text-xs border rounded"
                                    placeholder="ShelfLife_Backups"
                                    defaultValue={localStorage.getItem('shelfLife_backupFolder') || 'ShelfLife_Backups'}
                                    onBlur={(e) => localStorage.setItem('shelfLife_backupFolder', e.target.value || 'ShelfLife_Backups')}
                                />
                            </div>
                            <button onClick={verifyFolder} className="w-full py-1 bg-yellow-100 text-yellow-800 rounded text-[10px] font-bold mb-2">Test Folder Creation</button>

                            <hr className="border-yellow-200 my-3" />

                            <h4 className="font-bold text-xs uppercase text-yellow-800 mb-2">Backups</h4>
                            <div className="grid grid-cols-2 gap-2 mb-4">
                                <button onClick={() => performChunkedBackup(false)} className="py-2 bg-yellow-600 text-white rounded text-xs font-bold flex flex-col items-center gap-1"><Icon name="Save" size={16} /> Full Backup<span className="text-[9px] opacity-80">(Images)</span></button>
                                <button onClick={() => performChunkedBackup(true)} className="py-2 bg-yellow-700 text-white rounded text-xs font-bold flex flex-col items-center gap-1"><Icon name="FileText" size={16} /> Text-Only<span className="text-[9px] opacity-80">(No Images)</span></button>
                            </div>

                            <h4 className="font-bold text-xs uppercase text-yellow-800 mb-2">Restore</h4>
                            <div className="space-y-2">
                                <button onClick={performNativeRestore} className="w-full py-2 bg-gray-700 text-white rounded text-xs font-bold flex items-center justify-center gap-2"><Icon name="RefreshCcw" /> Scan & Restore from Folder</button>
                                <label className="w-full py-2 bg-gray-500 text-white rounded text-xs font-bold flex items-center justify-center gap-2 cursor-pointer">
                                    <Icon name="Upload" /> Restore Legacy JSON File
                                    <input type="file" onChange={handleLegacyImport} accept=".json" className="hidden" />
                                </label>
                            </div>
                        </div>
                    </div>
                    <div className="bg-white p-4 rounded-xl shadow border">
                        <h3 className="font-bold mb-3">Tag Manager</h3>
                        <TagManager books={books} onClose={() => { }} />
                    </div>
                </div >
            );
        };

        // --- TAG MANAGER ---
        const TagManager = ({ books, onClose }) => {
            const tags = useMemo(() => { const t = {}; books.forEach(b => { if (b.tags) b.tags.forEach(x => t[x] = (t[x] || 0) + 1) }); return Object.entries(t).sort((a, b) => b[1] - a[1]); }, [books]);

            const handleRename = async (oldTag) => {
                const newTag = prompt(`Rename ${oldTag} to:`);
                if (!newTag || newTag === oldTag) return;
                const affected = books.filter(b => b.tags && b.tags.includes(oldTag));
                for (const b of affected) {
                    const newTags = b.tags.filter(t => t !== oldTag);
                    if (!newTags.includes(newTag)) newTags.push(newTag);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert("Tag Renamed!");
            };

            const handleMerge = async (oldTag) => {
                const target = prompt(`Merge #${oldTag} into existing tag (Books will move to new tag):`);
                if (!target || target === oldTag) return;
                const affected = books.filter(b => b.tags && b.tags.includes(oldTag));
                for (const b of affected) {
                    let newTags = b.tags.filter(t => t !== oldTag);
                    if (!newTags.includes(target)) newTags.push(target);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert(`Merged #${oldTag} -> #${target}`);
            };

            const handleDelete = async (tag) => {
                if (!confirm(`Delete tag "${tag}" from ${tags.find(t => t[0] === tag)[1]} books?`)) return;
                const affected = books.filter(b => b.tags && b.tags.includes(tag));
                for (const b of affected) {
                    let newTags = b.tags.filter(t => t !== tag);
                    await db.books.update(b.id, { tags: newTags });
                }
                alert("Tag Deleted");
            };

            return (
                <div className="h-64 overflow-y-auto border rounded p-2">
                    {tags.length === 0 && <p className="text-sm text-gray-400">No tags used.</p>}
                    {tags.map(([t, c]) => (
                        <div key={t} className="flex justify-between p-2 border-b text-sm items-center">
                            <span><b>{t}</b> ({c})</span>
                            <div className="flex gap-2">
                                <button onClick={() => handleRename(t)} title="Rename" className="text-blue-500"><Icon name="Edit3" size={14} /></button>
                                <button onClick={() => handleMerge(t)} title="Merge" className="text-purple-500"><Icon name="Merge" size={14} /></button>
                                <button onClick={() => handleDelete(t)} title="Delete" className="text-red-500"><Icon name="Trash2" size={14} /></button>
                            </div>
                        </div>
                    ))}
                </div>
            );
        };

        // --- APP HEADER ---
        const AppHeader = ({ title = "ShelfLife" }) => (
            <div className="bg-blue-900 text-white p-4 shadow-md sticky top-0 z-50 flex items-center justify-between no-print">
                <div className="flex items-center gap-3">
                    <div className="bg-white/10 p-2 rounded-lg"><Icon name="Library" size={20} /></div>
                    <div>
                        <h1 className="font-bold text-lg leading-none">{title}</h1>
                        <p className="text-[10px] text-blue-200 opacity-80">Personal Library Manager</p>
                    </div>
                </div>
            </div>
        );

        // --- SETUP MODAL ---
        const SetupModal = ({ onComplete }) => {
            const [folder, setFolder] = useState('ShelfLife_Backups');
            const [base, setBase] = useState('DOCUMENTS');
            const [status, setStatus] = useState('');

            const requestPerms = async () => {
                if (!window.Capacitor) return;
                try {
                    const { Filesystem, Camera } = window.Capacitor.Plugins;
                    setStatus('Requesting permissions...');
                    try { await Filesystem.requestPermissions(); } catch (e) { }
                    try { await Camera.requestPermissions(); } catch (e) { }

                    // Save Prefs
                    localStorage.setItem('shelfLife_backupFolder', folder);
                    localStorage.setItem('shelfLife_backupBase', base);

                    // Test Create with Force Write
                    const targetDir = Directory[base] || Directory.Documents;
                    try {
                        await Filesystem.mkdir({
                            path: folder,
                            directory: targetDir,
                            recursive: true
                        });
                        // Create a test file to REALLY verify write access
                        await Filesystem.writeFile({
                            path: `${folder}/.test_marker`,
                            data: 'Setup Complete',
                            directory: targetDir,
                            encoding: Encoding.UTF8
                        });
                        // Clean up
                        try { await Filesystem.deleteFile({ path: `${folder}/.test_marker`, directory: targetDir }); } catch (e) { }

                        setStatus('Permissions Granted & Folder Verified!');
                    } catch (e) {
                        setStatus('Error: ' + e.message);
                        alert("Folder Creation Failed.\nTry changing 'Storage Location' to External, or use a different folder name.");
                    }
                } catch (e) {
                    setStatus('Setup Error: ' + e.message);
                }
            };

            return (
                <div className="fixed inset-0 bg-black/80 z-[100] flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl p-6 w-full max-w-sm shadow-2xl animate-[fadeIn_0.3s_ease-out]">
                        <div className="text-center mb-6">
                            <div className="inline-block p-4 bg-blue-100 rounded-full text-blue-600 mb-3"><Icon name="Library" size={32} /></div>
                            <h2 className="text-xl font-bold text-gray-800">Welcome to ShelfLife</h2>
                            <p className="text-sm text-gray-500 mt-1">Let's set up your secure storage.</p>
                        </div>

                        <div className="space-y-4">
                            <div>
                                <label className="block text-xs font-bold text-gray-700 uppercase mb-1">Storage Location</label>
                                <div className="flex gap-2">
                                    <select className="p-3 border rounded-lg bg-gray-50 text-xs font-bold" value={base} onChange={e => setBase(e.target.value)}>
                                        <option value="DOCUMENTS">Documents/</option>
                                        <option value="EXTERNAL_STORAGE">External/</option>
                                    </select>
                                    <input
                                        className="flex-1 p-3 border rounded-lg bg-gray-50 focus:ring-2 focus:ring-blue-500 outline-none transition-all"
                                        value={folder}
                                        onChange={e => setFolder(e.target.value)}
                                        placeholder="FolderName"
                                    />
                                </div>
                                <p className="text-[10px] text-gray-400 mt-1">Files will be saved to: {base}/{folder}/</p>
                            </div>

                            <button onClick={requestPerms} className="w-full py-2 bg-gray-100 hover:bg-gray-200 text-gray-800 font-bold rounded-lg border border-gray-300 text-xs">
                                🔓 Grant Storage Permissions & Test
                            </button>
                            {status && <div className={`text-center text-[10px] font-bold p-1 rounded ${status.includes('Error') ? 'text-red-600 bg-red-50' : 'text-green-600 bg-green-50'}`}>{status}</div>}

                            <button onClick={onComplete} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-lg transform transition active:scale-95">
                                Start Using App
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- APP ROOT ---
        const App = () => {
            const [view, setView] = useState('library');
            const [books, setBooks] = useState([]);
            const [editBook, setEditBook] = useState(null);
            const [currency, setCurrency] = useState(() => localStorage.getItem('shelfLife_currency') || '₹');
            const [showSetup, setShowSetup] = useState(false);

            useEffect(() => {
                // Startup Check for Folder
                if (!localStorage.getItem('shelfLife_backupFolder')) {
                    setShowSetup(true);
                }

                const l = async () => setBooks(await db.books.toArray());
                l();
                setInterval(l, 1000);

                // Android Back Button & Permissions Logic
                try {
                    if (window.Capacitor) {
                        const { App } = window.Capacitor.Plugins;
                        // Handle Back Button
                        App.addListener('backButton', ({ canGoBack }) => {
                            if (canGoBack) {
                                window.history.back();
                            } else {
                                if (confirm('Do you want to exit ShelfLife?')) {
                                    App.exitApp();
                                }
                            }
                        });

                        // Request Permissions
                        (async () => {
                            try {
                                const { Filesystem, Directory } = window.Capacitor.Plugins;
                                await Filesystem.readdir({ path: 'Documents', directory: Directory.External }).catch(() => { });
                            } catch (e) { console.log("Perms check silent fail", e); }
                        })();

                        console.log("Native listeners active");

                        // Exit confirmation on back button
                        const CapApp = window.Capacitor.Plugins.App;
                        if (CapApp && CapApp.addListener) {
                            CapApp.addListener('backButton', ({ canGoBack }) => {
                                if (!canGoBack) {
                                    if (confirm("Do you want to exit ShelfLife?")) {
                                        CapApp.exitApp();
                                    }
                                } else {
                                    window.history.back();
                                }
                            });
                        }
                    }
                } catch (e) { console.error("Native setup error", e); }

            }, []);

            // Pull to refresh logic
            useEffect(() => {
                let startY = 0;
                const spinner = document.getElementById('ptr-spinner');

                const touchStart = (e) => { if (window.scrollY === 0) startY = e.touches[0].clientY; };
                const touchMove = (e) => {
                    if (!startY) return;
                    const y = e.touches[0].clientY;
                    const diff = y - startY;
                    if (diff > 0 && window.scrollY === 0) {
                        if (diff > 80) spinner.style.top = '20px'; // Show
                        else spinner.style.top = '-50px';
                    }
                };
                const touchEnd = (e) => {
                    if (spinner.style.top === '20px') {
                        startY = 0;
                        setTimeout(() => window.location.reload(), 500);
                    }
                };

                window.addEventListener('touchstart', touchStart);
                window.addEventListener('touchmove', touchMove);
                window.addEventListener('touchend', touchEnd);
                return () => {
                    window.removeEventListener('touchstart', touchStart);
                    window.removeEventListener('touchmove', touchMove);
                    window.removeEventListener('touchend', touchEnd);
                };
            }, []);

            useEffect(() => {
                localStorage.setItem('shelfLife_currency', currency);
            }, [currency]);

            // Save Logic
            const save = async (d) => {
                try {
                    if (d.id) await db.books.put(d);
                    else {
                        await db.books.add({ ...d, date_added: Date.now() });

                        // Track entries since backup for reminder
                        const count = parseInt(localStorage.getItem('shelfLife_entriesSinceBackup') || '0') + 1;
                        localStorage.setItem('shelfLife_entriesSinceBackup', count.toString());
                    }
                    setEditBook(null);
                    setView('library');

                    // Check if backup reminder needed
                    const lastBackup = localStorage.getItem('shelfLife_lastBackupDate');
                    const entriesSince = parseInt(localStorage.getItem('shelfLife_entriesSinceBackup') || '0');
                    const daysSince = lastBackup ? Math.floor((Date.now() - new Date(lastBackup).getTime()) / 86400000) : 999;

                    if ((daysSince >= 7 || entriesSince >= 10) && !sessionStorage.getItem('backupReminderShown')) {
                        sessionStorage.setItem('backupReminderShown', 'true');
                        setTimeout(() => {
                            if (confirm(`Backup Reminder:\n${entriesSince} new entries since last backup.\nWould you like to backup now?`)) {
                                setView('settings');
                            }
                        }, 1000);
                    }
                } catch (err) {
                    alert("Database Error: " + err.message + "\nCheck storage space?");
                }
            };

            const deleteMulti = async (ids) => { if (confirm(`Delete ${ids.length} books?`)) { await db.books.bulkDelete(ids); } };

            if (editBook || view === 'add') return (
                <div className="max-w-md mx-auto min-h-screen bg-gray-50">
                    <AppHeader />
                    <BookForm book={editBook} onSave={save} onCancel={() => { setEditBook(null); setView('library') }} onBarcodeFound={(b) => { setEditBook(b); setView('add') }} globalCurrency={currency} />
                </div>
            );

            return (
                <div className="max-w-md mx-auto min-h-screen bg-gray-50 shadow-2xl relative overflow-hidden">
                    {showSetup && <SetupModal onComplete={() => setShowSetup(false)} />}

                    <AppHeader />

                    <main className="p-4 pb-24 safe-area-top">
                        {view === 'library' && <LibraryView books={books} onEdit={(b) => { setEditBook(b); }} onDeleteMulti={deleteMulti} />}
                        {view === 'search' && <SlicerSearch books={books} onEdit={(b) => { setEditBook(b); setView('add') }} />}
                        {view === 'reports' && <Dashboard books={books} />}
                        {view === 'settings' && <Tools books={books} currency={currency} setCurrency={setCurrency} />}
                    </main>

                    <nav className="fixed bottom-0 w-full max-w-md bg-white border-t flex justify-around py-3 pb-safe z-30 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                        <button onClick={() => setView('library')} className={view === 'library' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Library" /><span className="block text-[10px]">Lib</span></button>
                        <button onClick={() => setView('search')} className={view === 'search' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Search" /><span className="block text-[10px]">Search</span></button>
                        <button onClick={() => setView('add')} className={view === 'add' ? 'text-blue-600' : 'text-gray-400'}><Icon name="PlusSquare" /><span className="block text-[10px]">Add</span></button>
                        <button onClick={() => setView('reports')} className={view === 'reports' ? 'text-blue-600' : 'text-gray-400'}><Icon name="BarChart2" /><span className="block text-[10px]">Stats</span></button>
                        <button onClick={() => setView('settings')} className={view === 'settings' ? 'text-blue-600' : 'text-gray-400'}><Icon name="Settings" /><span className="block text-[10px]">Tools</span></button>
                    </nav>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>

</html>